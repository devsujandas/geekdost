[
  {
    "id": "cpp",
    "title": "C++ Programming",
    "desc": "A comprehensive roadmap for C++ from beginner to expert, covering fundamentals, OOP, STL, modern features, and advanced topics.",
    "description": "This roadmap provides a structured learning path for mastering the C++ programming language. It starts with the absolute basics of setting up your environment and understanding syntax, then progressively moves through control flow, functions, and pointers. The curriculum heavily emphasizes Object-Oriented Programming (OOP), covering everything from basic classes to advanced concepts like polymorphism, inheritance, and design patterns. You will gain a deep understanding of memory management, a critical skill in C++. The roadmap also dives deep into the Standard Template Library (STL), teaching you how to use its powerful containers, iterators, and algorithms to write efficient code. As you advance, you'll explore modern C++ features (C++11/14/17/20), multithreading, and concurrency. Finally, the roadmap concludes with essential tools and best practices, including build systems like CMake, version control with Git, unit testing, debugging, and writing clean, maintainable code, preparing you for real-world software development challenges.",
    "category": "Programming",
    "categories": ["Programming", "System", "OOP"],
    "difficulty": "Advanced",
    "image": "/images/cpp.jpg",
    "icon": "SiCplusplus",
    "chapters": [
      {
        "id": "c1-introduction",
        "title": "Introduction & Setup",
        "desc": "Learn C++ history, set up your compiler and IDE, and write your first program.",
        "notes": "Welcome to the start of your C++ journey! This foundational chapter is all about getting you set up and comfortable with the C++ ecosystem. We'll begin by exploring the rich history of C++, understanding its origins from the C language and its evolution into the powerful, versatile tool it is today. Created by Bjarne Stroustrup, its primary goal was to add object-oriented features to C, but it has since grown to include many other paradigms. Next, we'll demystify the tools of the trade. You'll learn what a compiler is (like GCC's g++ or Clang) and its crucial role in translating your human-readable code into machine-executable instructions. We'll guide you through installing a compiler and setting up an Integrated Development Environment (IDE) like Visual Studio Code, CLion, or Visual Studio, which will make your coding process much smoother with features like syntax highlighting, debugging, and project management. The highlight of this chapter is writing and running your first 'Hello, World!' program. This simple exercise will walk you through the entire development workflow: writing the source code, compiling it into an executable file, and running it from the terminal. Understanding this compile-run cycle is fundamental to all C++ development.",
        "code": "",
        "duration": "1 week",
        "topics": [
          {
            "id": "t1-history",
            "title": "History of C++",
            "desc": "Explore the origin and evolution of the C++ language.",
            "note": "C++ was developed by Bjarne Stroustrup at Bell Labs, starting in 1979. Initially named 'C with Classes,' it was designed to be a superset of the C language, adding object-oriented features like classes to the existing power and efficiency of C. The goal was to create a language that could handle large-scale software projects while retaining the low-level memory manipulation capabilities that C was famous for. The name was changed to C++ in 1983, a nod to the `++` increment operator in C, humorously suggesting its incremental improvement over C. The first commercial version was released in 1985. A key milestone in its history was the standardization process, which led to the first international standard in 1998, known as C++98. This was followed by minor updates in C++03. The language then underwent a major revolution with the release of C++11, which introduced a vast number of new features like lambda expressions, smart pointers, and range-based for loops, making the language safer, more expressive, and easier to use. This modernization trend continued with subsequent releases like C++14, C++17, and C++20, which added even more features like concepts, modules, and coroutines. Today, C++ is one of the most widely used programming languages in the world, powering high-performance applications in domains like game development, financial trading systems, operating systems, and embedded systems.",
            "code": "// Example 1\n#include <iostream>\n\nint main() {\n    std::cout << \"C++ was created by Bjarne Stroustrup.\" << std::endl;\n    std::cout << \"Its initial name was 'C with Classes'.\" << std::endl;\n    return 0;\n}\n\n// Example 2\n#include <iostream>\n\nint main() {\n    const int firstStandardYear = 1998; // C++98\n    const int modernCppYear = 2011; // C++11\n    std::cout << \"First ISO standard for C++ was in \" << firstStandardYear << std::endl;\n    std::cout << \"The modern era of C++ began with C++11 in \" << modernCppYear << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t2-compilers-ide",
            "title": "Compilers, IDEs, and Workflow",
            "desc": "Understand compilers, set up an IDE, and learn the development workflow.",
            "note": "To start programming in C++, you need two essential tools: a text editor to write your code and a compiler to translate it into a program your computer can run. While you can use any basic text editor, an Integrated Development Environment (IDE) is highly recommended. An IDE combines a text editor with other useful tools, such as a compiler, a debugger, and a project builder, into a single application. Popular IDEs for C++ include Visual Studio (Windows), Xcode (macOS), CLion (cross-platform), and the lightweight yet powerful Visual Studio Code with C++ extensions. The compiler is the core component that processes your source code (the `.cpp` files you write). It checks your code for syntax errors and, if everything is correct, converts it into machine code, creating an executable file. The most common C++ compilers are GCC (GNU Compiler Collection, which includes g++), Clang, and MSVC (Microsoft Visual C++). The basic development workflow consists of three main steps: 1. **Write:** You write your C++ code in a `.cpp` file using your editor or IDE. 2. **Compile:** You use a compiler to transform your `.cpp` file into an executable. For example, in a terminal, you might run the command `g++ my_program.cpp -o my_program`. This tells the `g++` compiler to compile `my_program.cpp` and create an executable file named `my_program`. 3. **Run:** You execute the compiled program by typing its name in the terminal, for example, `./my_program`. This workflow is fundamental to C++ development.",
            "code": "// Example 1: A simple hello world program to be saved as hello.cpp\n#include <iostream>\n\nint main() {\n    // This line prints the message to the console.\n    std::cout << \"Hello, Compiler!\" << std::endl;\n    return 0; // Indicates successful execution\n}\n// To compile and run from terminal:\n// g++ hello.cpp -o hello\n// ./hello\n\n// Example 2: Demonstrating the separation of source code and execution\n#include <iostream>\n\nint main() {\n    int number = 10;\n    std::cout << \"This code is in a .cpp file.\" << std::endl;\n    std::cout << \"After compiling, it becomes an executable.\" << std::endl;\n    std::cout << \"The value of 'number' is: \" << number << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t3-first-program",
            "title": "Your First Program",
            "desc": "Write, compile, and run the classic 'Hello, World!' program.",
            "note": "Writing your first program is a rite of passage in learning any new language. In C++, the classic 'Hello, World!' program serves as a simple introduction to the basic structure of a C++ program. Let's break down the components. `#include <iostream>` is a preprocessor directive. It tells the compiler to include the contents of the `iostream` header file, which contains declarations for input/output operations, like printing text to the screen. `int main()` is the main function. Every C++ program must have a `main` function, as it is the starting point of execution. The `int` indicates that the function returns an integer value. The curly braces `{}` define the scope of the function; all the code inside them belongs to the `main` function. `std::cout` is the standard character output stream, used to print text. The `<<` operator is the stream insertion operator; it 'inserts' the data that follows it into the stream. The text to be printed, \"Hello, World!\", is enclosed in double quotes, making it a string literal. `std::endl` is a manipulator that inserts a newline character and flushes the output buffer, moving the cursor to the next line. `return 0;` terminates the `main` function and returns the value 0 to the operating system, signifying that the program executed successfully. This simple program demonstrates the essential elements you'll see in almost every C++ application.",
            "code": "// Example 1: The classic 'Hello, World!'\n#include <iostream>\n\nint main() {\n    // std::cout is used for printing to the console\n    // std::endl adds a new line\n    std::cout << \"Hello, World!\" << std::endl;\n    return 0;\n}\n\n// Example 2: Printing multiple lines\n#include <iostream>\n\nint main() {\n    std::cout << \"This is the first line.\" << std::endl;\n    std::cout << \"This is the second line.\" << std::endl;\n    std::cout << \"You can print numbers too: \" << 42 << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c2-basic-syntax",
        "title": "Basic Syntax & Data Types",
        "desc": "Learn about variables, data types, literals, constants, and operators.",
        "notes": "Now that you have your environment set up, it's time to learn the fundamental building blocks of the C++ language. This chapter introduces you to the basic syntax and data types that form the core of any C++ program. We'll start with variables, which are named storage locations for holding data. You'll learn how to declare variables, what the rules are for naming them, and how to assign values to them. Closely tied to variables are data types, which tell the compiler what kind of data a variable can hold and how much memory to allocate for it. We'll cover the fundamental types, including `int` for integers, `double` and `float` for floating-point numbers, `char` for single characters, and `bool` for true/false values. We will also explore literals and constants. Literals are the fixed values you write directly in your code (like `101`, `3.14`, or `'A'`), while constants are variables whose values cannot be changed after they are initialized. Using constants can make your code safer and more readable. Finally, we'll dive into operators, the symbols that perform operations on variables and values. We will cover arithmetic operators (`+`, `-`, `*`, `/`, `%`), assignment operators (`=`, `+=`, `-=`), comparison operators (`==`, `!=`, `<`, `>`), and logical operators (`&&`, `||`, `!`). A solid grasp of these concepts is essential before moving on to more complex topics.",
        "code": "",
        "duration": "1 week",
        "topics": [
          {
            "id": "t1-variables",
            "title": "Variables and Data Types",
            "desc": "Understand how to declare and use variables of different data types.",
            "note": "In C++, a variable is a name given to a memory location. It is the basic unit of storage in a program. Before you can use a variable, you must declare it, which involves specifying its type and name. The type determines the size and layout of the variable's memory, the range of values that can be stored within that memory, and the set of operations that can be applied to it. For example, `int age;` declares a variable named `age` of type `integer`. C++ has several built-in (primitive) data types: `int` for whole numbers (e.g., 10, -5), `double` and `float` for numbers with decimal points (e.g., 3.14, -0.05), `char` for single characters (e.g., 'a', '$'), and `bool` for logical values (`true` or `false`). You can also use type modifiers like `short`, `long`, `signed`, and `unsigned` to alter the storage size or range of these basic types. For instance, `unsigned int` can only hold non-negative values, but its maximum value is roughly twice that of a `signed int`. Initialization is the process of assigning an initial value to a variable at the time of its declaration, like `int score = 0;`. It's a good practice to always initialize your variables to avoid using them with indeterminate 'garbage' values, which can lead to unpredictable program behavior.",
            "code": "// Example 1: Declaring and initializing different data types\n#include <iostream>\n\nint main() {\n    int age = 30;               // Integer type\n    double price = 19.99;       // Double-precision floating point\n    char initial = 'J';         // Character type\n    bool isStudent = true;      // Boolean type\n\n    std::cout << \"Age: \" << age << std::endl;\n    std::cout << \"Price: $\" << price << std::endl;\n    std::cout << \"Initial: \" << initial << std::endl;\n    std::cout << \"Is student? \" << isStudent << std::endl; // bool prints as 1 or 0\n    return 0;\n}\n\n// Example 2: Using type modifiers\n#include <iostream>\n\nint main() {\n    unsigned int positiveNumber = 40000;\n    long long bigNumber = 9000000000LL;\n    float smallPi = 3.14f;\n\n    std::cout << \"Positive Number: \" << positiveNumber << std::endl;\n    std::cout << \"Big Number: \" << bigNumber << std::endl;\n    std::cout << \"Small Pi (float): \" << smallPi << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t2-constants",
            "title": "Constants and Literals",
            "desc": "Learn how to define constants and understand different types of literals.",
            "note": "A literal is a value that is written directly into the source code. For example, in the statement `int x = 100;`, `100` is an integer literal. Literals can be of any basic data type. `3.14` is a double literal, `'A'` is a character literal, and `\"hello\"` is a string literal. Sometimes, you need to store a value that should not be changed throughout the program's execution. These are called constants. C++ provides two main ways to define constants. The first is using the `const` keyword. When you declare a variable with `const`, you are telling the compiler that its value is read-only and cannot be modified after initialization. For example, `const double PI = 3.14159;`. Any attempt to change the value of `PI` later in the code will result in a compilation error. This makes your code safer and more self-documenting, as it clearly communicates the intent that a value should not change. The second method is using the `#define` preprocessor directive, like `#define PI 3.14159`. However, using `const` is generally preferred in modern C++ because it is type-safe and respects scope, whereas `#define` is a simple text substitution performed by the preprocessor before compilation, which can sometimes lead to unexpected errors.",
            "code": "// Example 1: Using the 'const' keyword to define constants\n#include <iostream>\n\nint main() {\n    const int DAYS_IN_WEEK = 7;\n    const double GRAVITY = 9.81;\n\n    // DAYS_IN_WEEK = 8; // This would cause a compile error\n\n    std::cout << \"There are \" << DAYS_IN_WEEK << \" days in a week.\" << std::endl;\n    std::cout << \"Earth's gravity is approx \" << GRAVITY << \" m/s^2.\" << std::endl;\n    return 0;\n}\n\n// Example 2: Different types of literals\n#include <iostream>\n\nint main() {\n    int integerLiteral = 42;\n    double doubleLiteral = 3.14;\n    char charLiteral = 'C';\n    const char* stringLiteral = \"Hello, C++!\"; // C-style string literal\n    bool boolLiteral = true;\n\n    std::cout << integerLiteral << std::endl;\n    std::cout << doubleLiteral << std::endl;\n    std::cout << charLiteral << std::endl;\n    std::cout << stringLiteral << std::endl;\n    std::cout << boolLiteral << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t3-operators",
            "title": "Operators in C++",
            "desc": "Explore arithmetic, relational, logical, and assignment operators.",
            "note": "Operators are special symbols that perform operations on one or more operands (variables and values) and produce a result. C++ is rich with built-in operators. **Arithmetic Operators** perform mathematical calculations: `+` (addition), `-` (subtraction), `*` (multiplication), `/` (division), and `%` (modulus, which gives the remainder of a division). **Assignment Operators** are used to assign values to variables. The basic assignment operator is `=`, but there are also compound assignment operators like `+=`, `-=`, `*=`, and `/=`, which combine an arithmetic operation with an assignment (e.g., `x += 5` is shorthand for `x = x + 5`). **Relational Operators** are used to compare two values and result in a boolean (`true` or `false`) value: `==` (equal to), `!=` (not equal to), `>` (greater than), `<` (less than), `>=` (greater than or equal to), and `<=` (less than or equal to). **Logical Operators** are used to combine or modify boolean expressions: `&&` (logical AND), `||` (logical OR), and `!` (logical NOT). These are crucial for creating complex conditions in control flow statements. There are other types of operators as well, such as bitwise operators and the ternary operator, which we'll explore later. Understanding operator precedence is also important, as it determines the order in which operators are evaluated in a complex expression (e.g., `*` and `/` are evaluated before `+` and `-`).",
            "code": "// Example 1: Arithmetic and Assignment Operators\n#include <iostream>\n\nint main() {\n    int a = 10, b = 4;\n    std::cout << \"a + b = \" << (a + b) << std::endl;\n    std::cout << \"a - b = \" << (a - b) << std::endl;\n    std::cout << \"a * b = \" << (a * b) << std::endl;\n    std::cout << \"a / b = \" << (a / b) << std::endl; // Integer division\n    std::cout << \"a % b = \" << (a % b) << std::endl; // Modulus\n\n    a += b; // a is now 14\n    std::cout << \"After a += b, a is \" << a << std::endl;\n    return 0;\n}\n\n// Example 2: Relational and Logical Operators\n#include <iostream>\n\nint main() {\n    int x = 5, y = 8;\n    std::cout << std::boolalpha; // Print bools as 'true' or 'false'\n\n    std::cout << \"x > y: \" << (x > y) << std::endl;\n    std::cout << \"x <= y: \" << (x <= y) << std::endl;\n    std::cout << \"x == 5: \" << (x == 5) << std::endl;\n\n    bool condition1 = (x > 0) && (y > 0);\n    bool condition2 = (x > y) || (y > 0);\n    std::cout << \"(x > 0) AND (y > 0): \" << condition1 << std::endl;\n    std::cout << \"(x > y) OR (y > 0): \" << condition2 << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c3-control-flow",
        "title": "Control Flow",
        "desc": "Master decision-making with if-else and switch, and repetition with loops.",
        "notes": "Control flow statements are the decision-making constructs of a programming language. They allow you to alter the default sequential execution of code, enabling your program to respond differently to various inputs and conditions. This chapter covers the two main categories of control flow: conditional statements and loops. First, we'll explore conditional (or selection) statements. The `if`, `if-else`, and `if-else if` statements allow your program to execute a certain block of code only if a specific condition is true. This is the primary way to introduce branching logic into your applications. We'll also cover the `switch` statement, which provides a clean way to compare a variable against a list of possible constant values, often serving as a more readable alternative to a long chain of `if-else if` statements. The second part of the chapter focuses on loops (or iteration statements), which are used to execute a block of code repeatedly. We'll cover the three main types of loops in C++: the `for` loop, which is ideal when you know in advance how many times you want to iterate; the `while` loop, which repeats as long as a given condition remains true; and the `do-while` loop, which is similar to the `while` loop but guarantees that the loop body is executed at least once. Finally, we'll look at the `break` and `continue` statements, which give you finer control over loop execution by allowing you to exit a loop prematurely or skip the current iteration, respectively.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-if-else",
            "title": "If-Else Statements",
            "desc": "Use if, if-else, and nested if-else to create branching logic.",
            "note": "The `if` statement is the most fundamental control flow construct. It allows a program to make a decision based on a condition. The syntax is straightforward: `if (condition) { /* code to execute */ }`. The `condition` inside the parentheses is evaluated. If it resolves to `true`, the code block inside the curly braces is executed. If it resolves to `false`, the block is skipped, and the program continues with the next statement after the `if` block. To handle the case where the condition is false, you can add an `else` clause: `if (condition) { /* block A */ } else { /* block B */ }`. Here, if the condition is `true`, block A is executed; otherwise, block B is executed. This ensures that one of the two blocks will always run. For more complex scenarios involving multiple conditions, you can chain these statements using `else if`. This allows you to test a series of conditions in order. The first condition that evaluates to `true` will have its corresponding code block executed, and the rest of the chain will be skipped. A final `else` block can be added at the end to act as a default case, which runs if none of the preceding `if` or `else if` conditions were met. This structure is incredibly powerful for implementing logic, from simple checks to complex decision trees.",
            "code": "// Example 1: Simple if-else statement\n#include <iostream>\n\nint main() {\n    int score = 85;\n    if (score >= 60) {\n        std::cout << \"You passed!\" << std::endl;\n    } else {\n        std::cout << \"You failed. Better luck next time.\" << std::endl;\n    }\n    return 0;\n}\n\n// Example 2: Using if-else if-else for grading\n#include <iostream>\n\nint main() {\n    int grade = 78;\n    if (grade >= 90) {\n        std::cout << \"Grade: A\" << std::endl;\n    } else if (grade >= 80) {\n        std::cout << \"Grade: B\" << std::endl;\n    } else if (grade >= 70) {\n        std::cout << \"Grade: C\" << std::endl;\n    } else {\n        std::cout << \"Grade: F\" << std::endl;\n    }\n    return 0;\n}"
          },
          {
            "id": "t2-switch",
            "title": "Switch Statement",
            "desc": "Use the switch statement for multi-way branching based on a single value.",
            "note": "The `switch` statement provides an alternative to a long `if-else if-else` chain when you need to check a single variable against a series of constant integer or character values. It can often make the code cleaner and more readable. The structure of a `switch` statement involves a control expression (the variable you're testing) and a series of `case` labels. The program evaluates the control expression and jumps to the `case` label whose value matches. The code following that `case` is then executed. A crucial component of the `switch` statement is the `break` keyword. When a `break` is encountered, it immediately exits the `switch` block. If you omit the `break` after a `case`, execution will 'fall through' to the next `case`'s code block, which is sometimes intended but often a source of bugs if done accidentally. You can also include a `default` label. The `default` block is executed if the control expression's value does not match any of the `case` labels. It serves a similar purpose to the final `else` in an `if-else if` chain. The `switch` statement is less flexible than `if-else` because it cannot handle ranges or complex boolean expressions; it only works with equality checks against constant integral types (like `int`, `char`, `enum`).",
            "code": "// Example 1: A simple menu using switch\n#include <iostream>\n\nint main() {\n    int choice = 2;\n    switch (choice) {\n        case 1:\n            std::cout << \"You chose Option 1.\" << std::endl;\n            break;\n        case 2:\n            std::cout << \"You chose Option 2.\" << std::endl;\n            break;\n        case 3:\n            std::cout << \"You chose Option 3.\" << std::endl;\n            break;\n        default:\n            std::cout << \"Invalid choice.\" << std::endl;\n            break;\n    }\n    return 0;\n}\n\n// Example 2: Switch with fall-through behavior\n#include <iostream>\n\nint main() {\n    char grade = 'B';\n    switch (grade) {\n        case 'A':\n            std::cout << \"Excellent! \";\n            // No break, falls through\n        case 'B':\n        case 'C':\n            std::cout << \"Well done.\" << std::endl;\n            break;\n        case 'D':\n            std::cout << \"You passed.\" << std::endl;\n            break;\n        default:\n            std::cout << \"Try again.\" << std::endl;\n            break;\n    }\n    return 0;\n}"
          },
          {
            "id": "t3-loops",
            "title": "Loops (for, while, do-while)",
            "desc": "Execute blocks of code repeatedly using for, while, and do-while loops.",
            "note": "Loops are fundamental for automation and iteration. The `for` loop is ideal for situations where you know the number of iterations beforehand. It consists of three parts in its header: initialization (executed once before the loop starts), condition (checked before each iteration), and increment/decrement (executed at the end of each iteration). For example, `for (int i = 0; i < 5; i++) { ... }` will run the loop body exactly five times. The `while` loop is more suitable when the number of iterations is not known in advance, and the loop continues as long as a certain condition is met. The syntax is `while (condition) { /* loop body */ }`. The condition is checked at the beginning of each iteration. If it's initially false, the loop body never executes. The `do-while` loop is a variation of the `while` loop. Its syntax is `do { /* loop body */ } while (condition);`. The key difference is that the condition is checked at the *end* of the iteration. This guarantees that the loop body will be executed at least once, regardless of whether the condition is initially true or false. This is useful for scenarios like prompting a user for input and validating it, where you need to get the input at least once.",
            "code": "// Example 1: A 'for' loop to print numbers 1 to 5\n#include <iostream>\n\nint main() {\n    for (int i = 1; i <= 5; ++i) {\n        std::cout << \"Iteration \" << i << std::endl;\n    }\n    return 0;\n}\n\n// Example 2: A 'while' loop for user input validation\n#include <iostream>\n\nint main() {\n    int number = 0;\n    // The loop continues as long as the user enters a non-positive number\n    while (number <= 0) {\n        std::cout << \"Enter a positive number: \";\n        std::cin >> number;\n    }\n    std::cout << \"You entered: \" << number << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t4-break-continue",
            "title": "Break and Continue",
            "desc": "Control loop execution with the break and continue statements.",
            "note": "The `break` and `continue` statements provide additional control over the flow within loops and `switch` statements. The `break` statement is used to terminate a loop (`for`, `while`, `do-while`) or a `switch` statement prematurely. When a `break` statement is encountered inside a loop, the loop is immediately exited, and program execution resumes at the next statement following the loop. This is useful for stopping an iteration process when a specific condition is met, such as finding an item in a list or encountering an error. For example, you might loop through an array to find a specific value, and once you find it, there's no need to continue looping, so you can `break`. The `continue` statement, on the other hand, is used to skip the current iteration of a loop and move to the next one. When `continue` is encountered, the rest of the code inside the current loop iteration is skipped, and the loop's control condition is re-evaluated (for `while` and `do-while`) or the update expression is executed (for `for` loops) before the next iteration begins. This is helpful when you want to bypass a specific case within a loop without terminating the entire loop. For instance, you might be processing a list of numbers and want to skip all negative numbers.",
            "code": "// Example 1: Using 'break' to exit a loop early\n#include <iostream>\n\nint main() {\n    for (int i = 1; i <= 10; ++i) {\n        if (i == 5) {\n            std::cout << \"Found 5, breaking loop.\" << std::endl;\n            break; // Exit the loop\n        }\n        std::cout << i << std::endl;\n    }\n    std::cout << \"Loop finished.\" << std::endl;\n    return 0;\n}\n\n// Example 2: Using 'continue' to skip an iteration\n#include <iostream>\n\nint main() {\n    for (int i = 1; i <= 10; ++i) {\n        if (i % 2 != 0) { // Check if the number is odd\n            continue; // Skip the rest of the loop for odd numbers\n        }\n        std::cout << i << \" is an even number.\" << std::endl;\n    }\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c4-functions",
        "title": "Functions & Recursion",
        "desc": "Learn to write modular code with functions, overloading, and recursion.",
        "notes": "Functions are the cornerstone of modular, reusable, and organized code in C++. Instead of writing a long, monolithic block of code in `main()`, you can break down your program into smaller, manageable, and self-contained units called functions. Each function performs a specific task. This chapter will teach you how to define and use functions effectively. We'll start with the basics of function declaration (prototype) and definition (implementation). A declaration tells the compiler about a function's name, return type, and parameters, while the definition provides the actual body of the function. We will then explore function overloading, a powerful feature that allows you to define multiple functions with the same name, as long as they have different parameter lists. This lets you create more intuitive interfaces. You'll also learn about inline functions, a performance optimization technique for very short functions, and default arguments, which make your functions more flexible by allowing callers to omit certain parameters. A key concept in this chapter is recursion. A recursive function is one that calls itself to solve a problem. We will explore how recursion works, its relationship with the call stack, and how to solve problems like calculating factorials or traversing tree structures recursively. Understanding functions is a critical step towards writing any non-trivial C++ program and is essential for object-oriented programming.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-declaration-definition",
            "title": "Function Declaration and Definition",
            "desc": "Understand the difference between declaring and defining a function.",
            "note": "In C++, there is a crucial distinction between a function's declaration and its definition. A function declaration, also known as a function prototype, introduces the function's name, its return type, and the types of its parameters to the compiler. It's essentially a blueprint for the function. The declaration doesn't contain the actual code that the function executes; it simply tells the compiler that a function with this signature exists somewhere in the program. This allows you to call a function before it has been defined, as long as it has been declared. Declarations are often placed in header files (`.h` or `.hpp`). A function definition, on the other hand, provides the actual implementation of the function—the code block that runs when the function is called. A function can be declared multiple times in a program (though it's redundant), but it can only be defined once. This is known as the One Definition Rule (ODR). The basic structure of a definition is: `return_type function_name(parameter_list) { // function body }`. For example, `int add(int a, int b);` is a declaration, while `int add(int a, int b) { return a + b; }` is the corresponding definition. Separating declaration from definition is key to organizing large projects, allowing different parts of the code to know about functions without needing to know how they work internally.",
            "code": "// Example 1: Declaration and Definition are separate\n#include <iostream>\n\n// Function declaration (prototype)\nvoid greet(); \n\nint main() {\n    greet(); // Function call\n    return 0;\n}\n\n// Function definition (implementation)\nvoid greet() {\n    std::cout << \"Hello from the greet function!\" << std::endl;\n}\n\n// Example 2: Function with parameters and return value\n#include <iostream>\n\n// Function declaration\nint multiply(int x, int y);\n\nint main() {\n    int result = multiply(5, 10);\n    std::cout << \"The result is: \" << result << std::endl;\n    return 0;\n}\n\n// Function definition\nint multiply(int x, int y) {\n    return x * y;\n}"
          },
          {
            "id": "t2-overloading",
            "title": "Function Overloading",
            "desc": "Define multiple functions with the same name but different parameters.",
            "note": "Function overloading is a feature of C++ that allows you to have two or more functions with the same name in the same scope, provided that their parameter lists are different. The difference can be in the number of parameters, the type of parameters, or the order of parameters. This enables you to create functions that perform similar operations on different types of data without having to invent new names for each one. For example, you could have an `add` function that works for integers (`int add(int, int)`) and another `add` function that works for doubles (`double add(double, double)`). When you call an overloaded function, the compiler determines which version of the function to execute based on the arguments you provide in the function call. This process is called overload resolution. The compiler matches the types and number of arguments to the parameter lists of the available overloaded functions. If a unique match is found, that function is called. If no match is found, or if the call is ambiguous (i.e., it could match more than one overloaded function), the compiler will issue an error. Note that the return type of the function is not considered for overloading. Two functions cannot be overloaded if they only differ by their return type.",
            "code": "// Example 1: Overloading a 'print' function for different data types\n#include <iostream>\n\nvoid print(int i) {\n    std::cout << \"Printing an integer: \" << i << std::endl;\n}\n\nvoid print(double d) {\n    std::cout << \"Printing a double: \" << d << std::endl;\n}\n\nvoid print(const char* c) {\n    std::cout << \"Printing a string: \" << c << std::endl;\n}\n\nint main() {\n    print(10);\n    print(3.14);\n    print(\"Hello C++\");\n    return 0;\n}\n\n// Example 2: Overloading based on number of parameters\n#include <iostream>\n\nint sum(int a, int b) {\n    return a + b;\n}\n\nint sum(int a, int b, int c) {\n    return a + b + c;\n}\n\nint main() {\n    std::cout << \"Sum of 2 numbers: \" << sum(5, 10) << std::endl;\n    std::cout << \"Sum of 3 numbers: \" << sum(5, 10, 15) << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t3-recursion",
            "title": "Recursion",
            "desc": "Solve problems by creating functions that call themselves.",
            "note": "Recursion is a powerful programming technique where a function calls itself, either directly or indirectly, to solve a problem. A recursive solution breaks a problem down into smaller, simpler subproblems that are identical in nature to the original problem. This process continues until the problem becomes so simple that it can be solved directly. Every recursive function must have two key components. The first is the **base case**: a condition under which the function does not call itself and instead returns a direct result. The base case is crucial because it prevents the recursion from continuing infinitely, which would lead to a stack overflow error. The second component is the **recursive step**: the part of the function that calls itself, but with modified arguments that move it closer to the base case. A classic example of recursion is calculating the factorial of a number. The factorial of n (n!) is the product of all positive integers up to n. This can be defined recursively: `factorial(n) = n * factorial(n-1)`, with the base case `factorial(0) = 1`. When a function is called, its state (local variables, parameters) is pushed onto the program's call stack. In recursion, each recursive call adds a new frame to the stack. When the base case is reached, the functions start returning, and the frames are popped off the stack one by one. While elegant, recursion can be less efficient than iterative solutions due to the overhead of function calls.",
            "code": "// Example 1: Calculating factorial using recursion\n#include <iostream>\n\nlong long factorial(int n) {\n    // Base case: factorial of 0 or 1 is 1\n    if (n <= 1) {\n        return 1;\n    }\n    // Recursive step: n * factorial of (n-1)\n    return n * factorial(n - 1);\n}\n\nint main() {\n    int number = 5;\n    std::cout << \"Factorial of \" << number << \" is \" << factorial(number) << std::endl;\n    return 0;\n}\n\n// Example 2: Fibonacci sequence using recursion\n#include <iostream>\n\nint fibonacci(int n) {\n    // Base cases\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n    \n    // Recursive step\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int term = 7;\n    std::cout << \"The \" << term << \"th term of Fibonacci is \" << fibonacci(term) << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c5-pointers-references",
        "title": "Pointers & References",
        "desc": "Understand memory addresses, pointers, pointer arithmetic, and references.",
        "notes": "Pointers and references are among the most powerful and challenging features of C++. They allow for direct memory manipulation, which is key to the language's performance and flexibility, but they also require careful handling to avoid errors. This chapter will provide a thorough understanding of these concepts. A pointer is a special variable that holds the memory address of another variable. Instead of storing a value directly, it 'points to' the location where a value is stored. We'll cover how to declare pointers using the asterisk (`*`), how to get the address of a variable using the address-of operator (`&`), and how to access the value at a pointer's address using the dereference operator (`*`). You'll learn about pointer arithmetic, which allows you to perform mathematical operations on pointers to navigate through blocks of memory, a concept fundamental to working with arrays. We will then introduce references. A reference is an alias or an alternative name for an existing variable. Once initialized, a reference cannot be changed to refer to another variable. They are often simpler and safer to use than pointers, especially for passing arguments to functions, as they provide a way to modify the original variable without the more complex syntax of pointers. Finally, we'll look at more advanced topics like pointers to functions, which allow you to store the address of a function and call it dynamically, enabling powerful techniques like callbacks.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-pointer-basics",
            "title": "Pointer Basics",
            "desc": "Learn how to declare, initialize, and dereference pointers.",
            "note": "A pointer is a variable whose value is the memory address of another variable. Every variable in your program is stored at a specific location in the computer's memory, and this location has a unique address. A pointer simply holds that address. To declare a pointer, you use the asterisk (`*`) symbol. For example, `int* ptr;` declares a pointer named `ptr` that is intended to point to an integer. To make a pointer point to a variable, you use the address-of operator (`&`). For example, if you have `int number = 10;`, you can make `ptr` point to `number` with the statement `ptr = &number;`. Now, `ptr` holds the memory address of the `number` variable. The real power of pointers comes from the dereference operator, which is also the asterisk (`*`). When used on a pointer variable, it retrieves the value stored at the memory address the pointer is holding. So, `*ptr` would evaluate to `10`. You can use this to both read and modify the original variable's value. For instance, `*ptr = 20;` would change the value of `number` to `20`. It's crucial to initialize pointers before using them. An uninitialized pointer contains a garbage address and dereferencing it can crash your program. A good practice is to initialize pointers to `nullptr` (a C++11 keyword) if they don't point to a valid memory location yet.",
            "code": "// Example 1: Declaring, initializing, and dereferencing a pointer\n#include <iostream>\n\nint main() {\n    int number = 50;\n    int* ptr = &number; // ptr holds the address of 'number'\n\n    std::cout << \"Value of number: \" << number << std::endl;\n    std::cout << \"Address of number: \" << &number << std::endl;\n    std::cout << \"Value of ptr (the address it holds): \" << ptr << std::endl;\n    std::cout << \"Value pointed to by ptr: \" << *ptr << std::endl;\n\n    *ptr = 100; // Modify the value of 'number' via the pointer\n    std::cout << \"New value of number: \" << number << std::endl;\n    return 0;\n}\n\n// Example 2: Using nullptr for safe pointer initialization\n#include <iostream>\n\nint main() {\n    int* safePtr = nullptr; // Initialize pointer to null\n\n    if (safePtr != nullptr) {\n        // This code won't execute because safePtr is null\n        std::cout << \"Value: \" << *safePtr << std::endl;\n    } else {\n        std::cout << \"safePtr is a null pointer.\" << std::endl;\n    }\n    return 0;\n}"
          },
          {
            "id": "t2-references",
            "title": "References",
            "desc": "Learn to use references as aliases for other variables.",
            "note": "A reference in C++ is an alias, or an alternative name, for an existing variable. Unlike a pointer, which stores a memory address, a reference acts as another name for the same piece of memory. You declare a reference using the ampersand (`&`) symbol. For example, `int original = 10; int& ref = original;`. Here, `ref` is a reference to `original`. Any operation performed on `ref` is actually performed on `original`. If you execute `ref = 20;`, the value of `original` will also become `20`. References have a few key properties that distinguish them from pointers. First, a reference must be initialized when it is declared. You cannot have an uninitialized reference. Second, once a reference is initialized to refer to a variable, it cannot be 'reseated' or changed to refer to a different variable. It will always be an alias for the original variable it was assigned to. Third, you don't need a special dereferencing operator to access the value; you just use the reference's name directly. Because of these properties, references are often considered simpler and safer than pointers. They are particularly useful for passing arguments to functions 'by reference', which allows the function to modify the original argument without the caller having to pass a memory address explicitly. This avoids making a copy of the argument, which can be a significant performance benefit for large objects.",
            "code": "// Example 1: Basic reference usage\n#include <iostream>\n\nint main() {\n    int value = 25;\n    int& ref = value; // 'ref' is now an alias for 'value'\n\n    std::cout << \"Original value: \" << value << std::endl;\n    std::cout << \"Reference value: \" << ref << std::endl;\n\n    ref = 100; // Modifying the reference changes the original\n\n    std::cout << \"New original value: \" << value << std::endl;\n    std::cout << \"New reference value: \" << ref << std::endl;\n    return 0;\n}\n\n// Example 2: Using references in functions to modify arguments\n#include <iostream>\n\n// The function takes an integer by reference\nvoid increment(int& num) {\n    num++; // This modifies the original variable passed to the function\n}\n\nint main() {\n    int myNumber = 10;\n    std::cout << \"Before calling increment: \" << myNumber << std::endl;\n    increment(myNumber);\n    std::cout << \"After calling increment: \" << myNumber << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c6-arrays-strings",
        "title": "Arrays & Strings",
        "desc": "Work with fixed-size arrays, C-style strings, and the std::string class.",
        "notes": "This chapter focuses on handling collections of data using arrays and strings, two fundamental data structures. An array is a collection of elements of the same data type, stored in contiguous memory locations. This contiguous storage allows for efficient, constant-time access to any element based on its index. We'll cover how to declare one-dimensional (1D) and two-dimensional (2D) arrays, how to initialize them with values, and how to access and modify their elements using an index. A crucial aspect we'll explore is the close relationship between arrays and pointers in C++. The name of an array often decays into a pointer to its first element, a concept that is essential for understanding how to pass arrays to functions and perform pointer arithmetic on them. Next, we will delve into strings. C++ has two main ways of handling strings. The first is the traditional C-style string, which is simply an array of characters terminated by a special null character (`'\\0'`). We'll look at how to work with these and the common pitfalls associated with them, such as buffer overflows. The second, and highly preferred, method is using the `std::string` class from the C++ Standard Library. This class provides a much safer, more powerful, and easier-to-use interface for string manipulation. It handles memory management automatically, provides a rich set of member functions for operations like concatenation, searching, and substring extraction, and integrates seamlessly with other parts of the standard library.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-arrays",
            "title": "Arrays",
            "desc": "Learn to declare, initialize, and access elements in 1D and 2D arrays.",
            "note": "An array is a data structure that stores a fixed-size, sequential collection of elements of the same type. Think of it as a row of numbered boxes, where each box holds a value of the same kind. You declare an array by specifying the type of its elements, its name, and its size in square brackets. For example, `int scores[5];` declares an array named `scores` that can hold 5 integers. The elements of an array are accessed using a zero-based index. This means the first element is at index 0, the second at index 1, and so on, up to `size - 1`. So, for our `scores` array, the valid indices are 0, 1, 2, 3, and 4. You can access an element with `scores[0]`, `scores[1]`, etc. You can initialize an array at the time of declaration using an initializer list, like `int numbers[3] = {10, 20, 30};`. C++ also supports multi-dimensional arrays. A two-dimensional array, for instance, can be thought of as a grid or a table. You declare it with two size specifiers: `int matrix[3][4];` creates a 2D array with 3 rows and 4 columns. You access its elements with two indices, `matrix[row][col]`. A key characteristic of C-style arrays is that they don't have built-in bounds checking, so accessing an element outside the array's defined range (e.g., `scores[5]`) leads to undefined behavior, a common source of bugs.",
            "code": "// Example 1: One-dimensional array\n#include <iostream>\n\nint main() {\n    int numbers[5] = {10, 20, 30, 40, 50};\n\n    std::cout << \"The first element is: \" << numbers[0] << std::endl;\n    std::cout << \"The third element is: \" << numbers[2] << std::endl;\n\n    numbers[1] = 25; // Change the second element\n\n    std::cout << \"The elements are: \";\n    for (int i = 0; i < 5; ++i) {\n        std::cout << numbers[i] << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n\n// Example 2: Two-dimensional array (matrix)\n#include <iostream>\n\nint main() {\n    int matrix[2][3] = {\n        {1, 2, 3},\n        {4, 5, 6}\n    };\n\n    std::cout << \"Element at row 1, column 2 is: \" << matrix[1][2] << std::endl;\n\n    // Print the entire matrix\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            std::cout << matrix[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}"
          },
          {
            "id": "t2-cpp-strings",
            "title": "C++ std::string",
            "desc": "Use the std::string class for safe and efficient string manipulation.",
            "note": "The `std::string` class, part of the C++ Standard Library, is the modern, recommended way to handle strings. It's a vast improvement over traditional C-style character arrays because it manages its own memory, eliminating many common errors like buffer overflows and memory leaks. To use it, you must include the `<string>` header. Creating a string is simple: `std::string greeting = \"Hello, World!\";`. The `std::string` class provides a wealth of useful member functions. You can get the length of a string using the `.length()` or `.size()` method. You can concatenate strings easily using the `+` or `+=` operators. For example, `std::string name = \"John\"; std::string message = \"Hello, \" + name;`. You can access individual characters using the same array-like square bracket notation (`greeting[0]`) or the `.at()` method, which provides bounds checking and throws an exception if the index is invalid. Other powerful features include methods for finding substrings (`.find()`), extracting substrings (`.substr()`), and comparing strings using standard relational operators (`==`, `!=`, `<`, `>`). Because `std::string` handles memory allocation dynamically, it can grow or shrink as needed. This flexibility, combined with its robust interface and safety features, makes `std::string` an essential tool for any C++ programmer.",
            "code": "// Example 1: Basic std::string operations\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string firstName = \"Bjarne\";\n    std::string lastName = \"Stroustrup\";\n\n    // Concatenation\n    std::string fullName = firstName + \" \" + lastName;\n\n    std::cout << \"Full Name: \" << fullName << std::endl;\n    std::cout << \"Length of name: \" << fullName.length() << std::endl;\n    std::cout << \"First character: \" << fullName[0] << std::endl;\n\n    return 0;\n}\n\n// Example 2: Finding and creating substrings\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string sentence = \"C++ is a powerful language.\";\n\n    // Find the position of a substring\n    size_t pos = sentence.find(\"powerful\");\n\n    if (pos != std::string::npos) { // npos means 'not found'\n        std::cout << \"'powerful' found at index: \" << pos << std::endl;\n    }\n\n    // Create a substring\n    std::string sub = sentence.substr(0, 3); // Get \"C++\"\n    std::cout << \"Substring: \" << sub << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c7-oop-basics",
        "title": "Object-Oriented Basics",
        "desc": "Learn the fundamentals of OOP: classes, objects, constructors, and destructors.",
        "notes": "This chapter marks a pivotal transition from procedural to Object-Oriented Programming (OOP), a paradigm that C++ was designed to support. OOP is a way of structuring programs around 'objects' rather than 'actions'. An object bundles data (attributes) and the methods (functions) that operate on that data into a single unit. This approach helps in creating modular, reusable, and maintainable code for complex software systems. We'll start with the most fundamental concept: the class. A class is a blueprint or a template for creating objects. It defines the properties (member variables) and behaviors (member functions) that all objects of that class will have. An object is a specific instance of a class. For example, if you have a `Car` class, then a specific `myCar` would be an object of that class. You'll learn about access specifiers (`public`, `private`, and `protected`), which are crucial for encapsulation—the bundling of data with the methods that operate on it and restricting direct access to an object's components. We will then cover special member functions: constructors and destructors. A constructor is a method that is automatically called when an object is created, used for initializing the object's state. A destructor is automatically called when an object is destroyed, used for cleaning up resources. Finally, we'll introduce the `this` pointer, a special pointer that exists within every member function and points to the object that invoked the function.",
        "code": "",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-classes-objects",
            "title": "Classes and Objects",
            "desc": "Define blueprints (classes) and create instances (objects).",
            "note": "A class is a user-defined data type that acts as a blueprint for creating objects. It encapsulates data (attributes, implemented as member variables) and methods (behaviors, implemented as member functions) that operate on that data. For example, you could define a `Dog` class. Its attributes might be `name`, `breed`, and `age`, and its methods could be `bark()`, `wagTail()`, and `fetch()`. The class definition itself doesn't create any dogs; it just describes what a dog is. An object is a concrete instance of a class. Once a class is defined, you can create multiple objects from it. For example, `Dog myDog;` creates an object named `myDog` of the `Dog` class. Each object has its own set of member variables. So, if you create another object, `Dog neighborDog;`, it will have its own `name`, `breed`, and `age`, separate from `myDog`. You access the members (variables and functions) of an object using the dot (`.`) operator. For example, `myDog.name = \"Fido\";` would set the name of the `myDog` object, and `myDog.bark();` would call its `bark` method. This bundling of data and functionality is a core principle of OOP and helps in creating well-structured, logical programs.",
            "code": "// Example 1: Defining a simple Car class and creating objects\n#include <iostream>\n#include <string>\n\nclass Car {\npublic:\n    std::string brand;\n    std::string model;\n    int year;\n\n    void displayInfo() {\n        std::cout << year << \" \" << brand << \" \" << model << std::endl;\n    }\n};\n\nint main() {\n    Car car1; // Create an object of Car class\n    car1.brand = \"Toyota\";\n    car1.model = \"Camry\";\n    car1.year = 2021;\n\n    Car car2;\n    car2.brand = \"Honda\";\n    car2.model = \"Civic\";\n    car2.year = 2022;\n\n    car1.displayInfo();\n    car2.displayInfo();\n    return 0;\n}\n\n// Example 2: A simple Rectangle class\n#include <iostream>\n\nclass Rectangle {\npublic:\n    double width;\n    double height;\n\n    double getArea() {\n        return width * height;\n    }\n};\n\nint main() {\n    Rectangle rect;\n    rect.width = 5.0;\n    rect.height = 10.0;\n\n    std::cout << \"The area of the rectangle is: \" << rect.getArea() << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t2-constructors-destructors",
            "title": "Constructors and Destructors",
            "desc": "Initialize objects with constructors and clean up with destructors.",
            "note": "A constructor is a special member function of a class that is executed automatically whenever a new object of that class is created. Its primary purpose is to initialize the object's member variables to appropriate starting values. A constructor has the same name as the class and does not have a return type, not even `void`. If you don't define a constructor, the compiler provides a default one for you. You can define your own constructors to take arguments, which allows you to create and initialize an object in a single step. For example, `Car myCar(\"Ford\", \"Mustang\", 2023);`. This is known as a parameterized constructor. A class can also have multiple overloaded constructors. A destructor is another special member function that is called automatically when an object goes out of scope or is explicitly deleted. Its purpose is to perform cleanup tasks before the object is destroyed, such as releasing memory that was allocated by the object. A destructor has the same name as the class, but preceded by a tilde (`~`), and it cannot take any arguments or have a return type. For simple classes, a destructor may not be necessary, but for classes that manage resources like dynamic memory, files, or network connections, it is essential for preventing resource leaks.",
            "code": "// Example 1: Class with a constructor and destructor\n#include <iostream>\n#include <string>\n\nclass Message {\npublic:\n    // Constructor\n    Message(std::string text) {\n        std::cout << \"Constructor called! Message created with text: \" << text << std::endl;\n        messageText = text;\n    }\n\n    // Destructor\n    ~Message() {\n        std::cout << \"Destructor called! Message '\" << messageText << \"' is being destroyed.\" << std::endl;\n    }\n\nprivate:\n    std::string messageText;\n};\n\nint main() {\n    std::cout << \"Entering main function.\" << std::endl;\n    Message msg(\"Hello\");\n    std::cout << \"Exiting main function.\" << std::endl;\n    return 0;\n}\n\n// Example 2: Class with overloaded constructors\n#include <iostream>\n#include <string>\n\nclass Box {\npublic:\n    // Default constructor\n    Box() : width(1), height(1) {}\n\n    // Parameterized constructor\n    Box(double w, double h) : width(w), height(h) {}\n\n    void display() {\n        std::cout << \"Box with width \" << width << \" and height \" << height << std::endl;\n    }\nprivate:\n    double width;\n    double height;\n};\n\nint main() {\n    Box defaultBox; // Uses the default constructor\n    Box customBox(10.5, 5.2); // Uses the parameterized constructor\n    defaultBox.display();\n    customBox.display();\n    return 0;\n}"
          },
          {
            "id": "t3-this-pointer",
            "title": "The 'this' Pointer",
            "desc": "Understand the 'this' pointer and its use inside member functions.",
            "note": "In C++, every object has access to its own address through a special pointer called the `this` pointer. The `this` pointer is an implicit parameter to all non-static member functions. Therefore, inside a member function, `this` may be used to refer to the invoking object. It's a pointer to the object on which the member function was called. A primary use of the `this` pointer is to resolve ambiguity between member variables and function parameters that have the same name. For instance, in a constructor, it's common to have parameters with the same names as the class's member variables. To distinguish between them, you can use `this->memberVariable = parameter;`. Here, `this->memberVariable` refers to the member variable of the object, while `parameter` refers to the local parameter of the function. Another use of the `this` pointer is to return a reference to the current object from a member function, which allows for function chaining (also known as fluent interface). For example, a function could perform an operation and then `return *this;`, allowing another member function to be called on the same object in the same statement, like `myObject.setX(10).setY(20);`. The type of the `this` pointer for a class `MyClass` is `MyClass*`. In a `const` member function, its type is `const MyClass*`, meaning you cannot use it to modify the object's members.",
            "code": "// Example 1: Using 'this' to resolve name ambiguity\n#include <iostream>\n\nclass Box {\npublic:\n    // Constructor parameters have same names as member variables\n    Box(int width, int height) {\n        // 'this->width' refers to the member variable\n        // 'width' refers to the function parameter\n        this->width = width;\n        this->height = height;\n    }\n\n    void display() {\n        std::cout << \"Width: \" << this->width << \", Height: \" << this->height << std::endl;\n    }\n\nprivate:\n    int width;\n    int height;\n};\n\nint main() {\n    Box b(10, 20);\n    b.display();\n    return 0;\n}\n\n// Example 2: Chaining method calls by returning *this\n#include <iostream>\n\nclass Counter {\npublic:\n    Counter() : value(0) {}\n\n    Counter& increment() {\n        value++;\n        return *this; // Return a reference to the current object\n    }\n\n    Counter& decrement() {\n        value--;\n        return *this;\n    }\n\n    void print() {\n        std::cout << \"Current value: \" << value << std::endl;\n    }\n\nprivate:\n    int value;\n};\n\nint main() {\n    Counter c;\n    c.increment().increment().increment().decrement();\n    c.print(); // Prints 2\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c8-oop-advanced",
        "title": "OOP Advanced",
        "desc": "Explore inheritance, polymorphism, virtual functions, and abstract classes.",
        "notes": "Building on the basics of OOP, this chapter delves into the advanced concepts that give C++ its power and flexibility for building complex, hierarchical systems. We will focus on the pillars of OOP: inheritance and polymorphism. Inheritance is the mechanism by which one class (the derived or child class) can inherit the properties and behaviors of another class (the base or parent class). This promotes code reuse and establishes an 'is-a' relationship between classes (e.g., a `Dog` is an `Animal`). You'll learn how to implement inheritance and understand the different access specifiers (`public`, `protected`, `private`) that control how base class members are accessed in the derived class. The true power of inheritance is realized through polymorphism, which means 'many forms'. In C++, polymorphism allows you to treat objects of different derived classes as if they were objects of their common base class. This is achieved through virtual functions. A virtual function is a member function in a base class that you expect to be redefined (overridden) in derived classes. When you call a virtual function through a base class pointer or reference, C++ determines which version of the function to call at runtime based on the actual type of the object, a mechanism known as dynamic binding. This leads us to abstract classes and interfaces. An abstract class is a class that cannot be instantiated on its own and is designed to be a base for other classes. It often contains one or more pure virtual functions, which are virtual functions with no implementation, forcing derived classes to provide their own.",
        "code": "",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-inheritance",
            "title": "Inheritance",
            "desc": "Create new classes from existing ones to reuse code and establish relationships.",
            "note": "Inheritance is a fundamental principle of Object-Oriented Programming that allows a new class, called the derived class (or subclass), to be based on an existing class, called the base class (or superclass). The derived class inherits the public and protected members (both variables and functions) of the base class. This models an 'is-a' relationship. For example, a `Car` is a `Vehicle`, so you could have a `Vehicle` base class and a `Car` derived class. The `Car` class would automatically have all the properties of a `Vehicle` (like `speed`, `weight`) and could add its own specific properties (like `numberOfDoors`). The syntax for inheritance is `class DerivedClass : accessSpecifier BaseClass { ... };`. The `accessSpecifier` (usually `public`) determines how the inherited members of the base class are accessed from within the derived class and by outside code. With `public` inheritance, public members of the base class become public members of the derived class, and protected members of the base class become protected members of the derived class. Private members of the base class are not accessible by the derived class at all. Inheritance is a powerful tool for code reuse, as you can write common functionality in a base class and then create multiple specialized derived classes without duplicating code. It also forms the foundation for polymorphism.",
            "code": "// Example 1: Basic inheritance\n#include <iostream>\n#include <string>\n\n// Base class\nclass Animal {\npublic:\n    void eat() {\n        std::cout << \"This animal eats food.\" << std::endl;\n    }\n};\n\n// Derived class\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"The dog barks: Woof!\" << std::endl;\n    }\n};\n\nint main() {\n    Dog myDog;\n    myDog.eat();  // Inherited from Animal\n    myDog.bark(); // Defined in Dog\n    return 0;\n}\n\n// Example 2: Inheritance with member variables\n#include <iostream>\n#include <string>\n\nclass Vehicle {\npublic:\n    std::string brand = \"Ford\";\n};\n\nclass Car : public Vehicle {\npublic:\n    std::string model = \"Mustang\";\n};\n\nint main() {\n    Car myCar;\n    std::cout << \"Brand: \" << myCar.brand << std::endl;   // Accessing base class member\n    std::cout << \"Model: \" << myCar.model << std::endl;   // Accessing derived class member\n    return 0;\n}"
          },
          {
            "id": "t2-polymorphism",
            "title": "Polymorphism and Virtual Functions",
            "desc": "Achieve polymorphism using base class pointers and virtual functions.",
            "note": "Polymorphism allows objects of different classes to be treated through a common interface. In C++, this is primarily achieved at runtime through virtual functions and base class pointers or references. Here's how it works: you define a common interface in a base class using `virtual` functions. A `virtual` function is a member function that you declare in a base class and expect to redefine in derived classes. When you have a pointer or reference to the base class that actually points to an object of a derived class, calling a virtual function on that pointer/reference will execute the derived class's version of the function. This decision of which function to call is made at runtime, a process called dynamic dispatch or late binding. For example, you could have a base class `Shape` with a virtual function `draw()`. Derived classes like `Circle` and `Square` would each provide their own implementation (override) of the `draw()` function. Then, you can have an array of `Shape*` pointers, where each pointer can point to either a `Circle` object or a `Square` object. When you loop through the array and call `draw()` on each pointer, the correct `draw()` function (either `Circle`'s or `Square`'s) will be invoked automatically. This allows for writing flexible and extensible code, as you can add new shapes without changing the code that manages and draws them.",
            "code": "// Example 1: Demonstrating polymorphism with virtual functions\n#include <iostream>\n\nclass Animal {\npublic:\n    // virtual function\n    virtual void speak() {\n        std::cout << \"Animal makes a sound.\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    // override the virtual function\n    void speak() override {\n        std::cout << \"Dog barks: Woof!\" << std::endl;\n    }\n};\n\nclass Cat : public Animal {\npublic:\n    // override the virtual function\n    void speak() override {\n        std::cout << \"Cat meows: Meow!\" << std::endl;\n    }\n};\n\nint main() {\n    Animal* pAnimal1 = new Dog();\n    Animal* pAnimal2 = new Cat();\n\n    pAnimal1->speak(); // Calls Dog's speak()\n    pAnimal2->speak(); // Calls Cat's speak()\n\n    delete pAnimal1;\n    delete pAnimal2;\n    return 0;\n}\n\n// Example 2: Polymorphism with a function\n#include <iostream>\n#include <string>\n\nclass Character {\npublic:\n    virtual std::string getAttack() { return \"Character attacks!\"; }\n};\n\nclass Warrior : public Character {\npublic:\n    std::string getAttack() override { return \"Warrior swings a sword!\"; }\n};\n\nvoid performAttack(Character& c) {\n    std::cout << c.getAttack() << std::endl;\n}\n\nint main() {\n    Warrior w;\n    Character c;\n    performAttack(w); // Calls Warrior's getAttack\n    performAttack(c); // Calls Character's getAttack\n    return 0;\n}"
          },
          {
            "id": "t3-abstract-classes",
            "title": "Abstract Classes and Interfaces",
            "desc": "Define abstract base classes with pure virtual functions to create interfaces.",
            "note": "An abstract class is a class that is designed to be specifically used as a base class. It cannot be instantiated, meaning you cannot create objects of an abstract class. A class becomes abstract if it has at least one **pure virtual function**. A pure virtual function is a virtual function that is declared in the base class but has no definition. It is declared by assigning `= 0` to its declaration. The syntax is `virtual void myFunction() = 0;`. The purpose of a pure virtual function is to force all concrete (non-abstract) derived classes to provide their own implementation for that function. This effectively creates a contract: any class that inherits from the abstract base class *must* implement all of its pure virtual functions. This is how C++ programmers create interfaces. An interface is a class that consists only of pure virtual functions and has no member variables. It defines a set of behaviors that other classes can promise to implement. For example, you could have an `IShape` interface with pure virtual functions like `getArea()` and `getPerimeter()`. Any class like `Rectangle` or `Circle` that inherits from `IShape` would be required to provide its own logic for calculating area and perimeter. This enforces a consistent interface across different types of shapes, which is extremely useful for building flexible and maintainable systems.",
            "code": "// Example 1: An abstract base class 'Shape'\n#include <iostream>\n\n// Abstract base class\nclass Shape {\npublic:\n    // Pure virtual function, makes Shape an abstract class\n    virtual double getArea() = 0;\n\n    void printMessage() {\n        std::cout << \"I am a shape.\" << std::endl;\n    }\n};\n\nclass Rectangle : public Shape {\nprivate:\n    double width, height;\npublic:\n    Rectangle(double w, double h) : width(w), height(h) {}\n    // Provide implementation for the pure virtual function\n    double getArea() override {\n        return width * height;\n    }\n};\n\nint main() {\n    // Shape s; // Error: Cannot instantiate abstract class\n    Rectangle r(5, 4);\n    std::cout << \"Area of rectangle: \" << r.getArea() << std::endl;\n    r.printMessage();\n    return 0;\n}\n\n// Example 2: Using an abstract class as an interface\n#include <iostream>\n\nclass ILogger {\npublic:\n    virtual void logMessage(const char* message) = 0;\n    virtual ~ILogger() {} // Virtual destructor is important for interfaces\n};\n\nclass ConsoleLogger : public ILogger {\npublic:\n    void logMessage(const char* message) override {\n        std::cout << \"CONSOLE: \" << message << std::endl;\n    }\n};\n\nvoid processData(ILogger& logger) {\n    logger.logMessage(\"Processing started.\");\n    // ... processing logic ...\n    logger.logMessage(\"Processing finished.\");\n}\n\nint main() {\n    ConsoleLogger myLogger;\n    processData(myLogger);\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c9-encapsulation-overloading",
        "title": "Encapsulation & Operator Overloading",
        "desc": "Protect data with encapsulation and customize operators for your classes.",
        "notes": "This chapter reinforces the OOP principle of encapsulation and introduces a powerful C++ feature: operator overloading. Encapsulation, also known as data hiding, is the practice of bundling an object's data (member variables) and the methods that operate on that data into a single unit (the class), while restricting direct access to some of the object's components. In C++, this is achieved by declaring the member variables as `private` or `protected`. Private members can only be accessed by the member functions of the same class. This prevents outside code from putting the object into an invalid or inconsistent state. To allow controlled access to this hidden data, we provide `public` member functions, often called getters (accessors) and setters (mutators). Getters are functions that return the value of a private member, and setters are functions that modify its value, often with built-in validation logic. This protects the integrity of the object's data. Next, we'll explore operator overloading. C++ allows you to redefine the way most of its built-in operators work for user-defined types (i.e., your classes). For example, you can overload the `+` operator to define how to 'add' two `Vector` objects or the `<<` operator to define how a `Book` object should be printed to an output stream like `std::cout`. This can make your code much more intuitive and readable, as it allows you to use familiar operators with your custom types, making them behave more like built-in types.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-encapsulation",
            "title": "Encapsulation (Getters and Setters)",
            "desc": "Hide data using private access specifiers and provide public getters/setters.",
            "note": "Encapsulation is a core concept in OOP that involves bundling data and the methods that work on that data within one unit, and controlling access to that data from the outside world. The primary mechanism for this in C++ is the use of access specifiers: `public`, `protected`, and `private`. By declaring a class's member variables as `private`, you make them inaccessible to any code outside the class. This is called data hiding. The main benefit of data hiding is that it protects the object's internal state. It prevents external code from accidentally or intentionally corrupting the object's data, ensuring the object remains in a valid state. So, how do we interact with this private data? We provide a controlled public interface through special member functions. **Getters** (or accessor methods) are public functions that return the value of a private member variable. They provide read-only access. **Setters** (or mutator methods) are public functions that are used to modify the value of a private member variable. Setters are powerful because they can include validation logic. For example, a `setAge` method for a `Person` class could ensure that the age being set is a non-negative number. This combination of private data and public getter/setter methods gives you fine-grained control over your object's data, making your code more robust, secure, and easier to maintain.",
            "code": "// Example 1: A class demonstrating encapsulation\n#include <iostream>\n#include <string>\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n\npublic:\n    // Setter for name\n    void setName(std::string n) {\n        name = n;\n    }\n    // Getter for name\n    std::string getName() {\n        return name;\n    }\n    // Setter for age with validation\n    void setAge(int a) {\n        if (a > 0) {\n            age = a;\n        } else {\n            std::cout << \"Invalid age!\" << std::endl;\n        }\n    }\n    // Getter for age\n    int getAge() {\n        return age;\n    }\n};\n\nint main() {\n    Student s1;\n    s1.setName(\"Alice\");\n    s1.setAge(20);\n    std::cout << \"Name: \" << s1.getName() << \", Age: \" << s1.getAge() << std::endl;\n    s1.setAge(-5); // This will print an error message\n    return 0;\n}\n\n// Example 2: Encapsulation for a Bank Account\n#include <iostream>\n\nclass BankAccount {\nprivate:\n    double balance;\n\npublic:\n    BankAccount() : balance(0) {}\n\n    double getBalance() {\n        return balance;\n    }\n\n    void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n        }\n    }\n\n    void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n        }\n    }\n};\n\nint main() {\n    BankAccount acc;\n    acc.deposit(100.0);\n    acc.withdraw(30.0);\n    std::cout << \"Final balance: \" << acc.getBalance() << std::endl;\n    // acc.balance = 10000; // Error: balance is private\n    return 0;\n}"
          },
          {
            "id": "t2-operator-overloading",
            "title": "Operator Overloading",
            "desc": "Define custom behavior for operators with your user-defined types.",
            "note": "Operator overloading allows you to specify custom implementations for C++ operators when they are used with objects of your own classes. This can make your code more intuitive and readable because you can use familiar syntax with your custom types. For example, instead of writing `Vector v3 = v1.add(v2);`, you could overload the `+` operator and simply write `Vector v3 = v1 + v2;`. You can overload most C++ operators, including arithmetic (`+`, `-`, `*`), relational (`==`, `!=`, `<`), and even I/O stream operators (`<<`, `>>`). An operator is overloaded by writing a special function, either as a member function of the class or as a non-member (global) function. The name of the function is the keyword `operator` followed by the symbol for the operator you're overloading (e.g., `operator+`, `operator==`). When the operator is a member function, the left-hand operand is the object calling the function (`this`), and the right-hand operand is passed as an argument. When it's a non-member function, both operands are passed as arguments. Operator overloading should be used judiciously. The custom behavior should be logical and consistent with the operator's conventional meaning. Overloading operators in a non-intuitive way can make code confusing and difficult to understand.",
            "code": "// Example 1: Overloading the '+' operator for a Complex number class\n#include <iostream>\n\nclass Complex {\nprivate:\n    double real, imag;\npublic:\n    Complex(double r = 0, double i = 0) : real(r), imag(i) {}\n\n    // Overload the + operator\n    Complex operator+(const Complex& other) {\n        return Complex(real + other.real, imag + other.imag);\n    }\n\n    void display() {\n        std::cout << real << \" + \" << imag << \"i\" << std::endl;\n    }\n};\n\nint main() {\n    Complex c1(3, 4);\n    Complex c2(1, 2);\n    Complex c3 = c1 + c2; // Calls the overloaded operator+\n    c3.display();\n    return 0;\n}\n\n// Example 2: Overloading the '<<' operator for easy printing\n#include <iostream>\n#include <string>\n\nclass Point {\nprivate:\n    int x, y;\npublic:\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n\n    // Friend function to overload <<\n    friend std::ostream& operator<<(std::ostream& os, const Point& p);\n};\n\n// Definition of the overloaded operator\nstd::ostream& operator<<(std::ostream& os, const Point& p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\n\nint main() {\n    Point p1(5, 10);\n    std::cout << \"My point is: \" << p1 << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c10-templates",
        "title": "Templates & Generics",
        "desc": "Write generic code that works with any data type using function and class templates.",
        "notes": "Templates are a cornerstone of generic programming in C++, allowing you to write code that is independent of any particular data type. This means you can write a function or a class once and have it work with integers, doubles, strings, or any custom type that supports the operations used in the template. This promotes massive code reuse and is the foundation upon which the Standard Template Library (STL) is built. This chapter covers the two main types of templates. First, we'll explore **function templates**. A function template is a blueprint for creating a family of functions. For example, you can write a single `max()` function template that can find the maximum of two integers, two doubles, or two strings, without having to write a separate overloaded function for each type. The compiler automatically generates the appropriate function based on the types of arguments you pass to it. Second, we'll cover **class templates**. A class template is a blueprint for creating a family of classes. This is incredibly powerful for creating generic data structures. For example, you can create a `Stack` class template that can be instantiated to create a stack of integers (`Stack<int>`), a stack of strings (`Stack<string>`), or a stack of any other type. We'll also touch upon template specialization, which allows you to provide a specific implementation of a template for a particular data type when the generic version is not suitable.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-function-templates",
            "title": "Function Templates",
            "desc": "Create functions that can operate on various data types.",
            "note": "A function template is a powerful feature that allows you to define a generic function that can work with different data types without rewriting the entire function for each type. You define a function template by preceding the function definition with the `template <typename T>` or `template <class T>` keyword (both are equivalent in this context). Here, `T` is a placeholder for a data type, which is determined by the compiler at compile time based on the arguments passed to the function. For example, you can write a generic `swap` function that can swap the values of two variables of any type. When you call `swap(a, b)` where `a` and `b` are integers, the compiler instantiates a version of the swap function specifically for `int`. If you call it with two `double` variables, it generates a version for `double`. This process is called template instantiation. Function templates reduce code duplication significantly. Instead of writing multiple overloaded functions that do the exact same thing but with different types, you write a single, generic template. This makes your code cleaner, easier to maintain, and less error-prone. The logic is defined in one place, and the compiler handles the type-specific implementations for you.",
            "code": "// Example 1: A generic function template to find the maximum of two values\n#include <iostream>\n\n// Function template\ntemplate <typename T>\nT getMax(T a, T b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int i1 = 10, i2 = 20;\n    std::cout << \"Max of integers: \" << getMax(i1, i2) << std::endl;\n\n    double d1 = 5.5, d2 = 3.3;\n    std::cout << \"Max of doubles: \" << getMax(d1, d2) << std::endl;\n\n    char c1 = 'A', c2 = 'Z';\n    std::cout << \"Max of chars: \" << getMax(c1, c2) << std::endl;\n    return 0;\n}\n\n// Example 2: A function template to swap two values\n#include <iostream>\n\ntemplate <typename T>\nvoid swapValues(T& a, T& b) {\n    T temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    std::cout << \"Before swap: x = \" << x << \", y = \" << y << std::endl;\n    swapValues(x, y);\n    std::cout << \"After swap: x = \" << x << \", y = \" << y << std::endl;\n\n    std::string s1 = \"Hello\", s2 = \"World\";\n    std::cout << \"Before swap: s1 = \" << s1 << \", s2 = \" << s2 << std::endl;\n    swapValues(s1, s2);\n    std::cout << \"After swap: s1 = \" << s1 << \", s2 = \" << s2 << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t2-class-templates",
            "title": "Class Templates",
            "desc": "Create generic classes for data structures that work with any type.",
            "note": "A class template allows you to define a blueprint for a generic class. It's particularly useful for creating data structures that can store elements of any type, like lists, stacks, queues, and arrays. Just like function templates, you declare a class template using the `template <typename T>` syntax before the class definition. Inside the class, `T` is used as a placeholder for the data type that the class will manage. When you want to create an object of a template class, you must specify the actual data type you want to use in angle brackets. This is called instantiating the template. For example, if you have a class template named `MyArray<T>`, you can create an array of integers with `MyArray<int> intArray;` or an array of strings with `MyArray<std::string> stringArray;`. The compiler then generates a separate class definition for each specific type (`MyArray<int>` and `MyArray<std::string>`). The implementation of the class template's member functions is also generic. When defining a member function outside the class definition, you must include the template prefix and specify the template parameter, like `template <typename T> void MyArray<T>::someFunction() { ... }`. Class templates are the foundation of the C++ Standard Template Library (STL), which provides a rich set of pre-built, generic, and highly efficient data structures and algorithms.",
            "code": "// Example 1: A simple generic Pair class\n#include <iostream>\n\ntemplate <typename T1, typename T2>\nclass Pair {\npublic:\n    T1 first;\n    T2 second;\n\n    Pair(T1 f, T2 s) : first(f), second(s) {}\n\n    void display() {\n        std::cout << \"(\" << first << \", \" << second << \")\" << std::endl;\n    }\n};\n\nint main() {\n    Pair<int, double> p1(1, 2.5);\n    Pair<std::string, char> p2(\"Hello\", 'C');\n\n    p1.display();\n    p2.display();\n    return 0;\n}\n\n// Example 2: A simple generic Stack class\n#include <iostream>\n#include <vector>\n\ntemplate <typename T>\nclass Stack {\nprivate:\n    std::vector<T> elements;\npublic:\n    void push(const T& element) {\n        elements.push_back(element);\n    }\n    void pop() {\n        if (!elements.empty()) elements.pop_back();\n    }\n    T top() const {\n        return elements.back();\n    }\n    bool isEmpty() const {\n        return elements.empty();\n    }\n};\n\nint main() {\n    Stack<int> intStack;\n    intStack.push(10);\n    intStack.push(20);\n    std::cout << \"Top of int stack: \" << intStack.top() << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c11-exception-handling",
        "title": "Exception Handling & Debugging",
        "desc": "Handle runtime errors gracefully using exceptions and learn basic debugging.",
        "notes": "Even the best-written programs can encounter errors at runtime. These could be due to invalid user input, a missing file, a network failure, or running out of memory. Exception handling is the C++ mechanism for dealing with these runtime anomalies in a structured and controlled manner. It allows you to separate your error-handling code from your normal program logic, making the code cleaner and more robust. The core of exception handling revolves around three keywords: `try`, `catch`, and `throw`. You place the code that might generate an error inside a `try` block. If an error occurs within the `try` block, you can signal it by 'throwing' an exception using the `throw` keyword. An exception can be any value, but it's typically an object of a class designed for error reporting. The program then immediately exits the `try` block and looks for a corresponding `catch` block that can handle the type of exception that was thrown. A `catch` block is an error handler that specifies the type of exception it can catch. You can have multiple `catch` blocks to handle different types of errors. We'll also discuss stack unwinding, the process by which C++ cleans up objects on the stack when an exception is thrown. Finally, we'll briefly cover the importance of debugging tools (like GDB or the debuggers integrated into IDEs) which allow you to step through your code, inspect variables, and pinpoint the source of bugs.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-try-catch-throw",
            "title": "Try, Catch, and Throw",
            "desc": "Use try-catch blocks to handle exceptions thrown during program execution.",
            "note": "The `try-catch` mechanism is the standard way to handle exceptions in C++. The process starts with the `try` block. You should enclose any code that you suspect might cause a runtime error within a `try { ... }` block. This tells the compiler that you are prepared to handle potential exceptions that occur within this scope. If a function called within the `try` block, or the code directly within it, encounters an error condition, it can signal this by using the `throw` keyword. For example, a function that performs division might `throw` an error message if the denominator is zero. When `throw` is executed, the normal flow of the program is interrupted. The runtime system begins searching for a `catch` block that can handle the thrown exception. The search starts with the `catch` blocks immediately following the `try` block. The runtime checks the type of the thrown exception against the type specified in each `catch` statement (`catch (ExceptionType e) { ... }`). The first `catch` block with a matching type is executed. If no matching `catch` block is found in the current function, the function terminates, and the runtime continues searching for a handler in the calling function (a process called stack unwinding). This mechanism allows you to gracefully recover from errors instead of letting them crash your program.",
            "code": "// Example 1: A simple division function that throws an exception\n#include <iostream>\n#include <stdexcept> // For std::runtime_error\n\ndouble divide(double numerator, double denominator) {\n    if (denominator == 0) {\n        throw std::runtime_error(\"Error: Division by zero!\");\n    }\n    return numerator / denominator;\n}\n\nint main() {\n    try {\n        double result = divide(10.0, 0.0);\n        std::cout << \"Result: \" << result << std::endl;\n    } catch (const std::runtime_error& e) {\n        std::cout << \"Exception caught: \" << e.what() << std::endl;\n    }\n    std::cout << \"Program continues after exception.\" << std::endl;\n    return 0;\n}\n\n// Example 2: Catching different types of exceptions\n#include <iostream>\n\nint main() {\n    try {\n        int choice = 2;\n        if (choice == 1) {\n            throw 10; // throw an int\n        } else if (choice == 2) {\n            throw 'x'; // throw a char\n        }\n    } catch (int e) {\n        std::cout << \"Caught an integer exception: \" << e << std::endl;\n    } catch (char e) {\n        std::cout << \"Caught a character exception: \" << e << std::endl;\n    } catch (...) { // Catches any other type of exception\n        std::cout << \"Caught an unknown exception!\" << std::endl;\n    }\n    return 0;\n}"
          },
          {
            "id": "t2-custom-exceptions",
            "title": "Custom Exceptions",
            "desc": "Create your own exception classes for more specific error handling.",
            "note": "While you can throw exceptions of fundamental types like `int` or `const char*`, it is a much better practice to use custom exception classes. The C++ Standard Library provides a hierarchy of exception classes (like `std::exception`, `std::runtime_error`, `std::logic_error`) that you can use, but often it's beneficial to create your own. A custom exception class is simply a class that you design to represent a specific type of error in your application. Typically, these classes inherit from `std::exception`. The `std::exception` base class provides a virtual member function called `what()` that returns a C-style string describing the exception. By inheriting from it and overriding `what()`, your custom exceptions can integrate smoothly with the standard exception handling mechanisms. For example, if you are writing a banking application, you might create an `InsufficientFundsError` class. When a withdrawal fails, you can `throw InsufficientFundsError(\"Not enough balance\");`. The calling code can then have a specific `catch (const InsufficientFundsError& e)` block to handle that particular scenario, perhaps by showing a user-friendly message. Using custom exception classes makes your error handling much more precise and your code more readable and maintainable. You can add member variables to your custom exception classes to carry more detailed information about the error that occurred.",
            "code": "// Example 1: A custom exception class\n#include <iostream>\n#include <exception>\n#include <string>\n\nclass MyCustomException : public std::exception {\nprivate:\n    std::string message;\npublic:\n    MyCustomException(const std::string& msg) : message(msg) {}\n\n    const char* what() const noexcept override {\n        return message.c_str();\n    }\n};\n\nint main() {\n    try {\n        throw MyCustomException(\"Something went wrong in my module.\");\n    } catch (const MyCustomException& e) {\n        std::cout << \"Caught custom exception: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n\n// Example 2: Another custom exception for a specific domain\n#include <iostream>\n#include <exception>\n\nclass NetworkError : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Failed to connect to the network.\";\n    }\n};\n\nvoid connectToNetwork() {\n    bool isConnected = false; // Simulate failure\n    if (!isConnected) {\n        throw NetworkError();\n    }\n}\n\nint main() {\n    try {\n        connectToNetwork();\n    } catch (const NetworkError& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c12-memory-management",
        "title": "Memory Management",
        "desc": "Learn about dynamic memory allocation, smart pointers, and preventing memory leaks.",
        "notes": "Memory management is a critical aspect of C++ programming. Unlike many modern languages that use automatic garbage collection, C++ gives the programmer direct control over memory allocation and deallocation. This control is a double-edged sword: it allows for highly optimized, high-performance applications, but it also places the responsibility of managing memory squarely on the developer. This chapter covers the essential concepts and tools for effective memory management. We'll start with manual memory management using the `new` and `delete` operators. The `new` operator is used to allocate memory on the heap (also known as the free store) at runtime, which is necessary when the size or lifetime of an object isn't known at compile time. The `delete` operator is used to release that memory back to the system. Failing to `delete` memory that was allocated with `new` leads to memory leaks, where the program consumes more and more memory over time, eventually causing it to slow down or crash. To combat the dangers of manual memory management, modern C++ introduced smart pointers. Smart pointers are class templates that act like raw pointers but provide automatic memory management. We will cover the main types: `std::unique_ptr` (for exclusive ownership), `std::shared_ptr` (for shared ownership with reference counting), and `std::weak_ptr` (to break circular references). Finally, we'll discuss the RAII (Resource Acquisition Is Initialization) idiom, a fundamental C++ technique that uses object lifetime to manage resources automatically, which is the principle behind smart pointers.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-new-delete",
            "title": "Dynamic Allocation (new/delete)",
            "desc": "Allocate and deallocate memory on the heap using 'new' and 'delete'.",
            "note": "In C++, memory for variables can be allocated in two main places: the stack and the heap. Stack allocation is the default for local variables within functions. It's fast and automatic—memory is allocated when the function is entered and deallocated when it exits. However, the stack has a limited size, and the lifetime of variables is tied to their scope. The heap (or free store) is a large pool of memory available to the programmer for dynamic allocation at runtime. This is useful when you don't know the amount of memory you need at compile time, or when you need an object to persist beyond the scope in which it was created. To allocate memory on the heap, you use the `new` operator, which returns a pointer to the allocated memory. For example, `int* ptr = new int;` allocates enough memory for one integer and stores its address in `ptr`. You can also allocate arrays: `int* arr = new int[10];`. The most critical part of using `new` is that you are responsible for deallocating the memory once you are finished with it. This is done using the `delete` operator. For a single object, you use `delete ptr;`. For an array, you must use the array form: `delete[] arr;`. If you forget to `delete` the memory, it becomes a memory leak. The program loses the pointer to that memory but the memory remains allocated, effectively lost until the program terminates.",
            "code": "// Example 1: Allocating and deleting a single object\n#include <iostream>\n\nint main() {\n    // Allocate an integer on the heap\n    int* pNumber = new int;\n    *pNumber = 25;\n\n    std::cout << \"Value of pNumber: \" << *pNumber << std::endl;\n\n    // Deallocate the memory to prevent a leak\n    delete pNumber;\n    pNumber = nullptr; // Good practice to nullify dangling pointers\n\n    return 0;\n}\n\n// Example 2: Allocating and deleting an array dynamically\n#include <iostream>\n\nint main() {\n    int size = 5;\n    // Allocate an array of 5 integers on the heap\n    int* pArray = new int[size];\n\n    for (int i = 0; i < size; ++i) {\n        pArray[i] = (i + 1) * 10;\n    }\n\n    for (int i = 0; i < size; ++i) {\n        std::cout << pArray[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    // Deallocate the array memory\n    delete[] pArray;\n    pArray = nullptr;\n\n    return 0;\n}"
          },
          {
            "id": "t2-smart-pointers",
            "title": "Smart Pointers",
            "desc": "Use std::unique_ptr, std::shared_ptr, and std::weak_ptr for automatic memory management.",
            "note": "Smart pointers are a modern C++ feature (introduced in C++11) designed to automate the process of memory management and prevent common errors like memory leaks and dangling pointers. They are wrapper classes that store a raw pointer and ensure that the memory it points to is properly deallocated when the smart pointer object goes out of scope. This is an application of the RAII (Resource Acquisition Is Initialization) idiom. There are three main types of smart pointers in the `<memory>` header. **`std::unique_ptr`** represents exclusive ownership. Only one `unique_ptr` can point to a given object at any time. It's very lightweight and has virtually no performance overhead compared to a raw pointer. You cannot copy a `unique_ptr`, but you can move it, transferring ownership to another `unique_ptr`. **`std::shared_ptr`** allows for shared ownership. Multiple `shared_ptr` instances can point to the same object. It keeps a reference count of how many `shared_ptr`s are pointing to the object. When the last `shared_ptr` owning the object is destroyed, the managed memory is automatically deleted. **`std::weak_ptr`** is a companion to `shared_ptr`. It holds a non-owning ('weak') reference to an object managed by a `shared_ptr`. It's used to break circular references between `shared_ptr` instances, which would otherwise prevent the reference count from ever reaching zero, causing a memory leak. In modern C++, you should almost always prefer using smart pointers over raw pointers for owning memory.",
            "code": "// Example 1: Using std::unique_ptr for exclusive ownership\n#include <iostream>\n#include <memory>\n\nclass MyClass {\npublic:\n    MyClass() { std::cout << \"MyClass created.\" << std::endl; }\n    ~MyClass() { std::cout << \"MyClass destroyed.\" << std::endl; }\n};\n\nint main() {\n    // Create a unique_ptr. Memory is automatically deallocated when ptr goes out of scope.\n    std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();\n    \n    // std::unique_ptr<MyClass> ptr2 = ptr; // Error: cannot copy unique_ptr\n    return 0; // ptr is destroyed here, calling ~MyClass()\n}\n\n// Example 2: Using std::shared_ptr for shared ownership\n#include <iostream>\n#include <memory>\n\nclass Resource {\npublic:\n    Resource() { std::cout << \"Resource acquired.\" << std::endl; }\n    ~Resource() { std::cout << \"Resource released.\" << std::endl; }\n};\n\nint main() {\n    std::shared_ptr<Resource> p1;\n    {\n        std::shared_ptr<Resource> p2 = std::make_shared<Resource>();\n        std::cout << \"Use count: \" << p2.use_count() << std::endl; // Count is 1\n        p1 = p2; // Both pointers now share ownership\n        std::cout << \"Use count: \" << p2.use_count() << std::endl; // Count is 2\n    } // p2 goes out of scope, count becomes 1\n    std::cout << \"Use count: \" << p1.use_count() << std::endl; // Count is 1\n    return 0; // p1 goes out of scope, count becomes 0, resource released\n}"
          }
        ]
      },
      {
        "id": "c13-file-handling",
        "title": "File Handling",
        "desc": "Read from and write to files using fstream, ifstream, and ofstream.",
        "notes": "File handling, or file I/O, is the process of reading data from and writing data to files on a storage device. It's a fundamental requirement for most applications, as it allows for data persistence—the ability to save data so it can be used later, even after the program has terminated. C++ provides a powerful and object-oriented way to handle file I/O through its fstream library. The library defines three main classes for file operations. **`ofstream`** (output file stream) is used for writing data to files. You create an object of this class, associate it with a file, and then use the stream insertion operator (`<<`) just like you do with `std::cout` to write data to the file. **`ifstream`** (input file stream) is used for reading data from files. Similarly, you associate an object of this class with a file and then use the stream extraction operator (`>>`) as you would with `std::cin` to read formatted data. **`fstream`** is a more general class that can handle both reading from and writing to files. In this chapter, you'll learn how to open and close files, check for errors during file operations, and read/write different kinds of data, including text and binary data. We'll cover topics like reading a file line by line, random access to files (moving the read/write position to a specific location), and ensuring that files are properly closed to save all changes.",
        "code": "",
        "duration": "1 week",
        "topics": [
          {
            "id": "t1-writing-to-files",
            "title": "Writing to a File (ofstream)",
            "desc": "Learn how to create files and write data to them using ofstream.",
            "note": "To write data to a file in C++, you use the `ofstream` class from the `<fstream>` library. The process involves three main steps. First, you create an `ofstream` object and open a file. You can do this in one step: `std::ofstream myFile(\"example.txt\");`. This creates an `ofstream` object named `myFile` and attempts to open (or create, if it doesn't exist) a file named `example.txt` for writing. By default, opening a file in this way overwrites its existing content. To append to the end of the file instead, you can specify a second argument: `std::ofstream myFile(\"example.txt\", std::ios::app);`. Second, after opening the file, it's good practice to check if the file was opened successfully. You can do this by treating the file stream object as a boolean: `if (myFile.is_open()) { ... }`. Third, you write data to the file using the stream insertion operator (`<<`), just as you would with `std::cout`. For example, `myFile << \"Hello, File!\\n\"; myFile << 42;`. Finally, and most importantly, you must close the file when you are done writing. This is done by calling the `.close()` method: `myFile.close();`. Closing the file ensures that all the data you've written is flushed from the buffer and saved to the disk. A more modern and safer approach is to use the RAII idiom; when the `ofstream` object goes out of scope, its destructor is automatically called, which closes the file for you. This avoids leaving files open accidentally.",
            "code": "// Example 1: Writing text to a file\n#include <iostream>\n#include <fstream>\n\nint main() {\n    // Create and open a text file\n    std::ofstream outFile(\"greetings.txt\");\n\n    if (outFile.is_open()) {\n        // Write to the file\n        outFile << \"Hello from C++!\" << std::endl;\n        outFile << \"This is the second line.\" << std::endl;\n\n        // Close the file\n        outFile.close();\n        std::cout << \"Successfully wrote to the file.\" << std::endl;\n    } else {\n        std::cout << \"Unable to open file for writing.\" << std::endl;\n    }\n    return 0;\n}\n\n// Example 2: Appending content to an existing file\n#include <iostream>\n#include <fstream>\n\nint main() {\n    // Open the file in append mode\n    std::ofstream outFile(\"greetings.txt\", std::ios::app);\n\n    if (outFile.is_open()) {\n        outFile << \"This is an appended line.\" << std::endl;\n        outFile.close();\n        std::cout << \"Successfully appended to the file.\" << std::endl;\n    } else {\n        std::cout << \"Unable to open file for appending.\" << std::endl;\n    }\n    return 0;\n}"
          },
          {
            "id": "t2-reading-from-files",
            "title": "Reading from a File (ifstream)",
            "desc": "Learn how to open files and read data from them using ifstream.",
            "note": "Reading data from a file is accomplished using the `ifstream` class. The process is symmetric to writing. First, you create an `ifstream` object and open the desired file for reading: `std::ifstream inFile(\"example.txt\");`. You should then verify that the file was opened successfully using `inFile.is_open()`. If the file doesn't exist or can't be opened, the operation will fail. There are several ways to read data. You can use the stream extraction operator (`>>`) to read formatted, whitespace-separated data, similar to `std::cin`. For example, if your file contains `100 Hello`, `inFile >> myInt >> myString;` would read `100` into `myInt` and `Hello` into `myString`. A more common task is to read a file line by line. This is done using the `std::getline()` function. You typically use a `while` loop to read all the lines from a file: `while (std::getline(inFile, line)) { ... }`. This loop will continue as long as `getline` is able to successfully read a line from the file into the `line` string variable. Once you're finished reading, you should close the file using `inFile.close()`. Just like `ofstream`, the `ifstream` object's destructor will also close the file automatically when it goes out of scope, providing a safer way to manage the file resource.",
            "code": "// Example 1: Reading a file line by line\n#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    std::string line;\n    std::ifstream inFile(\"greetings.txt\");\n\n    if (inFile.is_open()) {\n        std::cout << \"File content:\" << std::endl;\n        while (std::getline(inFile, line)) {\n            std::cout << line << std::endl;\n        }\n        inFile.close();\n    } else {\n        std::cout << \"Unable to open file for reading.\" << std::endl;\n    }\n    return 0;\n}\n\n// Example 2: Reading formatted data from a file\n#include <iostream>\n#include <fstream>\n#include <string>\n\nint main() {\n    // First, let's create a file with some data\n    std::ofstream outFile(\"data.txt\");\n    outFile << \"Alice 25\\nBob 30\";\n    outFile.close();\n\n    // Now, let's read it back\n    std::ifstream inFile(\"data.txt\");\n    std::string name;\n    int age;\n\n    if (inFile.is_open()) {\n        while (inFile >> name >> age) {\n            std::cout << \"Read Name: \" << name << \", Age: \" << age << std::endl;\n        }\n        inFile.close();\n    } else {\n        std::cout << \"Unable to open data file.\" << std::endl;\n    }\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c14-stl-basics",
        "title": "Standard Template Library (STL)",
        "desc": "Get introduced to the core components of the STL: containers, iterators, and algorithms.",
        "notes": "The Standard Template Library (STL) is one of the most powerful and celebrated features of C++. It is a library of generic classes and functions that provides a collection of common data structures and algorithms. Using the STL can dramatically increase your productivity and the quality of your code, as it provides pre-built, highly efficient, and thoroughly tested components. The STL is built on three core concepts. First, **Containers** are objects that store data. They are template classes used to manage collections of objects of a certain kind. The STL provides several types of containers, which can be broadly categorized. Sequence containers, like `std::vector`, `std::deque`, and `std::list`, store elements in a linear sequence. Associative containers, like `std::set` and `std::map`, store elements in a sorted order for fast lookup. Unordered associative containers, like `std::unordered_set` and `std::unordered_map`, store elements using hash tables for even faster average-case lookup. Second, **Algorithms** are functions that perform operations on the data in containers, such as sorting, searching, and transforming. They are provided in the `<algorithm>` header. Third, **Iterators** are objects that act like pointers, providing a way to access the elements of a container sequentially. They are the glue that connects algorithms with containers; algorithms don't operate on containers directly but on a range of elements specified by two iterators. This chapter will introduce you to these core components, focusing on the most common containers and how to use them with iterators.",
        "code": "",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-stl-containers",
            "title": "STL Containers (vector, list, map, set)",
            "desc": "Learn about the most common STL container classes.",
            "note": "Containers are the heart of the STL. **`std::vector`** is a dynamic array. It stores elements in contiguous memory, allowing for fast random access (accessing any element by its index). It can grow or shrink in size automatically. You typically add elements to the end using `.push_back()`. It's the most commonly used container and should be your default choice unless you have a specific reason to use something else. **`std::list`** is a doubly-linked list. Its elements are not stored contiguously in memory. This means it does not support fast random access, but it excels at fast insertion and deletion of elements anywhere in the list. **`std::map`** is an associative container that stores elements as key-value pairs, sorted by the key. This allows for efficient lookup, insertion, and deletion of elements based on their key. For example, you could map student names (keys) to their grades (values). It's typically implemented as a balanced binary search tree. **`std::set`** is another associative container that stores a collection of unique elements, also in sorted order. It's useful when you need to store a group of items and quickly check for the presence or absence of a specific item. All these containers are class templates, so you must specify the type of data they will hold, e.g., `std::vector<int>`, `std::map<std::string, double>`.",
            "code": "// Example 1: Using std::vector\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> numbers;\n    numbers.push_back(10);\n    numbers.push_back(20);\n    numbers.push_back(30);\n\n    std::cout << \"Vector elements: \";\n    for (int num : numbers) { // Range-based for loop\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    std::cout << \"Second element: \" << numbers[1] << std::endl;\n    return 0;\n}\n\n// Example 2: Using std::map\n#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n    std::map<std::string, int> student_ages;\n\n    student_ages[\"Alice\"] = 21;\n    student_ages[\"Bob\"] = 22;\n    student_ages.insert({\"Charlie\", 20});\n\n    std::cout << \"Bob's age is: \" << student_ages[\"Bob\"] << std::endl;\n\n    // Iterate over the map\n    for (const auto& pair : student_ages) {\n        std::cout << pair.first << \" is \" << pair.second << \" years old.\" << std::endl;\n    }\n    return 0;\n}"
          },
          {
            "id": "t2-stl-iterators",
            "title": "Iterators",
            "desc": "Use iterators to traverse and access elements in STL containers.",
            "note": "Iterators are the essential link between STL containers and algorithms. An iterator is an object that behaves like a pointer, pointing to an element within a container. It allows you to traverse the container's elements sequentially. Every STL container provides a way to get iterators. The `.begin()` member function returns an iterator pointing to the first element of the container. The `.end()` member function returns an iterator pointing to a theoretical element that is *one past* the last element. This `end` iterator acts as a sentinel; when your traversal reaches `end`, you know you've processed all the elements. To access the element an iterator points to, you use the dereference operator (`*`), just like with a pointer. To move to the next element, you use the increment operator (`++`). A typical loop for traversing a container with an iterator looks like this: `for (std::vector<int>::iterator it = myVec.begin(); it != myVec.end(); ++it) { std::cout << *it; }`. Iterators provide a uniform interface for traversal across different container types. Whether you are using a `std::vector`, `std::list`, or `std::map`, the basic mechanism of using `begin()`, `end()`, `*`, and `++` remains the same. This abstraction allows algorithms to be written generically, so a single `std::sort` algorithm can work on any container that provides the required type of iterator.",
            "code": "// Example 1: Using an iterator with a std::vector\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5};\n\n    std::cout << \"Vector elements using an iterator: \";\n    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {\n        std::cout << *it << \" \"; // Dereference iterator to get value\n    }\n    std::cout << std::endl;\n    return 0;\n}\n\n// Example 2: Using an iterator to modify elements in a std::list\n#include <iostream>\n#include <list>\n\nint main() {\n    std::list<int> myList = {10, 20, 30};\n\n    // Use an iterator to double each element\n    for (std::list<int>::iterator it = myList.begin(); it != myList.end(); ++it) {\n        *it = *it * 2;\n    }\n\n    std::cout << \"Modified list: \";\n    for (int val : myList) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t3-stl-algorithms",
            "title": "STL Algorithms",
            "desc": "Use generic algorithms like sort, find, and copy from the <algorithm> header.",
            "note": "The `<algorithm>` header in the STL provides a large collection of functions designed to perform common operations on ranges of elements. These algorithms are generic because they operate on iterators, not on the containers themselves. This makes them incredibly versatile. To use an algorithm, you typically provide it with two iterators defining a range (`[begin, end)`) on which to operate, plus any other necessary parameters. For example, `std::sort(myVector.begin(), myVector.end());` will sort the elements in `myVector`. `std::find(myVector.begin(), myVector.end(), valueToFind);` will search for `valueToFind` within the vector and return an iterator to the first occurrence, or the `end` iterator if the value is not found. Other common algorithms include `std::copy` (to copy elements from one range to another), `std::reverse` (to reverse the order of elements), `std::count` (to count occurrences of a value), and `std::for_each` (to apply a function to every element in a range). Using these pre-written, highly optimized algorithms is almost always better than writing your own loops for these tasks. They are less error-prone, more expressive, and often more performant. Learning to effectively use the functions in `<algorithm>` is a key step in becoming a proficient C++ programmer.",
            "code": "// Example 1: Using std::sort and std::reverse\n#include <iostream>\n#include <vector>\n#include <algorithm> // Required for algorithms\n\nvoid printVector(const std::vector<int>& vec) {\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    std::vector<int> numbers = {5, 2, 8, 1, 9};\n    std::cout << \"Original: \"; printVector(numbers);\n\n    std::sort(numbers.begin(), numbers.end());\n    std::cout << \"Sorted:   \"; printVector(numbers);\n\n    std::reverse(numbers.begin(), numbers.end());\n    std::cout << \"Reversed: \"; printVector(numbers);\n    return 0;\n}\n\n// Example 2: Using std::find\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> vec = {10, 20, 30, 40, 50};\n    int value_to_find = 30;\n\n    // Find the value in the vector\n    auto it = std::find(vec.begin(), vec.end(), value_to_find);\n\n    if (it != vec.end()) {\n        std::cout << \"Found \" << value_to_find << \" at index \" << std::distance(vec.begin(), it) << std::endl;\n    } else {\n        std::cout << value_to_find << \" not found in the vector.\" << std::endl;\n    }\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c15-stl-advanced",
        "title": "Advanced STL & Algorithms",
        "desc": "Explore container adaptors, more associative containers, and advanced algorithms.",
        "notes": "After mastering the basics of the STL, this chapter takes you deeper into its more specialized and advanced components. We'll start with **container adaptors**: `std::stack`, `std::queue`, and `std::priority_queue`. These are not full-fledged containers themselves but are wrappers around other underlying containers (like `std::vector` or `std::deque`) to provide a specific, restricted interface. A `stack` provides Last-In, First-Out (LIFO) access, a `queue` provides First-In, First-Out (FIFO) access, and a `priority_queue` provides access to the largest element first. We'll also look at additional associative containers like `std::multiset` and `std::multimap`. These are similar to `set` and `map` but with a key difference: they allow duplicate keys. A `multiset` can store multiple identical values, and a `multimap` can store multiple key-value pairs with the same key. The second half of the chapter focuses on more advanced features of the `<algorithm>` library. We'll explore algorithms that use predicates (functions that return a boolean), such as `std::find_if` or `std::remove_if`. We'll also introduce **functors** (or function objects), which are objects that can be called as if they were functions by overloading the function call operator `()`. Functors are often used with STL algorithms to provide custom behavior, for example, defining a custom sorting criterion for `std::sort`. This lays the groundwork for understanding lambda expressions, which are a more convenient way to create anonymous function objects.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-container-adaptors",
            "title": "Container Adaptors (stack, queue, priority_queue)",
            "desc": "Use stack (LIFO), queue (FIFO), and priority_queue for specific data access patterns.",
            "note": "Container adaptors are STL components that provide a restricted interface to an underlying container, adapting it for a specific purpose. They don't have their own iterators and are designed for simple data access patterns. **`std::stack`** provides a Last-In, First-Out (LIFO) data structure. Think of it like a stack of plates. You can only add a new plate to the top (`push()`) and remove the top plate (`pop()`). You can also view the top plate without removing it (`top()`). By default, `std::stack` uses `std::deque` as its underlying container. **`std::queue`** implements a First-In, First-Out (FIFO) data structure, like a checkout line. You add elements to the back (`push()`) and remove them from the front (`pop()`). You can view the front and back elements with `front()` and `back()`. It also uses `std::deque` by default. **`std::priority_queue`** is a queue where elements are ordered by priority. When you `pop()` an element, you always get the one with the highest priority (by default, the largest value). Elements are added with `push()`. It is typically implemented using a heap data structure and uses `std::vector` as its underlying container. These adaptors are useful because their limited interfaces clearly communicate their intended use and prevent accidental misuse of the data structure.",
            "code": "// Example 1: Using std::stack\n#include <iostream>\n#include <stack>\n\nint main() {\n    std::stack<int> s;\n    s.push(1);\n    s.push(2);\n    s.push(3);\n\n    std::cout << \"Top of stack: \" << s.top() << std::endl; // 3\n    s.pop();\n    std::cout << \"Top after pop: \" << s.top() << std::endl; // 2\n\n    std::cout << \"Popping all elements: \";\n    while (!s.empty()) {\n        std::cout << s.top() << \" \";\n        s.pop();\n    }\n    std::cout << std::endl;\n    return 0;\n}\n\n// Example 2: Using std::priority_queue\n#include <iostream>\n#include <queue> // priority_queue is in the <queue> header\n\nint main() {\n    // By default, it's a max-heap (largest element has highest priority)\n    std::priority_queue<int> pq;\n    pq.push(30);\n    pq.push(100);\n    pq.push(20);\n    pq.push(50);\n\n    std::cout << \"Processing items from priority queue: \";\n    while (!pq.empty()) {\n        std::cout << pq.top() << \" \"; // Accesses the largest element\n        pq.pop();\n    }\n    std::cout << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t2-functors",
            "title": "Functors (Function Objects)",
            "desc": "Create objects that can be called like functions, for use with STL algorithms.",
            "note": "A functor, or function object, is an instance of a C++ class that has its function call operator, `operator()`, overloaded. Because it overloads this operator, an object of the class can be called as if it were a regular function. For example, if you have `MyFunctor functorObject;`, you can invoke it with `functorObject(arg1, arg2);`. The main advantage of functors over regular functions is that they can store state. Since a functor is an object, it can have member variables. This allows the functor to maintain information across multiple calls. For instance, a functor used with `std::for_each` could count how many elements in a range meet a certain condition, storing the count in a member variable. Before C++11 and lambda expressions, functors were the primary way to pass custom, stateful operations to STL algorithms. For example, to sort a container in a custom order, you could pass an instance of a functor to `std::sort`. The functor's `operator()` would take two arguments of the container's element type and return `true` if the first argument should come before the second in the sorted order. While lambda expressions are often more convenient for simple cases today, understanding functors is still important as they are used throughout the STL and other C++ libraries, and they offer more flexibility for complex, stateful operations.",
            "code": "// Example 1: A simple functor that adds a value\n#include <iostream>\n\nclass AddValue {\nprivate:\n    int valueToAdd;\npublic:\n    AddValue(int val) : valueToAdd(val) {}\n\n    // Overload the function call operator\n    int operator()(int x) const {\n        return x + valueToAdd;\n    }\n};\n\nint main() {\n    AddValue add5(5); // Create a functor object that adds 5\n    AddValue add10(10); // Create a functor object that adds 10\n\n    std::cout << \"10 + 5 = \" << add5(10) << std::endl;\n    std::cout << \"10 + 10 = \" << add10(10) << std::endl;\n    return 0;\n}\n\n// Example 2: Using a functor with std::sort for custom sorting\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// A functor to compare integers by their absolute value\nstruct CompareAbsolute {\n    bool operator()(int a, int b) const {\n        return std::abs(a) < std::abs(b);\n    }\n};\n\nint main() {\n    std::vector<int> nums = {-3, 1, -4, 2, 5};\n\n    // Pass an instance of the functor to std::sort\n    std::sort(nums.begin(), nums.end(), CompareAbsolute());\n\n    std::cout << \"Sorted by absolute value: \";\n    for (int n : nums) {\n        std::cout << n << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c16-namespaces-preprocessor",
        "title": "Namespaces, Preprocessor & Macros",
        "desc": "Organize code with namespaces and understand the C++ preprocessor.",
        "notes": "This chapter covers important organizational and compilation-related features of C++. First, we'll explore **namespaces**. As projects grow larger and incorporate more libraries, the likelihood of naming conflicts increases. For example, you might define a function named `log()`, and a third-party library you use might also have a function named `log()`. Namespaces are designed to solve this problem. A namespace provides a declarative region that isolates a set of names (like classes, functions, and variables) from other parts of the code. The most common namespace you've already seen is `std`, which contains all the names from the C++ Standard Library (e.g., `std::cout`, `std::vector`). You'll learn how to create your own namespaces to organize your code and prevent naming collisions. The second part of the chapter deals with the **C++ preprocessor**. The preprocessor is a tool that runs before the actual compiler. It processes your source code, acting on special instructions called preprocessor directives, which all begin with a `#` symbol. We'll cover the most important directives: `#include`, which is used to insert the contents of another file (usually a header file) into the current file; `#define`, which is used to create macros (simple text substitutions) and symbolic constants; and conditional compilation directives (`#ifdef`, `#ifndef`, `#if`, `#else`, `#endif`), which allow you to include or exclude parts of the code from compilation based on certain conditions. We'll also cover header guards, an essential technique using `#ifndef` to prevent problems from including the same header file multiple times.",
        "code": "",
        "duration": "1 week",
        "topics": [
          {
            "id": "t1-namespaces",
            "title": "Namespaces",
            "desc": "Use namespaces to organize code and prevent naming conflicts.",
            "note": "A namespace is a feature in C++ used to group related declarations (functions, classes, variables, etc.) under a single name. This helps to avoid naming conflicts, especially in large projects or when using multiple libraries. For example, two different libraries might both define a class named `List`. Without namespaces, the compiler wouldn't know which one to use. By placing each `List` class inside its own namespace (e.g., `MyLib::List` and `TheirLib::List`), the ambiguity is resolved. To define a namespace, you use the `namespace` keyword: `namespace MyNamespace { ...declarations... }`. To access a member of a namespace, you use the scope resolution operator `::`, like `MyNamespace::myFunction();`. The C++ Standard Library is entirely contained within the `std` namespace, which is why you need to write `std::cout` and `std::vector`. The `using` directive allows you to bring a specific name, or the entire namespace, into the current scope to avoid having to repeatedly type the namespace prefix. For example, `using std::cout;` lets you just write `cout`. The statement `using namespace std;` brings all names from `std` into the current scope. While convenient for small programs, this is generally discouraged in header files and larger projects as it can re-introduce the very naming conflicts that namespaces were designed to prevent.",
            "code": "// Example 1: Creating and using a custom namespace\n#include <iostream>\n\nnamespace MyMath {\n    const double PI = 3.14159;\n    int add(int a, int b) { return a + b; }\n}\n\nnamespace YourMath {\n    int add(int a, int b) { return a + b + 1; } // A different 'add' function\n}\n\nint main() {\n    std::cout << \"MyMath's PI: \" << MyMath::PI << std::endl;\n    std::cout << \"MyMath's add(2, 3): \" << MyMath::add(2, 3) << std::endl;\n    std::cout << \"YourMath's add(2, 3): \" << YourMath::add(2, 3) << std::endl;\n    return 0;\n}\n\n// Example 2: Using the 'using' keyword\n#include <iostream>\n\nnamespace Graphics {\n    void drawCircle() { std::cout << \"Drawing a circle.\" << std::endl; }\n}\n\nint main() {\n    // Bring a single name into scope\n    using Graphics::drawCircle;\n\n    drawCircle(); // No need for Graphics:: prefix\n    return 0;\n}"
          },
          {
            "id": "t2-preprocessor-macros",
            "title": "Preprocessor and Macros",
            "desc": "Understand the role of #include, #define, and conditional compilation.",
            "note": "The C++ preprocessor scans the source code for directives (lines starting with `#`) before the code is passed to the compiler. It performs text-based transformations on the code. **`#include`** is the most common directive; it tells the preprocessor to find the specified file and insert its entire contents at that point. This is how you gain access to declarations in header files like `<iostream>` or `<vector>`. **`#define`** is used to create macros. In its simplest form, it creates a symbolic constant: `#define PI 3.14`. The preprocessor will replace every occurrence of `PI` with `3.14` in the code. More complex macros can take arguments, like `#define SQUARE(x) (x * x)`. While sometimes useful, macros can be dangerous because they are simple text substitutions and don't respect scope or type safety. In modern C++, `const` variables are preferred for constants, and inline functions or templates are preferred over function-like macros. **Conditional Compilation** directives (`#if`, `#ifdef`, `#ifndef`, `#else`, `#endif`) allow you to control which parts of your code get compiled. For example, you can have platform-specific code or debugging code that is only included in certain builds. This is heavily used for writing cross-platform applications and for creating header guards to prevent multiple inclusions of the same header file.",
            "code": "// Example 1: Using #define for a constant and a simple macro\n#include <iostream>\n\n#define BUFFER_SIZE 1024\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint main() {\n    int buffer[BUFFER_SIZE];\n    std::cout << \"Buffer size is: \" << BUFFER_SIZE << std::endl;\n\n    int x = 5, y = 10;\n    std::cout << \"The minimum of \" << x << \" and \" << y << \" is \" << MIN(x, y) << std::endl;\n    return 0;\n}\n\n// Example 2: Conditional compilation for debugging\n#include <iostream>\n\n// To enable debug messages, you would compile with a flag like g++ -DDEBUG_MODE ...\n// Or you can just define it in the code like this:\n#define DEBUG_MODE\n\nint main() {\n    std::cout << \"This is a standard message.\" << std::endl;\n\n#ifdef DEBUG_MODE\n    std::cout << \"This is a debug message, only shown in debug mode.\" << std::endl;\n#endif\n\n    std::cout << \"Program finished.\" << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t3-header-guards",
            "title": "Header Guards",
            "desc": "Prevent multiple inclusions of header files using #ifndef.",
            "note": "In a C++ project, it's common for a header file to be included by multiple source files. It's also possible for one header file to include another, leading to a situation where a single source file might indirectly include the same header file more than once. If a header file contains definitions (like class definitions), including it multiple times in the same translation unit will lead to a redefinition error from the compiler. To prevent this, we use a standard preprocessor technique called **header guards**. The structure is simple and should be used in every header file you write. At the very top of the header file (e.g., `myheader.h`), you add the following lines: `#ifndef MYHEADER_H` `#define MYHEADER_H`. Then, at the very bottom of the file, you add: `#endif // MYHEADER_H`. Here's how it works: The first time the preprocessor sees this file, the macro `MYHEADER_H` has not been defined yet. So, `#ifndef MYHEADER_H` (if not defined) is true. The preprocessor then proceeds to the next line, `#define MYHEADER_H`, which defines the macro. It then includes the entire content of the header file until it hits the `#endif`. If the preprocessor encounters an `#include \"myheader.h\"` again in the same compilation process, it will check `#ifndef MYHEADER_H` again. This time, since `MYHEADER_H` is already defined, the condition will be false, and the preprocessor will skip everything down to the `#endif`, effectively ignoring the entire contents of the file and preventing a redefinition error. The macro name (`MYHEADER_H`) must be unique across the project.",
            "code": "// Example 1: Structure of a typical header file (e.g., 'MyClass.h')\n\n// Header Guard Start\n#ifndef MY_CLASS_H\n#define MY_CLASS_H\n\n#include <iostream>\n\nclass MyClass {\npublic:\n    void sayHello();\n};\n\n// Header Guard End\n#endif // MY_CLASS_H\n\n\n// Example 2: The corresponding implementation file (e.g., 'MyClass.cpp')\n\n// #include \"MyClass.h\" // We need the class declaration here\n\n// void MyClass::sayHello() {\n//     std::cout << \"Hello from MyClass!\" << std::endl;\n// }\n\n// Now, if another file includes MyClass.h, the guard prevents redefinition.\n// For example, in main.cpp:\n// #include \"MyClass.h\"\n// int main() { MyClass obj; obj.sayHello(); return 0; }"
          }
        ]
      },
      {
        "id": "c17-advanced-oop",
        "title": "Advanced OOP",
        "desc": "Tackle complex inheritance scenarios like multiple inheritance and the diamond problem.",
        "notes": "This chapter delves into some of the more complex and nuanced aspects of Object-Oriented Programming in C++. We will start with **multiple inheritance**, a feature that allows a class to inherit from more than one base class simultaneously. This can be a powerful way to combine the functionality of different classes. For example, a `FlyingCar` class might inherit from both a `Car` class and an `Airplane` class. However, multiple inheritance can introduce complexities, most notably the **diamond problem**. This problem occurs when a class inherits from two classes that both share a common base class, creating an ambiguity about which base class's members to use. We will explore how C++ solves the diamond problem using **virtual base classes** (virtual inheritance), which ensures that only one instance of the common base class is included in the final derived object. Next, we will cover **Run-Time Type Information (RTTI)**. RTTI is a mechanism that allows the type of an object to be determined during program execution. This is primarily used in the context of polymorphism, where you might have a base class pointer to a derived object and need to know the actual type of that object. The two main components of RTTI are the `typeid` operator, which returns an object containing information about a type, and the `dynamic_cast` operator, which provides a safe way to downcast a base class pointer to a derived class pointer, returning `nullptr` if the cast is not valid.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-multiple-inheritance",
            "title": "Multiple Inheritance",
            "desc": "Inherit from multiple base classes and understand the diamond problem.",
            "note": "Multiple inheritance allows a derived class to inherit members from more than one base class. The syntax is straightforward: `class Derived : public Base1, public Base2 { ... };`. The `Derived` class will now contain all the public and protected members from both `Base1` and `B`ase2. While this can be a powerful tool for combining functionalities, it can also lead to the 'diamond problem'. This occurs in the following inheritance structure: a class `D` inherits from two classes `B` and `C`, and both `B` and `C` inherit from a common base class `A`. This creates a diamond-shaped inheritance diagram. The problem is that class `D` will inherit two copies of the members of class `A` (one via `B` and one via `C`). If you try to access a member of `A` from an object of `D`, the compiler will issue an ambiguity error because it doesn't know which copy to use. This issue highlights the potential complexity of multiple inheritance and is a reason why some other object-oriented languages choose not to support it. C++, however, provides a solution to this problem through virtual inheritance.",
            "code": "// Example 1: A simple multiple inheritance scenario\n#include <iostream>\n\nclass Printer {\npublic:\n    void print() { std::cout << \"Printing document...\" << std::endl; }\n};\n\nclass Scanner {\npublic:\n    void scan() { std::cout << \"Scanning document...\" << std::endl; }\n};\n\n// MultifunctionPrinter inherits from both Printer and Scanner\nclass MultifunctionPrinter : public Printer, public Scanner {};\n\nint main() {\n    MultifunctionPrinter mfp;\n    mfp.print();\n    mfp.scan();\n    return 0;\n}\n\n// Example 2: Demonstrating the diamond problem (ambiguity)\n#include <iostream>\n\nclass PoweredDevice {\npublic:\n    int power = 10;\n};\n\nclass ScannerDevice : public PoweredDevice {};\nclass PrinterDevice : public PoweredDevice {};\n\n// Copier inherits two copies of 'power'\nclass Copier : public ScannerDevice, public PrinterDevice {};\n\nint main() {\n    Copier c;\n    // std::cout << c.power << std::endl; // AMBIGUITY ERROR!\n    // Compiler doesn't know which 'power' to use: the one from\n    // ScannerDevice or the one from PrinterDevice.\n    std::cout << \"This code would not compile due to ambiguity.\" << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t2-virtual-inheritance",
            "title": "Virtual Base Classes",
            "desc": "Solve the diamond problem using virtual inheritance.",
            "note": "Virtual inheritance is the C++ mechanism designed specifically to solve the diamond problem that arises in multiple inheritance. When you specify that a base class is inherited `virtual`ly, you are telling the compiler that you only want a single instance of that base class's members to be included in any subsequent derived classes, no matter how many times it appears in the inheritance hierarchy. To make a base class virtual, you use the `virtual` keyword in the inheritance declaration of the intermediate classes. In our diamond problem example (`A` is the base, `B` and `C` inherit from `A`, and `D` inherits from `B` and `C`), you would declare the inheritance like this: `class B : virtual public A { ... };` and `class C : virtual public A { ... };`. Now, when class `D` inherits from both `B` and `C`, the compiler knows that `A` is a virtual base class and ensures that `D` contains only one copy of `A`'s members. The ambiguity is resolved, and you can access the members of `A` from an object of `D` without any issues. Virtual inheritance adds a small amount of overhead and complexity to object construction, so it should only be used when necessary to solve the diamond problem.",
            "code": "// Example 1: Solving the diamond problem with virtual inheritance\n#include <iostream>\n\nclass PoweredDevice {\npublic:\n    int power = 10;\n};\n\n// Inherit PoweredDevice virtually\nclass ScannerDevice : virtual public PoweredDevice {};\nclass PrinterDevice : virtual public PoweredDevice {};\n\n// Copier now gets only one copy of PoweredDevice members\nclass Copier : public ScannerDevice, public PrinterDevice {};\n\nint main() {\n    Copier c;\n    // No ambiguity now!\n    std::cout << \"Power level: \" << c.power << std::endl;\n    c.power = 20;\n    std::cout << \"New power level: \" << c.power << std::endl;\n    return 0;\n}\n\n// Example 2: A more complete example\n#include <iostream>\n\nclass Animal {\npublic:\n    Animal(int age) : age(age) {}\n    void sleep() { std::cout << \"Animal is sleeping.\" << std::endl; }\nprotected:\n    int age;\n};\n\nclass Mammal : virtual public Animal {\npublic:\n    Mammal(int age) : Animal(age) {}\n    void walk() { std::cout << \"Mammal is walking.\" << std::endl; }\n};\n\nclass WingedAnimal : virtual public Animal {\npublic:\n    WingedAnimal(int age) : Animal(age) {}\n    void fly() { std::cout << \"Winged animal is flying.\" << std::endl; }\n};\n\nclass Bat : public Mammal, public WingedAnimal {\npublic:\n    // We must call the virtual base class constructor from the most derived class\n    Bat(int age) : Animal(age), Mammal(age), WingedAnimal(age) {}\n    void printAge() { std::cout << \"Bat's age is: \" << age << std::endl; }\n};\n\nint main() {\n    Bat b(5);\n    b.sleep(); // No ambiguity\n    b.printAge();\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c18-multithreading",
        "title": "Multithreading & Concurrency",
        "desc": "Write concurrent programs using std::thread, mutexes, and condition variables.",
        "notes": "Modern processors have multiple cores, and multithreading is the key to unlocking their full potential. Concurrency allows a program to perform multiple tasks seemingly at the same time, leading to better performance for computationally intensive tasks and improved responsiveness for user interfaces. C++11 introduced a standard threading library, making it much easier to write portable, multi-threaded applications. This chapter introduces the fundamentals of C++ concurrency. We'll start with **`std::thread`**, the class used to create and manage new threads of execution. You'll learn how to launch a new thread to run a specific function and how to wait for it to complete using `.join()`. When multiple threads access shared data, there's a risk of **race conditions**, where the outcome of the program depends on the non-deterministic order of thread execution, often leading to data corruption. To prevent this, we use synchronization primitives. The most fundamental of these is the **`std::mutex`** (mutual exclusion), which can be used to protect a critical section of code, ensuring that only one thread can access the shared data at a time. We'll also cover **`std::condition_variable`**, which allows threads to wait for a specific condition to become true, enabling more complex coordination between threads. Finally, we'll touch upon higher-level concurrency features like `std::future` and `std::async`, which provide a simpler way to run tasks asynchronously and retrieve their results.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-std-thread",
            "title": "std::thread",
            "desc": "Create and manage threads of execution with std::thread.",
            "note": "The `std::thread` class, found in the `<thread>` header, is the primary way to create and manage threads in modern C++. A thread is an independent path of execution within a program. When a C++ program starts, it has one main thread that executes the `main` function. You can create additional threads to perform tasks concurrently. To create a new thread, you construct a `std::thread` object, passing it a callable entity (like a function pointer, a function object, or a lambda expression) and any arguments that the function needs. For example, `std::thread myThread(myFunction, arg1);` creates a new thread that immediately starts executing `myFunction` with the argument `arg1`. The original thread (e.g., the main thread) continues its own execution in parallel. A crucial aspect of thread management is joining. When you call the `.join()` method on a `std::thread` object (`myThread.join();`), the calling thread will pause and wait until `myThread` has finished its execution. It's essential to `join` with a thread (or detach it) before the `std::thread` object is destroyed. Failing to do so will cause the program to terminate. Joining ensures that all work started in a thread is completed before the program proceeds or exits, and it's the standard way to synchronize the completion of a task.",
            "code": "// Example 1: Creating and joining a simple thread\n#include <iostream>\n#include <thread>\n\nvoid task() {\n    std::cout << \"Hello from the new thread!\" << std::endl;\n}\n\nint main() {\n    // Create a new thread and start its execution\n    std::thread t1(task);\n\n    std::cout << \"Hello from the main thread!\" << std::endl;\n\n    // Wait for the new thread to finish\n    t1.join();\n\n    std::cout << \"Thread has finished.\" << std::endl;\n    return 0;\n}\n\n// Example 2: Passing arguments to a thread's function\n#include <iostream>\n#include <thread>\n#include <string>\n\nvoid printMessage(const std::string& message, int count) {\n    for (int i = 0; i < count; ++i) {\n        std::cout << message << std::endl;\n    }\n}\n\nint main() {\n    std::string msg = \"Worker thread says hello\";\n    std::thread t1(printMessage, msg, 3);\n\n    // Do some other work in the main thread...\n\n    t1.join();\n    return 0;\n}"
          },
          {
            "id": "t2-mutex-locks",
            "title": "Mutex and Locks",
            "desc": "Protect shared data and prevent race conditions using std::mutex.",
            "note": "When two or more threads access and modify the same shared data concurrently, you can get a race condition. The result can be corrupted data because one thread might read a value while another thread is in the middle of updating it. To prevent this, you need to ensure mutual exclusion, meaning only one thread can access the critical section (the code that modifies the shared data) at a time. The standard tool for this is `std::mutex`, from the `<mutex>` header. A mutex is like a lock. Before a thread enters a critical section, it must lock the mutex. If another thread tries to lock the same mutex while it's already locked, that thread will be blocked (put to sleep) until the mutex is unlocked. Once the first thread is done with the critical section, it unlocks the mutex, allowing one of the waiting threads to proceed. While you can call `.lock()` and `.unlock()` directly on a mutex, this is error-prone. If an exception is thrown while the mutex is locked, `.unlock()` might never be called, leading to a deadlock. The preferred, safer way is to use RAII-style lock guards like `std::lock_guard` or `std::unique_lock`. For example, `std::lock_guard<std::mutex> guard(myMutex);`. This creates a `guard` object that locks the mutex in its constructor. When the `guard` object goes out of scope (at the end of the block), its destructor is automatically called, which unlocks the mutex. This guarantees the mutex is always released, even if an exception occurs.",
            "code": "// Example 1: A race condition (unsafe)\n#include <iostream>\n#include <thread>\n#include <vector>\n\nint counter = 0;\n\nvoid unsafe_increment() {\n    for (int i = 0; i < 100000; ++i) {\n        counter++;\n    }\n}\n\nint main() {\n    std::vector<std::thread> threads;\n    for (int i = 0; i < 10; ++i) {\n        threads.push_back(std::thread(unsafe_increment));\n    }\n    for (auto& t : threads) {\n        t.join();\n    }\n    // The result will likely NOT be 1,000,000 due to race conditions.\n    std::cout << \"Final counter (unsafe): \" << counter << std::endl;\n    return 0;\n}\n\n// Example 2: Using std::mutex to fix the race condition\n#include <iostream>\n#include <thread>\n#include <vector>\n#include <mutex>\n\nint safe_counter = 0;\nstd::mutex mtx; // Mutex to protect the counter\n\nvoid safe_increment() {\n    for (int i = 0; i < 100000; ++i) {\n        std::lock_guard<std::mutex> lock(mtx); // Lock mutex\n        safe_counter++;\n    } // Mutex is automatically unlocked when 'lock' goes out of scope\n}\n\nint main() {\n    std::vector<std::thread> threads;\n    for (int i = 0; i < 10; ++i) {\n        threads.push_back(std::thread(safe_increment));\n    }\n    for (auto& t : threads) {\n        t.join();\n    }\n    // The result will now be exactly 1,000,000.\n    std::cout << \"Final counter (safe): \" << safe_counter << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c19-modern-cpp",
        "title": "Modern C++ Features",
        "desc": "Learn key features from C++11, C++14, C++17, and C++20.",
        "notes": "The C++11 standard, released in 2011, marked a renaissance for the language, introducing a host of features that make C++ safer, more expressive, and easier to work with. Subsequent standards (C++14, C++17, C++20) have continued this trend, adding further improvements and capabilities. This chapter provides an overview of some of the most important modern C++ features. We'll start with conveniences like the `auto` keyword for type inference, which simplifies variable declarations, and **range-based for loops**, which provide a much cleaner syntax for iterating over containers. We'll then dive into **lambda expressions**, which allow you to define anonymous, inline functions, perfect for use with STL algorithms. We'll revisit smart pointers (`unique_ptr`, `shared_ptr`), which are a cornerstone of modern C++ memory management. A key topic will be **move semantics** and **rvalue references (`&&`)**, an advanced feature that allows for the efficient transfer of resources (like memory allocated by a vector) from one object to another, avoiding expensive copies. This is crucial for performance in many applications. Finally, we'll get a glimpse of features from the latest standards, such as **structured bindings** (C++17) for easily unpacking tuples and pairs, and **concepts** (C++20), which provide a powerful way to put constraints on template parameters, leading to much clearer compiler errors when templates are used incorrectly. Embracing these modern features is essential for writing effective, contemporary C++ code.",
        "code": "",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-auto-range-for",
            "title": "auto and Range-Based for Loops",
            "desc": "Simplify code with automatic type deduction and cleaner loop syntax.",
            "note": "Two of the most frequently used and appreciated features of modern C++ are the `auto` keyword and range-based `for` loops. The `auto` keyword instructs the compiler to automatically deduce the type of a variable from its initializer. For example, instead of writing `std::vector<int>::iterator it = myVector.begin();`, which is verbose and prone to typos, you can simply write `auto it = myVector.begin();`. The compiler knows the type returned by `.begin()` and assigns it to `it`. This makes the code significantly cleaner, more readable, and less brittle to changes (if the container type changes, you don't have to update the iterator type). The range-based `for` loop provides a simplified syntax for iterating over all the elements in a range, such as an array, an STL container, or any other object that has `begin()` and `end()` methods. Instead of the traditional iterator-based loop, `for (auto it = vec.begin(); it != vec.end(); ++it)`, you can write `for (const auto& element : vec) { ... }`. This loop will iterate through each `element` in the `vec` container. Using `const auto&` is a common and efficient pattern: `auto` deduces the type, `&` makes it a reference to avoid a potentially expensive copy of the element, and `const` ensures you don't accidentally modify the element inside the loop.",
            "code": "// Example 1: Using 'auto' to simplify declarations\n#include <iostream>\n#include <vector>\n#include <map>\n\nint main() {\n    auto i = 42; // i is deduced as int\n    auto d = 3.14; // d is deduced as double\n\n    std::vector<int> numbers = {1, 2, 3};\n    auto it = numbers.begin(); // it is deduced as std::vector<int>::iterator\n\n    std::map<std::string, int> myMap;\n    myMap[\"key\"] = 100;\n    auto map_it = myMap.find(\"key\"); // deduced as std::map<...>::iterator\n\n    std::cout << \"Value of i: \" << i << std::endl;\n    std::cout << \"First vector element: \" << *it << std::endl;\n    std::cout << \"Map value: \" << map_it->second << std::endl;\n    return 0;\n}\n\n// Example 2: Using a range-based for loop\n#include <iostream>\n#include <vector>\n#include <string>\n\nint main() {\n    std::vector<std::string> words = {\"C++\", \"is\", \"awesome\"};\n\n    std::cout << \"Iterating through the vector: \";\n    // 'word' will be a copy of each element in 'words'\n    for (const auto& word : words) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t2-lambda-expressions",
            "title": "Lambda Expressions",
            "desc": "Create anonymous, inline functions, especially for use with algorithms.",
            "note": "A lambda expression, or lambda, is a convenient way to define an anonymous function object right at the location where it is needed. Lambdas are particularly useful when working with STL algorithms that take a callable entity as an argument, such as `std::sort`, `std::for_each`, or `std::find_if`. The basic syntax of a lambda is `[capture](parameters) -> return_type { body; }`. Let's break this down. The `[]` is the capture clause, which specifies which variables from the surrounding scope the lambda can access. You can capture by value (`[=]`), by reference (`[&]`), or list specific variables (`[var1, &var2]`). The `()` is the parameter list, just like a regular function. The `-> return_type` is optional; if omitted, the compiler will try to deduce the return type from the `return` statements in the body. The `{}` contains the body of the lambda function. For example, to find the first even number in a vector, you could use `std::find_if(vec.begin(), vec.end(), [](int n) { return n % 2 == 0; });`. Here, `[](int n) { return n % 2 == 0; }` is a lambda that takes an integer `n` and returns `true` if it's even. Lambdas make the code more concise and readable because the logic is defined right where it's used, avoiding the need to define a separate named function or a functor class for a simple, one-off operation.",
            "code": "// Example 1: Using a lambda with std::for_each\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    std::cout << \"The vector contains: \";\n    // A simple lambda that prints an integer\n    std::for_each(numbers.begin(), numbers.end(), [](int n) {\n        std::cout << n << \" \";\n    });\n    std::cout << std::endl;\n    return 0;\n}\n\n// Example 2: Using a lambda with capture for custom sort\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> nums = {1, 2, 3, 4, 5, 6, 7, 8};\n    int count = 0;\n\n    // A lambda that captures 'count' by reference to modify it\n    int even_count = std::count_if(nums.begin(), nums.end(), [&count](int n) {\n        if (n % 2 == 0) {\n            count++; // Modify the captured variable\n            return true;\n        }\n        return false;\n    });\n\n    std::cout << \"Found \" << count << \" even numbers.\" << std::endl;\n    std::cout << \"(count_if returned: \" << even_count << \")\" << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t3-move-semantics",
            "title": "Move Semantics",
            "desc": "Understand rvalue references and move semantics for efficient resource transfer.",
            "note": "Move semantics, introduced in C++11, is a major optimization feature that allows resources to be transferred from one object to another instead of being copied. This is particularly important for objects that manage expensive-to-copy resources, such as `std::vector` (which manages a dynamically allocated array) or `std::string`. The mechanism behind move semantics is the **rvalue reference**, denoted by a double ampersand (`&&`). An rvalue reference is a reference that can bind to a temporary object (an rvalue)—an object that is about to be destroyed, like the result of a function call. To enable move semantics, a class can implement a **move constructor** and a **move assignment operator**. These special member functions take an rvalue reference to an object of the same class. Instead of deep-copying the resource, they 'steal' it from the source object and leave the source object in a valid but empty or unspecified state. For example, the move constructor for a `std::vector` wouldn't copy all the elements; it would just copy the pointer to the internal array from the source vector and set the source vector's pointer to `nullptr`. The `std::move` function is used to cast an lvalue (a named object) into an rvalue, signaling that you are done with the object and its resources can be moved from. This avoids unnecessary allocations and copies, significantly improving performance.",
            "code": "// Example 1: Move semantics with std::vector\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> create_vector() {\n    std::vector<std::string> temp = {\"one\", \"two\", \"three\"};\n    return temp;\n}\n\nint main() {\n    // The vector returned by create_vector() is a temporary (rvalue).\n    // The move constructor of 'my_vec' is called, avoiding a deep copy.\n    std::vector<std::string> my_vec = create_vector();\n\n    std::cout << \"my_vec contains: \";\n    for (const auto& s : my_vec) {\n        std::cout << s << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n\n// Example 2: Explicitly using std::move\n#include <iostream>\n#include <vector>\n#include <utility> // For std::move\n\nint main() {\n    std::vector<int> vec1 = {10, 20, 30};\n    std::cout << \"vec1 size before move: \" << vec1.size() << std::endl;\n\n    // Transfer ownership of vec1's resources to vec2\n    // After this, vec1 is in a valid but likely empty state\n    std::vector<int> vec2 = std::move(vec1);\n\n    std::cout << \"vec1 size after move: \" << vec1.size() << std::endl;\n    std::cout << \"vec2 size after move: \" << vec2.size() << std::endl;\n\n    std::cout << \"vec2 contains: \";\n    for(int i : vec2) std::cout << i << \" \";\n    std::cout << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c20-data-structures",
        "title": "Data Structures in C++",
        "desc": "Implement fundamental data structures like linked lists, trees, and graphs.",
        "notes": "While the STL provides excellent, general-purpose implementations of common data structures, understanding how to build them from scratch is crucial for a deep understanding of computer science principles and for situations where a custom implementation is required. This chapter will guide you through implementing some of the most fundamental data structures using C++ classes and pointers. We'll start with the **linked list**, a linear data structure where elements are not stored in contiguous memory. Instead, each element (a 'node') contains its data and a pointer to the next node in the sequence. This structure allows for efficient insertions and deletions but lacks the fast random access of an array. We will then move on to non-linear structures. **Trees**, specifically binary search trees (BSTs), are hierarchical structures where each node has at most two children. BSTs maintain a specific ordering property that allows for fast searching, insertion, and deletion (on average O(log n)). Finally, we'll explore **graphs**, which are powerful structures used to model networks and relationships. A graph consists of a set of vertices (or nodes) and a set of edges connecting these vertices. We'll discuss common ways to represent graphs in code (adjacency matrix and adjacency list) and touch upon basic traversal algorithms. Implementing these structures will solidify your understanding of pointers, dynamic memory allocation, and object-oriented design.",
        "code": "",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-linked-list",
            "title": "Linked List",
            "desc": "Implement a singly linked list with insertion and deletion operations.",
            "note": "A linked list is a linear data structure composed of a sequence of nodes. Each node contains two pieces of information: the data itself and a pointer to the next node in the list. The list is accessed through a pointer to the first node, often called the `head`. The last node in the list has its 'next' pointer set to `nullptr`, indicating the end of the list. Unlike arrays, linked lists do not store elements in contiguous memory locations, which gives them their primary advantage: insertions and deletions can be performed in constant time (O(1)) if you have a pointer to the relevant node, as it only requires redirecting a few pointers. The disadvantage is the lack of direct random access; to find the nth element, you must traverse the list from the `head`, which takes linear time (O(n)). To implement a linked list, you typically start by defining a `Node` class or struct that holds the data and the 'next' pointer. Then, you create a `LinkedList` class that manages the list, keeping track of the `head` pointer and providing methods like `insertAtBeginning`, `deleteNode`, and `displayList`. Implementing a linked list is an excellent exercise in working with pointers and dynamic memory management.",
            "code": "// Example 1: Basic Node and LinkedList structure\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(nullptr) {}\n};\n\nclass LinkedList {\npublic:\n    Node* head;\n    LinkedList() : head(nullptr) {}\n\n    void insert(int val) {\n        Node* newNode = new Node(val);\n        newNode->next = head;\n        head = newNode;\n    }\n\n    void display() {\n        Node* current = head;\n        while (current != nullptr) {\n            std::cout << current->data << \" -> \";\n            current = current->next;\n        }\n        std::cout << \"null\" << std::endl;\n    }\n};\n\nint main() {\n    LinkedList list;\n    list.insert(10);\n    list.insert(20);\n    list.insert(30);\n    list.display();\n    return 0;\n}\n\n// Example 2: Deleting the head node in a linked list\n#include <iostream>\n\n// (Using the Node and LinkedList classes from Example 1)\n// ...\n\nvoid deleteList(Node*& head) {\n    Node* current = head;\n    Node* nextNode = nullptr;\n    while(current != nullptr) {\n        nextNode = current->next;\n        delete current;\n        current = nextNode;\n    }\n    head = nullptr;\n}\n\nint main() {\n    LinkedList list;\n    list.insert(1);\n    list.insert(2);\n    list.display();\n    deleteList(list.head);\n    std::cout << \"After deleting list: \";\n    list.display();\n    return 0;\n}"
          },
          {
            "id": "t2-binary-search-tree",
            "title": "Trees (Binary Search Tree)",
            "desc": "Implement a binary search tree with insertion, search, and traversal.",
            "note": "A binary search tree (BST) is a node-based binary tree data structure which has the following properties: the left subtree of a node contains only nodes with keys lesser than the node's key; the right subtree of a node contains only nodes with keys greater than the node's key; and both the left and right subtrees must also be binary search trees. This ordering property is the key to the BST's efficiency. Operations like searching for a value, inserting a new value, and deleting a value can be performed in O(log n) time on average for a balanced tree, where n is the number of nodes. The implementation is similar to a linked list in that you have a `Node` structure, but this time each node contains data, a pointer to a left child, and a pointer to a right child. The `BST` class would manage a pointer to the `root` node. The insertion and search operations are typically implemented recursively. To search for a value, you start at the root. If the value is less than the current node's key, you go to the left child; if it's greater, you go to the right child. You repeat this until you find the value or reach a `nullptr`, meaning the value is not in the tree. Tree traversal algorithms like in-order, pre-order, and post-order are also fundamental operations, often implemented recursively, to visit all the nodes in a specific order.",
            "code": "// Example 1: Basic Binary Search Tree implementation\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node *left, *right;\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nNode* insert(Node* root, int data) {\n    if (root == nullptr) return new Node(data);\n    if (data < root->data) {\n        root->left = insert(root->left, data);\n    } else {\n        root->right = insert(root->right, data);\n    }\n    return root;\n}\n\nvoid inorderTraversal(Node* root) {\n    if (root == nullptr) return;\n    inorderTraversal(root->left);\n    std::cout << root->data << \" \";\n    inorderTraversal(root->right);\n}\n\nint main() {\n    Node* root = nullptr;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 20);\n    insert(root, 40);\n    insert(root, 70);\n    std::cout << \"In-order traversal of the BST: \";\n    inorderTraversal(root);\n    std::cout << std::endl;\n    return 0;\n}\n\n// Example 2: Searching for a value in the BST\n#include <iostream>\n\n// (Using Node struct and insert function from Example 1)\n// ...\n\nbool search(Node* root, int key) {\n    if (root == nullptr) return false;\n    if (root->data == key) return true;\n    if (key < root->data) {\n        return search(root->left, key);\n    } else {\n        return search(root->right, key);\n    }\n}\n\nint main() {\n    Node* root = nullptr;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 70);\n    std::cout << std::boolalpha;\n    std::cout << \"Is 30 in the tree? \" << search(root, 30) << std::endl;\n    std::cout << \"Is 90 in the tree? \" << search(root, 90) << std::endl;\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c21-advanced-topics",
        "title": "Advanced Topics",
        "desc": "Explore specialized topics like bit manipulation and function pointers.",
        "notes": "This chapter covers a collection of advanced and specialized C++ topics that are important for system-level programming, optimization, and writing highly flexible code. We'll start by revisiting **operator precedence**, providing a more formal understanding of the rules that determine the order in which operators are evaluated in complex expressions. A solid grasp of this prevents subtle bugs. Next, we will dive into **bit manipulation**. This involves using bitwise operators (`&`, `|`, `^`, `~`, `<<`, `>>`) to directly manipulate the individual bits of integer data types. Bit manipulation is extremely fast and memory-efficient, making it essential in low-level programming domains like embedded systems, device drivers, and performance-critical algorithms. We'll explore other low-level concepts like **memory alignment**, understanding how compilers arrange data in memory to optimize access speeds for the processor. We will also take a deeper look at **function pointers**. While we've touched on them before, here we'll explore their syntax and usage in more detail, including their role in implementing callback mechanisms and designing plug-in architectures. Finally, we'll cover how to handle **command-line arguments** in the `main` function (`argc` and `argv`), which allows your programs to accept input directly from the terminal when they are launched, a standard feature for command-line tools.",
        "code": "",
        "duration": "1 week",
        "topics": [
          {
            "id": "t1-bit-manipulation",
            "title": "Bit Manipulation",
            "desc": "Use bitwise operators for efficient, low-level data manipulation.",
            "note": "Bit manipulation is the act of algorithmically manipulating bits or other pieces of data shorter than a word. This is a crucial skill for low-level programming and can lead to significant performance optimizations. C++ provides a set of bitwise operators to work directly on the binary representation of integers. The **AND (`&`)** operator compares two bits and generates a result of 1 if both bits are 1, and 0 otherwise. It's often used for 'masking', which means extracting a subset of bits. The **OR (`|`)** operator generates a result of 1 if either of the bits is 1. It's used to set specific bits to 1. The **XOR (`^`)** operator (exclusive OR) generates a result of 1 if the two bits are different. It's used to toggle bits. The **NOT (`~`)** operator inverts all the bits of its operand. The **Left Shift (`<<`)** and **Right Shift (`>>`)** operators shift the bits of a number to the left or right by a specified number of positions. A left shift by `n` is equivalent to multiplying by 2^n, and a right shift is equivalent to dividing by 2^n for non-negative numbers, which are much faster operations than actual multiplication or division. These operators are fundamental in areas like graphics programming, cryptography, and network protocols.",
            "code": "// Example 1: Basic bitwise operators\n#include <iostream>\n#include <bitset>\n\nint main() {\n    unsigned char a = 0b01010101; // 85\n    unsigned char b = 0b11110000; // 240\n\n    std::cout << \"a     = \" << std::bitset<8>(a) << std::endl;\n    std::cout << \"b     = \" << std::bitset<8>(b) << std::endl;\n    std::cout << \"a & b = \" << std::bitset<8>(a & b) << std::endl;\n    std::cout << \"a | b = \" << std::bitset<8>(a | b) << std::endl;\n    std::cout << \"a ^ b = \" << std::bitset<8>(a ^ b) << std::endl;\n    std::cout << \"~a    = \" << std::bitset<8>(~a) << std::endl;\n    return 0;\n}\n\n// Example 2: Using bit shifts to check for odd/even\n#include <iostream>\n\n// A number is even if its least significant bit is 0\nbool isEven(int n) {\n    return (n & 1) == 0;\n}\n\nint main() {\n    int num1 = 10; // binary ...1010\n    int num2 = 7;  // binary ...0111\n\n    std::cout << std::boolalpha;\n    std::cout << num1 << \" is even? \" << isEven(num1) << std::endl;\n    std::cout << num2 << \" is even? \" << isEven(num2) << std::endl;\n\n    // Using shifts for fast multiplication/division by 2\n    std::cout << \"10 * 2 = \" << (10 << 1) << std::endl;\n    std::cout << \"10 / 2 = \" << (10 >> 1) << std::endl;\n    return 0;\n}"
          },
          {
            "id": "t2-command-line-args",
            "title": "Command-Line Arguments",
            "desc": "Process arguments passed to your program from the command line.",
            "note": "Command-line arguments are parameters that you can pass to your program when you execute it from a terminal or command prompt. This is a common way to provide input, specify options, or pass file paths to an application. To access these arguments in C++, you need to use a specific signature for your `main` function: `int main(int argc, char* argv[])`. Here, `argc` (argument count) is an integer that holds the number of command-line arguments passed to the program. `argv` (argument vector) is an array of C-style strings (character pointers). By convention, `argv[0]` is always the name of the program itself. The actual arguments you pass start from `argv[1]`. So, `argc` is always at least 1. For example, if you run your program like `./my_program hello 123`, then `argc` will be 3. `argv[0]` will be `./my_program`, `argv[1]` will be `hello`, and `argv[2]` will be `123`. Note that all arguments, even numbers, are passed as strings. If you need to use them as numbers, you'll have to convert them using functions like `std::stoi` (for string to integer) or `std::stod` (for string to double). Processing command-line arguments is an essential skill for writing utility programs and tools.",
            "code": "// Example 1: Printing all command-line arguments\n#include <iostream>\n\n// Run from terminal like: ./my_app arg1 arg2 arg3\nint main(int argc, char* argv[]) {\n    std::cout << \"You have entered \" << argc << \" arguments:\" << std::endl;\n\n    for (int i = 0; i < argc; ++i) {\n        std::cout << \"argv[\" << i << \"]: \" << argv[i] << std::endl;\n    }\n    return 0;\n}\n\n// Example 2: A simple calculator using command-line arguments\n#include <iostream>\n#include <string>\n#include <stdexcept>\n\n// Run from terminal like: ./calculator 10 + 5\nint main(int argc, char* argv[]) {\n    if (argc != 4) {\n        std::cerr << \"Usage: \" << argv[0] << \" <num1> <operator> <num2>\" << std::endl;\n        return 1;\n    }\n\n    try {\n        double num1 = std::stod(argv[1]);\n        char op = argv[2][0];\n        double num2 = std::stod(argv[3]);\n\n        if (op == '+') {\n            std::cout << \"Result: \" << num1 + num2 << std::endl;\n        }\n    } catch (const std::invalid_argument& e) {\n        std::cerr << \"Error: Invalid number provided.\" << std::endl;\n        return 1;\n    }\n    return 0;\n}"
          }
        ]
      },
       {
        "id": "c22-tools-practices",
        "title": "Tools, Best Practices & Deployment",
        "desc": "Learn about essential tools, design patterns, clean code principles, and career tips.",
        "notes": "Writing code is only one part of software development. This final, crucial chapter focuses on the tools, practices, and methodologies that professional C++ developers use to build robust, maintainable, and high-quality software. We'll start with **build systems**, focusing on **CMake**. CMake is a cross-platform tool that automates the process of compiling and linking a project, making it easy to build your software on different operating systems and with different compilers. Next, we'll cover **version control** with **Git**, the industry standard for tracking changes in code, collaborating with teams, and managing different versions of a project. A fundamental practice for ensuring code quality is **unit testing**. We'll introduce **GoogleTest**, a popular framework for writing and running tests that verify the correctness of individual components (units) of your code. We'll also discuss the importance of **debugging** and **profiling** tools to find and fix bugs and performance bottlenecks. Beyond tools, we'll explore higher-level concepts. **Design patterns** are general, reusable solutions to commonly occurring problems within a given context in software design. We'll touch on what they are and why they're useful. We'll also emphasize the principles of **clean code**: writing code that is readable, simple, and easy for other developers (and your future self) to understand and maintain. Finally, we'll conclude with some career tips for aspiring C++ developers, pointing towards common application domains and areas for further learning.",
        "code": "",
        "duration": "4 weeks",
        "topics": [
          {
            "id": "t1-cmake-git",
            "title": "CMake and Git",
            "desc": "Manage your build process with CMake and track your code with Git.",
            "note": "**CMake** is an open-source, cross-platform family of tools designed to build, test, and package software. It is not a build system itself but rather a build system generator. You write your build instructions in a simple text file called `CMakeLists.txt`. In this file, you specify your project's name, find required libraries, and list your source files to create executables or libraries. CMake then uses this file to generate native build files for your chosen environment (e.g., Makefiles on Linux, Visual Studio projects on Windows). This means you can maintain a single, simple build configuration that works everywhere, which is invaluable for professional development. **Git** is a distributed version control system (VCS) that is essential for modern software development. It allows you to track every change you make to your code over time in a repository. You can create 'commits' to save snapshots of your project at specific points. You can create 'branches' to work on new features in isolation without affecting the main codebase. If you make a mistake, you can easily revert to a previous version. Git is also fundamental for collaboration. Platforms like GitHub and GitLab host Git repositories, allowing teams of developers to work on the same project, merge their changes, review each other's code, and manage the entire development lifecycle. Mastering the basics of CMake and Git is a non-negotiable skill for any serious C++ developer.",
            "code": "// Example 1: A very simple CMakeLists.txt file\n\n// # Set the minimum required version of CMake\n// cmake_minimum_required(VERSION 3.10)\n\n// # Set the project name\n// project(MyAwesomeApp)\n\n// # Add the executable, specifying the source file\n// add_executable(MyAwesomeApp main.cpp)\n\n\n// Example 2: Basic Git commands (to be run in a terminal)\n\n// # Initialize a new git repository in the current folder\n// git init\n\n// # Stage a file to be included in the next commit\n// git add main.cpp\n\n// # Commit the staged changes with a message\n// git commit -m \"Initial commit: Add main.cpp\"\n\n// # Check the status of the repository\n// git status"
          },
          {
            "id": "t2-unit-testing",
            "title": "Unit Testing with GoogleTest",
            "desc": "Write unit tests to verify the correctness of your code using the GoogleTest framework.",
            "note": "Unit testing is the practice of testing individual units or components of a software to ensure they work correctly in isolation. A unit is the smallest testable part of an application, often a single function or a method of a class. The goal is to verify that each part of the code performs as expected. Writing tests helps you catch bugs early in the development process, makes your code more robust, and provides confidence when refactoring or adding new features, as you can run the tests to ensure you haven't broken existing functionality. GoogleTest is a widely-used, open-source C++ testing framework developed by Google. It provides a rich set of assertions to check for various conditions. You write tests using macros like TEST() to define a test case. Inside the test, you use assertion macros like EXPECT_EQ(expected, actual) to check if two values are equal, ASSERT_TRUE(condition) to check if a condition is true, and many others. You then compile and run your tests. The framework provides clear output, telling you which tests passed and which failed, along with detailed messages for the failures. Integrating unit testing into your development workflow is a hallmark of a professional software engineer.",
            "code": "// Example 1: A function to be tested (e.g., in math_functions.h)\n// int add(int a, int b) { return a + b; }\n\n// A corresponding GoogleTest test (in test_math.cpp)\n// #include \"gtest/gtest.h\"\n// #include \"math_functions.h\"\n\n// TEST(AdditionTest, PositiveNumbers) {\n//     EXPECT_EQ(add(2, 3), 5);\n// }\n// TEST(AdditionTest, NegativeNumbers) {\n//     EXPECT_EQ(add(-2, -3), -5);\n// }\n\n// Example 2: Testing a simple Counter class\n// #include \"gtest/gtest.h\"\n// #include \"Counter.h\" // Assume Counter class is in this header\n\n// TEST(CounterTest, IncrementsCorrectly) {\n//     Counter c;\n//     c.inc();\n//     c.inc();\n//     ASSERT_EQ(c.get(), 2);\n// }"
          },
          {
            "id": "t3-design-patterns",
            "title": "Design Patterns",
            "desc": "Learn about common design patterns as reusable solutions to software design problems.",
            "note": "Design patterns are well-documented, reusable solutions to common problems that arise during software design. They are not specific algorithms or pieces of code, but rather general concepts and templates that describe how to structure classes and objects to solve a particular problem in a flexible and maintainable way. They represent the distilled experience of many software developers over many years. Design patterns are typically categorized into three groups. **Creational Patterns** deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. Examples include the Singleton (ensuring a class has only one instance) and Factory Method (creating objects without specifying the exact class of object that will be created). **Structural Patterns** deal with object composition, or how to assemble objects and classes into larger structures. Examples include the Adapter (allowing incompatible interfaces to work together) and Decorator (adding new functionality to an object dynamically). **Behavioral Patterns** are concerned with communication between objects. Examples include the Observer (defining a one-to-many dependency between objects so that when one object changes state, all its dependents are notified) and Strategy (defining a family of algorithms, encapsulating each one, and making them interchangeable). Learning design patterns provides you with a shared vocabulary and a toolkit of proven solutions, helping you avoid reinventing the wheel and enabling you to build more sophisticated and robust software architectures.",
            "code": "// Example 1: Conceptual code for the Singleton Pattern\n#include <iostream>\n\nclass Logger {\nprivate:\n    Logger() {}\npublic:\n    Logger(const Logger&) = delete;\n    Logger& operator=(const Logger&) = delete;\n    static Logger& getInstance() {\n        static Logger instance;\n        return instance;\n    }\n    void log(const std::string& msg) {\n        std::cout << \"LOG: \" << msg << std::endl;\n    }\n};\n\nint main() {\n    Logger::getInstance().log(\"Application started.\");\n    return 0;\n}\n\n// Example 2: Conceptual code for the Strategy Pattern\n#include <iostream>\n#include <memory>\n\nclass ISortStrategy {\npublic:\n    virtual void sort() = 0;\n    virtual ~ISortStrategy() = default;\n};\nclass BubbleSort : public ISortStrategy {\npublic:\n    void sort() override { std::cout << \"Sorting with Bubble Sort.\" << std::endl; }\n};\n\nclass Sorter {\nprivate:\n    std::unique_ptr<ISortStrategy> strategy;\npublic:\n    void setStrategy(std::unique_ptr<ISortStrategy> s) { strategy = std::move(s); }\n    void performSort() { if(strategy) strategy->sort(); }\n};\n\nint main() {\n    Sorter sorter;\n    sorter.setStrategy(std::make_unique<BubbleSort>());\n    sorter.performSort();\n    return 0;\n}"
          },
          {
            "id": "t4-clean-code-career",
            "title": "Clean Code, Debugging & Career",
            "desc": "Learn principles of clean code, debugging/profiling techniques, and career advice.",
            "note": "Writing code that works is only the first step; writing code that is clean, readable, and maintainable is the hallmark of a professional. **Clean Code** principles advocate for simple, understandable, and well-organized code. This includes using meaningful variable names, writing short, focused functions, adding clarifying comments (but only when necessary), and maintaining a consistent coding style. Clean code is easier to debug, extend, and for new team members to understand. **Debugging** is the systematic process of finding and fixing bugs. You'll learn to use a debugger (like GDB or the one in your IDE) to step through your code line-by-line, inspect the state of variables, and analyze the call stack to pinpoint the root cause of a problem. **Profiling** is the process of analyzing a program's performance to identify bottlenecks. Profiling tools help you find which parts of your code are consuming the most time or memory, allowing you to focus your optimization efforts where they will have the most impact. Finally, as you master these skills, consider your **career path**. C++ is in high demand in performance-critical fields like game development, high-frequency trading, robotics, embedded systems, and scientific computing. Continuously learning, contributing to open-source projects, and building a portfolio are excellent ways to advance your career.",
            "code": "// Example 1: 'Before' and 'after' clean code refactoring\n\n// Before: Unclear and hard to read\n// int proc(int d) {\n//     int t = 0; for (int i=0; i<d; i++) { t+=i; } return t;\n// }\n\n// After: Clear and self-documenting\nint calculateSumUpTo(int limit) {\n    int sum = 0;\n    for (int i = 0; i < limit; ++i) {\n        sum += i;\n    }\n    return sum;\n}\n\n// Example 2: Conceptual debugging with print statements\n#include <iostream>\n\nvoid buggyFunction(int x) {\n    std::cout << \"[DEBUG] Entering function with x = \" << x << std::endl;\n    int result = x / (x - 5); // Potential division by zero\n    // A debugger is a much better tool for inspecting 'x' before a crash.\n    std::cout << \"[DEBUG] Result: \" << result << std::endl;\n}\n\nint main() {\n    buggyFunction(10);\n    // The following line would crash the program:\n    // buggyFunction(5);\n    return 0;\n}"
          }
        ]
      },
      {
        "id": "c23-networking",
        "title": "Networking & Sockets",
        "desc": "Understand networking basics, socket programming, and using high-level libraries.",
        "notes": "Networking enables programs to communicate across different computers, forming the backbone of the internet and distributed systems. This chapter introduces the fundamentals of network programming in C++. We'll start with the core concepts of the TCP/IP model, understanding the roles of IP addresses for location and ports for service identification. We will differentiate between the two primary transport protocols: TCP (Transmission Control Protocol), which provides reliable, connection-oriented communication, and UDP (User Datagram Protocol), which offers a faster, connectionless, but less reliable service. The traditional way to perform network communication in C++ is through the Sockets API (like Berkeley Sockets or Winsock). We'll cover the conceptual workflow for creating a simple client-server application: creating a socket, binding it to an address, listening for connections, accepting them, and finally, sending and receiving data. While powerful, the Sockets API is low-level and platform-specific. Therefore, we will also explore modern, high-level, cross-platform networking libraries like Boost.Asio and cpp-httplib. These libraries provide a much safer and more convenient abstraction over raw sockets, making it significantly easier to build robust networked applications like HTTP clients or servers.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-networking-basics",
            "title": "Networking Basics (TCP/IP)",
            "desc": "Learn about the client-server model, TCP vs. UDP, IPs, and ports.",
            "note": "At the heart of most network communication is the client-server model. A **server** is a program that provides a service by listening for incoming network requests. A **client** is a program that connects to a server to use that service. To communicate, they need an address. This is provided by the Internet Protocol (IP), which gives every device on a network a unique **IP address**. However, a single device might be running multiple server applications (e.g., a web server and a database server). To differentiate between them, we use **ports**. A port is just a 16-bit number (0-65535) that identifies a specific application or process. The combination of an IP address and a port number creates a unique endpoint for communication. Data is transmitted using a transport protocol. The most common is **TCP (Transmission Control Protocol)**. It's 'connection-oriented', meaning it establishes a reliable, two-way communication channel between the client and server. It guarantees that data arrives in order and without errors by retransmitting lost packets. This makes it ideal for web browsing, file transfers, and email. The other major protocol is **UDP (User Datagram Protocol)**. It is 'connectionless' and does not guarantee delivery or order. It simply sends packets ('datagrams') and hopes for the best. This lack of overhead makes it much faster, so it's used for applications where speed is more critical than perfect reliability, such as online gaming, video streaming, and DNS lookups.",
            "code": "// Example 1: Conceptual representation of an endpoint\n#include <iostream>\n#include <string>\n\nstruct Endpoint {\n    std::string ip_address;\n    int port;\n};\n\nint main() {\n    Endpoint web_server;\n    web_server.ip_address = \"192.168.1.1\";\n    web_server.port = 80; // Default port for HTTP\n\n    std::cout << \"Connecting to \" << web_server.ip_address << \":\" << web_server.port << std::endl;\n    return 0;\n}\n\n// Example 2: Choosing a protocol conceptually\n#include <iostream>\n\nenum class Protocol { TCP, UDP };\n\nvoid start_service(Protocol p) {\n    if (p == Protocol::TCP) {\n        std::cout << \"Starting reliable TCP service...\" << std::endl;\n    } else {\n        std::cout << \"Starting fast UDP service...\" << std::endl;\n    }\n}\n\nint main() {\n    // Use TCP for a file transfer application\n    start_service(Protocol::TCP);\n    // Use UDP for a live video game\n    start_service(Protocol::UDP);\n    return 0;\n}"
          },
          {
            "id": "t2-socket-programming",
            "title": "Socket Programming Concepts",
            "desc": "Understand the basic API calls for low-level socket programming.",
            "note": "The Sockets API is the standard low-level interface for network programming. While the exact code differs between platforms (e.g., Winsock on Windows, POSIX sockets on Linux/macOS), the concepts are universal. A **socket** is an endpoint of communication, represented in code as an object or handle. The typical server workflow is: 1. `socket()`: Create a new socket. 2. `bind()`: Associate the socket with a specific IP address and port on the local machine. This is how clients know where to connect. 3. `listen()`: Put the socket in a passive mode, waiting for incoming client connections. You can specify a backlog limit, which is the number of connections that can be queued. 4. `accept()`: This is a blocking call. The server waits here until a client tries to connect. When a connection is made, `accept()` returns a *new* socket that is dedicated to communicating with that specific client, while the original listening socket goes back to waiting for more connections. The client workflow is simpler: 1. `socket()`: Create a new socket. 2. `connect()`: Actively try to establish a connection to the server's IP address and port. Once the connection is established (i.e., the server has `accept`ed), both client and server can use `send()` and `recv()` (or `write()` and `read()`) on their respective sockets to exchange data.",
            "code": "// Example 1: Conceptual C++-like server workflow\n#include <iostream>\n\n// NOTE: This is not runnable code, just a conceptual outline.\nvoid server_pseudo_code() {\n    // int listening_socket = socket(AF_INET, SOCK_STREAM, 0);\n    // bind(listening_socket, \"127.0.0.1\", 8080);\n    // listen(listening_socket, 5);\n    std::cout << \"Server is listening for connections...\" << std::endl;\n\n    // int client_socket = accept(listening_socket);\n    std::cout << \"Client connected!\" << std::endl;\n\n    // char buffer[1024];\n    // recv(client_socket, buffer, sizeof(buffer));\n    // send(client_socket, \"Hello Client!\", 13);\n\n    // close(client_socket);\n    // close(listening_socket);\n}\n\n// Example 2: Conceptual C++-like client workflow\n#include <iostream>\n\n// NOTE: This is not runnable code, just a conceptual outline.\nvoid client_pseudo_code() {\n    // int client_socket = socket(AF_INET, SOCK_STREAM, 0);\n    // connect(client_socket, \"127.0.0.1\", 8080);\n    std::cout << \"Connected to server!\" << std::endl;\n\n    // send(client_socket, \"Hello Server!\", 13);\n    // char buffer[1024];\n    // recv(client_socket, buffer, sizeof(buffer));\n\n    // close(client_socket);\n}"
          }
        ]
      },
      {
        "id": "c24-industry-practices",
        "title": "C++ in the Industry",
        "desc": "Explore real-world C++ applications, optimization, and continuous learning.",
        "notes": "Having covered the language features, it's time to see how C++ is used in the real world and what it takes to be a successful professional. This chapter explores the major industrial domains where C++ excels due to its performance and control. We'll look at its role in **Game Development**, where it powers engines like Unreal Engine; in **Finance**, especially for high-frequency trading (HFT) systems where every nanosecond counts; and in **Embedded Systems**, from cars to medical devices. A key skill for any C++ professional is performance optimization. We will discuss the process of **profiling** to identify performance bottlenecks and explore common optimization techniques. This includes understanding compiler optimizations, writing cache-friendly code (Data-Oriented Design), and leveraging SIMD instructions for parallel data processing. Finally, the C++ language is not static; it's a living language that continues to evolve. We'll cover the importance of staying current with the latest C++ standards (C++20, C++23, etc.). We'll point you to essential resources for continuous learning, such as talks from conferences like CppCon, influential blogs, and definitive references like cppreference.com. This chapter aims to bridge the gap between knowing the language and being an effective, modern C++ software engineer.",
        "code": "",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-application-domains",
            "title": "Application Domains",
            "desc": "Discover the key industries where C++ is the language of choice.",
            "note": "C++'s strength lies in its ability to provide high-level abstractions without sacrificing low-level control, making it the dominant language in performance-critical domains. In **Game Development**, major engines like Unreal Engine use C++ for their core logic, allowing developers to create complex, high-performance games for PC and consoles. In **Financial Technology (FinTech)**, especially High-Frequency Trading (HFT), C++ is used to build ultra-low-latency trading systems where speed is directly tied to profit. **Embedded Systems** are another huge area; C++ is used in automotive systems, aerospace, robotics, IoT devices, and medical equipment, where resource constraints and reliability are paramount. **Systems Programming** is C++'s native habitat. It's used to write operating systems, device drivers, and compilers. High-performance **Scientific Computing**, including physics simulations and data analysis, also relies heavily on C++ for its number-crunching capabilities. Other domains include desktop applications (e.g., Adobe Photoshop, Google Chrome) and the back-end infrastructure for large-scale services. Understanding these domains can help you specialize and tailor your learning path for a specific career.",
            "code": "// Example 1: Conceptual code for a game loop\n#include <iostream>\n\nvoid processInput() { /* ... */ }\nvoid updateGameLogic(double deltaTime) { /* ... */ }\nvoid renderGraphics() { /* ... */ }\n\nint main() {\n    bool isRunning = true;\n    while(isRunning) {\n        processInput();\n        updateGameLogic(0.016); // Update based on time passed\n        renderGraphics();\n        std::cout << \"Game frame executed.\" << std::endl; // Placeholder\n        isRunning = false; // Run once for example\n    }\n    return 0;\n}\n\n// Example 2: Conceptual code for a low-latency trading operation\n#include <iostream>\n\nstruct MarketData { double price; };\nstruct Order { /* ... */ };\n\nOrder analyzeAndCreateOrder(const MarketData& data) {\n    // In HFT, this logic must be extremely fast\n    std::cout << \"Analyzing market data at price: \" << data.price << std::endl;\n    return Order{};\n}\n\nvoid submitOrder(const Order& order) {\n    std::cout << \"Submitting trade order to exchange.\" << std::endl;\n}\n\nint main() {\n    MarketData latest_tick = { 101.5 };\n    Order my_order = analyzeAndCreateOrder(latest_tick);\n    submitOrder(my_order);\n    return 0;\n}"
          },
          {
            "id": "t2-performance-optimization",
            "title": "Performance & Optimization",
            "desc": "Learn about profiling, compiler optimizations, and writing efficient code.",
            "note": "Writing fast code is a central theme in C++. The first rule of optimization is: don't guess. Use a **profiler** (like Valgrind's Callgrind, Gprof, or Visual Studio's Performance Profiler) to measure your code and find the actual bottlenecks. A profiler will tell you which functions are taking the most time to execute. Once you've identified a hot spot, you can apply optimization techniques. Start with the **compiler**. Modern C++ compilers are incredibly smart. Simply enabling optimization flags (like `-O2` or `-O3` in GCC/Clang) can significantly speed up your code by enabling inlining, loop unrolling, and other transformations. Next, focus on your algorithms and data structures. A better algorithm (e.g., changing from O(n^2) to O(n log n)) will beat any micro-optimization. For memory-intensive tasks, write **cache-friendly code**. Process data sequentially in arrays to maximize CPU cache hits. This is the core idea behind **Data-Oriented Design**, a paradigm that focuses on the memory layout of data to improve performance. For computationally intensive loops, you might explore **SIMD (Single Instruction, Multiple Data)** intrinsics or libraries to perform the same operation on multiple pieces of data in parallel with a single CPU instruction. Always measure before and after any optimization to verify that it actually improved performance.",
            "code": "// Example 1: Compiler optimization flags (for terminal)\n\n// Compiling without optimization\n// g++ my_program.cpp -o my_program_slow\n\n// Compiling with a standard level of optimization\n// g++ -O2 my_program.cpp -o my_program_fast\n\n// Compiling with aggressive optimization\n// g++ -O3 my_program.cpp -o my_program_fastest\n\n\n// Example 2: Cache-unfriendly vs. cache-friendly memory access\n#include <vector>\n\nconst int SIZE = 1000;\nint matrix[SIZE][SIZE];\n\n// Cache-unfriendly: Jumps around in memory (column-major traversal)\nvoid process_unfriendly() {\n    for (int j = 0; j < SIZE; ++j) {\n        for (int i = 0; i < SIZE; ++i) {\n            matrix[i][j]++;\n        }\n    }\n}\n\n// Cache-friendly: Accesses memory sequentially (row-major traversal)\nvoid process_friendly() {\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            matrix[i][j]++;\n        }\n    }\n}"
          }
        ]
      }
    ]
  }
]

