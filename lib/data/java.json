[
  {
    "id": "java",
    "title": "Java",
    "desc": "A comprehensive roadmap for learning the Java programming language, from beginner to advanced topics.",
    "description": "This roadmap provides a structured, chapter-by-chapter guide to mastering Java. It begins with the fundamentals of setting up your development environment and understanding basic syntax, then progressively moves through core concepts like Object-Oriented Programming (OOP), data structures with the Collections Framework, and essential skills like exception handling and multithreading. Later chapters delve into modern Java features, database connectivity with JDBC, and building enterprise-grade web applications using the Spring Framework. The final chapter covers crucial tools for testing, building, and deploying robust Java applications, preparing you for real-world development challenges.",
    "category": "Programming",
    "categories": ["Programming", "Enterprise", "Backend"],
    "difficulty": "Advanced",
    "image": "/images/java.jpg",
    "icon": "FaJava",
    "chapters": [
      {
        "id": "c1-introduction",
        "title": "Introduction & Setup",
        "desc": "Set up your Java development environment, understand the core components, and write your first program.",
        "notes": "This foundational chapter is your gateway into the world of Java programming. Before you can write complex applications, you must first establish a solid development environment. We will demystify the key acronyms: JDK, JRE, and JVM. The Java Development Kit (JDK) is your toolbox, containing everything you need to compile, debug, and run Java applications. The Java Runtime Environment (JRE) is a subset of the JDK that provides the libraries and the Java Virtual Machine (JVM) necessary to run applications. The JVM is the magic behind Java's 'write once, run anywhere' philosophy, acting as an abstract computing machine that executes your compiled Java bytecode. We will guide you through installing the correct JDK and setting up a powerful Integrated Development Environment (IDE) like IntelliJ IDEA or Eclipse. An IDE significantly boosts productivity with features like code completion, debugging tools, and project management. You'll also be introduced to build automation tools like Maven and Gradle, which are essential for managing project dependencies and the build lifecycle in any non-trivial project. By the end of this chapter, you will have successfully compiled and run your first 'Hello, World!' application, marking a significant first step in your journey.",
        "duration": "1 week",
        "topics": [
          {
            "id": "t1-history",
            "title": "History of Java",
            "desc": "Understand the origin, motivation, and evolution of the Java programming language.",
            "note": "The story of Java begins in 1991 at Sun Microsystems with a project codenamed 'Green,' led by James Gosling, Mike Sheridan, and Patrick Naughton. The initial goal was to create a new language for smart consumer electronic devices, like set-top boxes. The language, originally named 'Oak' after an oak tree outside Gosling's office, needed to be simple, robust, and, most importantly, platform-independent. This platform independence was crucial because consumer electronics used a wide variety of processor chips. The team achieved this by compiling the source code into an intermediate format called bytecode, which could then be executed by a virtual machine on any target device. This core concept became Java's famous motto: 'Write Once, Run Anywhere' (WORA). As the internet boom of the mid-1990s began, the team realized that the platform-independent, secure, and robust nature of their language was a perfect fit for web development. In 1995, the language was officially renamed 'Java,' and Sun Microsystems released the first public version, Java 1.0. Its integration with the Netscape Navigator web browser through 'Java applets' quickly made it a popular choice for creating interactive web pages. Since then, Java has evolved significantly, expanding far beyond applets into enterprise-level server-side applications, big data processing, Android mobile development, and scientific computing, solidifying its position as one of the most powerful and widely used programming languages in the world.",
            "code": "// Example 1\npublic class History {\n  public static void main(String[] args) {\n    String creator = \"James Gosling\";\n    int releaseYear = 1995;\n    System.out.println(\"Java was created by \" + creator);\n    System.out.println(\"First public release was in \" + releaseYear);\n  }\n}\n\n// Example 2\nclass Philosophy {\n  public static void main(String[] args) {\n    // The core principle of Java\n    String motto = \"Write Once, Run Anywhere\";\n    System.out.println(\"Java's Motto: \" + motto);\n  }\n}"
          },
          {
            "id": "t2-jvm-jdk-jre",
            "title": "JVM, JDK, JRE Explained",
            "desc": "Differentiate between the Java Virtual Machine, Java Development Kit, and Java Runtime Environment.",
            "note": "Understanding the distinction between JVM, JRE, and JDK is fundamental for any Java developer. Let's break them down. The JVM, or Java Virtual Machine, is the cornerstone of Java's platform independence. It's an abstract machine that provides a runtime environment in which Java bytecode can be executed. It interprets the compiled bytecode and translates it into native machine code for the underlying operating system. Each operating system (Windows, macOS, Linux) has a different JVM implementation, but all of them understand the same Java bytecode. Next is the JRE, or Java Runtime Environment. The JRE is the on-disk implementation of the JVM. It includes the JVM itself, plus the essential Java class libraries and other supporting files needed to *run* a Java application. If you are a user who only wants to run a Java program, you only need to install the JRE. Finally, we have the JDK, or Java Development Kit. The JDK is the complete software development kit for Java programmers. It contains everything the JRE has, plus the development tools necessary to *create* Java applications. The most important of these tools is the compiler (`javac`), which takes your `.java` source code files and compiles them into `.class` files containing bytecode. The JDK also includes a debugger, archiver, and other utilities. In short, the relationship is hierarchical: the JDK contains the JRE, and the JRE contains the JVM. As a developer, you will always install the JDK.",
            "code": "// Example 1\npublic class Components {\n  public static void main(String[] args) {\n    System.out.println(\"JRE (Java Runtime Environment) is for running Java applications.\");\n    System.out.println(\"It contains the JVM and core libraries.\");\n  }\n}\n\n// Example 2\nclass DeveloperKit {\n  public static void main(String[] args) {\n    // As a developer, you need the JDK.\n    String jdkContents = \"JRE + Development Tools (like javac compiler)\";\n    System.out.println(\"JDK stands for Java Development Kit.\");\n    System.out.println(\"JDK = \" + jdkContents);\n  }\n}"
          },
          {
            "id": "t3-ide-setup",
            "title": "IDE Setup",
            "desc": "Install and configure an Integrated Development Environment (IDE) for Java development.",
            "note": "An Integrated Development Environment, or IDE, is an essential tool that significantly enhances a programmer's productivity. While you can write Java code in a simple text editor and compile it from the command line, an IDE provides a comprehensive suite of tools in a single application. For Java development, the most popular IDEs are IntelliJ IDEA, Eclipse, and Visual Studio Code with Java extensions. These IDEs offer intelligent code completion, which suggests variable names, methods, and classes as you type, reducing typos and the need to memorize APIs. They also provide real-time syntax checking, immediately highlighting errors in your code before you even compile it. One of the most powerful features of an IDE is its integrated debugger. A debugger allows you to pause your program's execution at specific points (called breakpoints), inspect the values of variables, and step through your code line by line. This is an invaluable tool for finding and fixing bugs. Furthermore, IDEs help manage your project's structure, handle complex build processes, and integrate with version control systems like Git. We will walk through the installation of IntelliJ IDEA Community Edition, a free and powerful IDE. The process involves downloading the installer, following the setup wizard, and configuring the project to use the JDK you installed earlier. Once set up, you will create your first Java project directly within the IDE, making the development workflow smooth and efficient.",
            "code": "// Example 1\n// This code would be written inside your IDE's editor.\npublic class MyFirstIdeProject {\n  public static void main(String[] args) {\n    // The IDE helps you with syntax highlighting and auto-completion.\n    String message = \"Hello from IntelliJ IDEA!\";\n    System.out.println(message);\n  }\n}\n\n// Example 2\nclass IdeBenefits {\n  public static void main(String[] args) {\n    System.out.println(\"An IDE provides:\");\n    System.out.println(\"- Code Completion\");\n    System.out.println(\"- Debugging Tools\");\n    System.out.println(\"- Project Management\");\n  }\n}"
          },
          {
            "id": "t4-hello-world",
            "title": "Hello, World!",
            "desc": "Write, compile, and run your first basic Java program.",
            "note": "The 'Hello, World!' program is a long-standing tradition in computer programming. It serves as a simple first step to ensure that your development environment is set up correctly and to introduce the basic syntax of a new language. In Java, every application must contain a `main` method, which is the entry point for the JVM to start execution. This method must have a specific signature: `public static void main(String[] args)`. Let's break this down: `public` is an access modifier, meaning the method is visible to all other classes. `static` means the method belongs to the class itself, not to a specific instance of the class, allowing the JVM to call it without creating an object. `void` indicates that the method does not return any value. `main` is the name of the method. `(String[] args)` declares a parameter named `args`, which is an array of `String` objects that can be used to pass command-line arguments to the program. Inside the `main` method, we use the statement `System.out.println(\"Hello, World!\");`. `System` is a built-in Java class, `out` is a static member of the `System` class that represents the standard output stream (usually the console), and `println` is a method of the `out` object that prints the given text followed by a new line. To run this program, you first save the code in a file named `HelloWorld.java`. Then, you compile it using the Java compiler: `javac HelloWorld.java`. This creates a `HelloWorld.class` file containing the bytecode. Finally, you run the program using the Java interpreter: `java HelloWorld`.",
            "code": "// Example 1\n// The classic first program for any language.\npublic class HelloWorld {\n  public static void main(String[] args) {\n    System.out.println(\"Hello, World!\");\n  }\n}\n\n// Example 2\n// A slightly different version, printing two lines.\npublic class HelloAgain {\n  public static void main(String[] args) {\n    System.out.println(\"This is my first Java program.\");\n    System.out.println(\"It's exciting!\");\n  }\n}"
          },
          {
            "id": "t5-maven-gradle",
            "title": "Maven/Gradle Introduction",
            "desc": "Learn the basics of build automation and dependency management tools.",
            "note": "As projects grow larger, manually managing compilation, testing, packaging, and external libraries becomes incredibly tedious and error-prone. This is where build automation tools like Maven and Gradle come in. These tools automate the entire lifecycle of a software project, from compiling the source code to packaging it into a distributable format like a JAR or WAR file. At their core, they manage project dependencies. Modern applications rarely exist in isolation; they rely on numerous third-party libraries for functionality like logging, database access, or web frameworks. Instead of manually downloading these library files (JARs) and adding them to your project, you simply declare the dependencies in a configuration file. Maven uses an XML file named `pom.xml` (Project Object Model), while Gradle uses a more concise, Groovy or Kotlin-based script named `build.gradle`. The build tool then automatically downloads the specified libraries and their transitive dependencies from central repositories and makes them available to your project. This ensures consistency and reproducibility across different developer machines and build environments. They also enforce a standard project directory structure, making it easier for developers to navigate any project that follows the convention. For instance, source code is typically placed in `src/main/java` and test code in `src/test/java`. Mastering a build tool is a non-negotiable skill for any professional Java developer.",
            "code": "// Example 1\n// A snippet from a Maven pom.xml (this is not Java code)\n/*\n<dependencies>\n  <dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n  </dependency>\n</dependencies>\n*/\npublic class MavenIntro {\n  public static void main(String[] args) {\n    System.out.println(\"Maven uses pom.xml to manage dependencies.\");\n  }\n}\n\n// Example 2\n// A snippet from a Gradle build.gradle (this is not Java code)\n/*\ndependencies {\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'\n}\n*/\npublic class GradleIntro {\n  public static void main(String[] args) {\n    System.out.println(\"Gradle uses build.gradle scripts for configuration.\");\n  }\n}"
          }
        ]
      },
      {
        "id": "c2-syntax",
        "title": "Syntax & Data Types",
        "desc": "Learn the fundamental syntax, variables, operators, and control flow structures of Java.",
        "notes": "This chapter covers the essential building blocks of the Java language. We begin with variables, which are containers for storing data values. In Java, you must declare the type of a variable before you can use it. We'll explore the eight primitive data types: `byte`, `short`, `int`, `long` for integer numbers; `float` and `double` for floating-point numbers; `char` for single characters; and `boolean` for true/false values. Understanding these primitives and their memory footprints is crucial for writing efficient code. Next, we dive into operators, the symbols that perform operations on variables and values. You will learn about arithmetic operators (`+`, `-`, `*`, `/`, `%`), assignment operators (`=`, `+=`), comparison operators (`==`, `!=`, `>`, `<`), and logical operators (`&&`, `||`, `!`). A solid grasp of operator precedence is vital for correctly evaluating complex expressions. With variables and operators in hand, we will introduce control flow statements, which allow you to control the execution path of your program. You'll master `if-else` statements for conditional logic, `switch` statements for multi-way branching, and looping constructs like `for`, `while`, and `do-while` loops for executing a block of code repeatedly. We will also cover how to get input from the user via the console using the `Scanner` class, making your programs interactive. This chapter lays the grammatical foundation upon which all your future Java programs will be built.",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-primitive-types",
            "title": "Primitive Data Types",
            "desc": "Explore the eight fundamental data types for storing simple values.",
            "note": "In Java, data types are divided into two main categories: primitive and reference types. This topic focuses on the eight primitive types, which are the most basic data types available in the language. They are not objects and store the actual binary value for the data they represent directly in memory. This makes them highly efficient. The integer types are used for whole numbers. They include `byte` (8-bit), `short` (16-bit), `int` (32-bit), and `long` (64-bit). The choice of which to use depends on the range of values you need to store; using a smaller type like `byte` when possible can save memory. The floating-point types are used for numbers with a fractional part. They are `float` (32-bit, single-precision) and `double` (64-bit, double-precision). `double` is the default and generally preferred choice for its higher precision unless memory is a significant concern. The `char` type (16-bit) is used to store a single Unicode character, such as 'A' or '$'. Finally, the `boolean` type represents a logical value and can only be `true` or `false`. It is the foundation of all conditional logic in Java. Understanding the size and range of each primitive type is crucial for writing memory-efficient and correct code, as choosing the wrong type can lead to data overflow or loss of precision. These eight types form the bedrock for all data manipulation in Java.",
            "code": "// Example 1\npublic class PrimitiveTypes {\n  public static void main(String[] args) {\n    int age = 30;\n    double salary = 65000.50;\n    char initial = 'J';\n    boolean isEmployed = true;\n    System.out.println(\"Age: \" + age);\n    System.out.println(\"Salary: \" + salary);\n    System.out.println(\"Initial: \" + initial);\n    System.out.println(\"Is Employed? \" + isEmployed);\n  }\n}\n\n// Example 2\nclass TypeRanges {\n  public static void main(String[] args) {\n    // Each integer type has a specific range.\n    System.out.println(\"Byte Min: \" + Byte.MIN_VALUE);\n    System.out.println(\"Byte Max: \" + Byte.MAX_VALUE);\n    System.out.println(\"Int Min: \" + Integer.MIN_VALUE);\n    System.out.println(\"Int Max: \" + Integer.MAX_VALUE);\n  }\n}"
          },
          {
            "id": "t2-operators",
            "title": "Operators",
            "desc": "Learn about arithmetic, relational, logical, and assignment operators.",
            "note": "Operators are special symbols that perform specific operations on one, two, or three operands and then return a result. Java provides a rich set of operators. Arithmetic operators are used for mathematical calculations: addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and modulus (`%`), which gives the remainder of a division. Relational operators are used to compare two values, and they always result in a `boolean` value (`true` or `false`). These include equal to (`==`), not equal to (`!=`), greater than (`>`), less than (`<`), greater than or equal to (`>=`), and less than or equal to (`<=`). They are the core of decision-making in programs. Logical operators, logical AND (`&&`) and logical OR (`||`), are used to combine multiple boolean expressions. The AND operator returns `true` only if both operands are true, while the OR operator returns `true` if at least one operand is true. The logical NOT (`!`) operator inverts a boolean value. Assignment operators are used to assign values to variables. The basic assignment operator is `=`, but Java also provides compound assignment operators like `+=`, `-=`, `*=`, and `/=`, which combine an arithmetic operation with an assignment. For instance, `x += 5` is shorthand for `x = x + 5`. Finally, there are increment (`++`) and decrement (`--`) operators, which increase or decrease a variable's value by one. Understanding how these operators work and their precedence is essential for writing correct and concise Java code.",
            "code": "// Example 1\npublic class ArithmeticOperators {\n  public static void main(String[] args) {\n    int a = 10;\n    int b = 3;\n    System.out.println(\"a + b = \" + (a + b));\n    System.out.println(\"a - b = \" + (a - b));\n    System.out.println(\"a * b = \" + (a * b));\n    System.out.println(\"a / b = \" + (a / b)); // Integer division\n    System.out.println(\"a % b = \" + (a % b)); // Modulus\n  }\n}\n\n// Example 2\nclass LogicalOperators {\n  public static void main(String[] args) {\n    int age = 25;\n    boolean hasLicense = true;\n    // Check if the person is an adult and has a license\n    if (age >= 18 && hasLicense) {\n      System.out.println(\"You are eligible to drive.\");\n    } else {\n      System.out.println(\"You are not eligible to drive.\");\n    }\n  }\n}"
          },
          {
            "id": "t3-control-flow",
            "title": "Control Flow",
            "desc": "Master conditional statements (if, else, switch) and loops (for, while).",
            "note": "Control flow statements are fundamental constructs that allow a programmer to alter the default sequential execution of code. They enable programs to make decisions and perform repetitive tasks. The primary decision-making statement is the `if-else` construct. An `if` statement executes a block of code only if a specified boolean condition is `true`. It can be paired with an `else` statement, which executes a block of code if the condition is `false`. For situations with multiple conditions, you can use `else if`. Another conditional statement is the `switch` statement, which provides a clean way to test a variable for equality against a list of values, often being more readable than a long chain of `if-else if` statements. Looping constructs are used to execute a block of code repeatedly. The `for` loop is ideal when you know in advance how many times you want to iterate. It consists of an initialization, a condition, and an update expression. The `while` loop repeatedly executes a block of code as long as a given boolean condition remains `true`. It is useful when the number of iterations is not known beforehand. A variation is the `do-while` loop, which is similar to the `while` loop but guarantees that the loop body will be executed at least once, as the condition is checked *after* the first iteration. Mastering these control flow mechanisms is essential for creating dynamic and responsive applications that can react to different inputs and situations.",
            "code": "// Example 1\npublic class IfElseExample {\n  public static void main(String[] args) {\n    int score = 85;\n    if (score >= 90) {\n      System.out.println(\"Grade: A\");\n    } else if (score >= 80) {\n      System.out.println(\"Grade: B\");\n    } else {\n      System.out.println(\"Grade: C or below\");\n    }\n  }\n}\n\n// Example 2\nclass ForLoopExample {\n  public static void main(String[] args) {\n    // Print numbers from 1 to 5\n    for (int i = 1; i <= 5; i++) {\n      System.out.println(\"Count is: \" + i);\n    }\n  }\n}"
          },
          {
            "id": "t4-input",
            "title": "User Input",
            "desc": "Learn how to read input from the user using the Scanner class.",
            "note": "Making programs interactive is a key part of software development, and the simplest way to do this in a console application is by accepting user input. In Java, the primary tool for this is the `Scanner` class, which is part of the `java.util` package. To use it, you first need to import it into your program with `import java.util.Scanner;`. Then, you create an instance of the `Scanner` class, typically attached to the standard input stream, `System.in`. The line `Scanner scanner = new Scanner(System.in);` creates a new scanner object that 'scans' input from the keyboard. Once the `Scanner` object is created, it provides several useful methods to read different types of data. The `nextLine()` method reads a full line of text as a `String`. The `nextInt()` method reads the next token of input as an `int`. Similarly, there are methods like `nextDouble()`, `nextBoolean()`, and so on for other primitive types. It's important to be mindful of how these methods interact. For example, after reading a number with `nextInt()`, the newline character entered by the user remains in the input buffer. If you then try to read a string with `nextLine()`, it will immediately consume that leftover newline character and return an empty string. A common practice to avoid this is to add an extra `scanner.nextLine();` call after reading a number to consume the rest of the line. Properly handling user input is crucial for creating robust and user-friendly console applications.",
            "code": "// Example 1\nimport java.util.Scanner;\n\npublic class ReadString {\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    System.out.print(\"Enter your name: \");\n    String name = input.nextLine();\n    System.out.println(\"Hello, \" + name + \"!\");\n    input.close();\n  }\n}\n\n// Example 2\nimport java.util.Scanner;\n\npublic class ReadNumber {\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    System.out.print(\"Enter your age: \");\n    int age = input.nextInt();\n    System.out.println(\"You will be \" + (age + 10) + \" in 10 years.\");\n    input.close();\n  }\n}"
          }
        ]
      },
      {
        "id": "c3-classes-objects",
        "title": "Classes, Objects & Methods",
        "desc": "Understand the core principles of object-oriented programming: classes, objects, constructors, and methods.",
        "notes": "This chapter introduces the fundamental concepts of Object-Oriented Programming (OOP), a paradigm that structures a software application as a collection of interacting objects. In Java, the blueprint for an object is a `class`. A class is a template that defines the properties (or attributes, stored in fields) and behaviors (or actions, implemented in methods) that objects of its type will have. For example, a `Car` class might have properties like `color` and `speed`, and behaviors like `startEngine()` and `accelerate()`. An `object` is a specific instance of a class. If `Car` is the blueprint, then a specific red Ferrari is an object, or instance, of the `Car` class. We will cover how to create objects using the `new` keyword and a `constructor`. A constructor is a special method that is called when an object is created, used to initialize the object's state. You will learn about the `this` keyword, which is a reference to the current object. We will also explore `static` members (fields and methods), which belong to the class itself rather than to any individual object. Method `overloading` is another key concept, allowing you to define multiple methods with the same name but different parameters within the same class. Finally, we'll discuss `encapsulation`, the practice of bundling data and methods together within a class and controlling access to them, and `packages`, which are used to organize related classes and interfaces into a hierarchical namespace.",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-classes-objects",
            "title": "Classes and Objects",
            "desc": "Define classes as blueprints and create objects as instances of those classes.",
            "note": "The concepts of classes and objects are the absolute cornerstones of object-oriented programming in Java. A class can be thought of as a blueprint, a template, or a set of instructions for creating objects. It defines a new data type. For example, you could define a `Dog` class. This blueprint would specify the common attributes (or state) that all dogs have, such as `name`, `breed`, and `age`. These attributes are represented by instance variables (fields) within the class. The blueprint also defines the common behaviors (or actions) that all dogs can perform, such as `bark()`, `eat()`, and `sleep()`. These behaviors are represented by methods within the class. However, the class itself is just a template; it doesn't represent a specific dog. An object, on the other hand, is a concrete instance of a class. Using our `Dog` blueprint, we could create multiple dog objects: one named 'Buddy' of breed 'Golden Retriever', and another named 'Lucy' of breed 'Poodle'. Each object has its own set of values for the instance variables defined in the class (Buddy and Lucy have different names and breeds) but shares the same methods. You create an object in Java using the `new` keyword, which allocates memory for the new object and returns a reference to it. This separation of the blueprint (class) from the actual entity (object) is a powerful abstraction that allows for creating organized, reusable, and maintainable code.",
            "code": "// Example 1\nclass Dog {\n  String name;\n  String breed;\n\n  void bark() {\n    System.out.println(name + \" says Woof!\");\n  }\n}\n\npublic class DogDemo {\n  public static void main(String[] args) {\n    Dog myDog = new Dog();\n    myDog.name = \"Buddy\";\n    myDog.breed = \"Golden Retriever\";\n    myDog.bark();\n  }\n}\n\n// Example 2\nclass Car {\n  String model;\n  int year;\n}\n\npublic class CarDemo {\n  public static void main(String[] args) {\n    Car car1 = new Car();\n    car1.model = \"Toyota Camry\";\n    car1.year = 2022;\n\n    Car car2 = new Car();\n    car2.model = \"Honda Civic\";\n    car2.year = 2023;\n\n    System.out.println(\"Car 1: \" + car1.year + \" \" + car1.model);\n    System.out.println(\"Car 2: \" + car2.year + \" \" + car2.model);\n  }\n}"
          },
          {
            "id": "t2-constructors",
            "title": "Constructors and 'this'",
            "desc": "Learn how to initialize objects with constructors and use the 'this' keyword.",
            "note": "A constructor is a special type of method in a class that is invoked when a new object is created. Its primary purpose is to initialize the state of the object, i.e., to set the initial values for its instance variables. A constructor has the same name as the class and does not have a return type, not even `void`. If you do not explicitly define a constructor in your class, Java provides a default, no-argument constructor for you. However, it's very common to define your own constructors to ensure that objects are created in a valid state. You can have multiple constructors in a class, each with a different set of parameters. This is known as constructor overloading. For instance, a `Person` class might have one constructor that only takes a `name` and another that takes both a `name` and an `age`. Within a constructor (or any instance method), the `this` keyword is a reference to the current object—the object whose method or constructor is being called. It is most commonly used to disambiguate between instance variables and parameters when they have the same name. For example, if a constructor parameter is named `name` and the instance variable is also named `name`, you would write `this.name = name;` to assign the value from the parameter to the instance variable. The `this` keyword can also be used to call another constructor from within a constructor, a practice known as constructor chaining (`this(...)`), which helps to reduce code duplication.",
            "code": "// Example 1\nclass Person {\n  String name;\n  int age;\n\n  // Constructor\n  Person(String name, int age) {\n    // 'this' refers to the current object's fields\n    this.name = name;\n    this.age = age;\n  }\n\n  void display() {\n    System.out.println(\"Name: \" + this.name + \", Age: \" + this.age);\n  }\n}\n\npublic class PersonDemo {\n  public static void main(String[] args) {\n    Person p1 = new Person(\"Alice\", 30);\n    p1.display();\n  }\n}\n\n// Example 2\nclass Book {\n  String title;\n  String author;\n\n  // No-argument constructor\n  Book() {\n    this.title = \"Unknown\";\n    this.author = \"Anonymous\";\n  }\n\n  // Parameterized constructor\n  Book(String title, String author) {\n    this.title = title;\n    this.author = author;\n  }\n}\n"
          },
          {
            "id": "t3-static",
            "title": "The 'static' Keyword",
            "desc": "Understand static fields and methods that belong to the class, not an instance.",
            "note": "The `static` keyword in Java is used to create variables and methods that belong to the class itself, rather than to any specific instance (object) of the class. This means there is only one copy of a static member, regardless of how many objects of that class are created. A static field, often called a class variable, is shared among all instances of the class. For example, if you had a `Car` class and wanted to keep track of how many `Car` objects have been created, you could use a `static int carCount;`. Every time a new `Car` is constructed, you would increment this counter, and its value would be the same no matter which `Car` object you accessed it from. Static methods, or class methods, also belong to the class and not to an object. As such, they can be called directly on the class name without needing to create an instance, for example, `Math.random()`. The `main` method is a prime example; the JVM needs to call it to start the program before any objects exist. A key rule for static methods is that they cannot directly access instance variables or instance methods of the class. This is because instance members are associated with a specific object (`this`), and a static context does not have a `this` reference. However, static methods can access other static members of the class. The `static` keyword is essential for defining utility methods, constants, and shared state within a class.",
            "code": "// Example 1\nclass Counter {\n  static int count = 0; // Static variable\n\n  Counter() {\n    count++;\n  }\n}\n\npublic class StaticVariableDemo {\n  public static void main(String[] args) {\n    Counter c1 = new Counter();\n    Counter c2 = new Counter();\n    Counter c3 = new Counter();\n    System.out.println(\"Objects created: \" + Counter.count);\n  }\n}\n\n// Example 2\nclass MathUtil {\n  // Static method\n  public static int add(int a, int b) {\n    return a + b;\n  }\n}\n\npublic class StaticMethodDemo {\n  public static void main(String[] args) {\n    // Call static method without creating an object\n    int sum = MathUtil.add(5, 10);\n    System.out.println(\"Sum is: \" + sum);\n  }\n}"
          },
          {
            "id": "t4-overloading",
            "title": "Method Overloading",
            "desc": "Define multiple methods with the same name but different parameters.",
            "note": "Method overloading is a feature in Java that allows a class to have more than one method with the same name, as long as their parameter lists are different. This allows you to create methods that perform similar operations but on different types or numbers of arguments, improving code readability and reusability. The compiler decides which version of the method to call based on the arguments you provide during the method call. The differentiation between overloaded methods can be based on two rules: either the number of parameters is different, or the data types of the parameters are different. For example, you could have a `Calculator` class with two `add` methods: one that takes two integers (`add(int a, int b)`) and another that takes two doubles (`add(double a, double b)`). When you call `calculator.add(5, 10)`, the compiler knows to invoke the integer version. If you call `calculator.add(3.5, 2.7)`, it invokes the double version. It is important to note that the return type of the method does not play any role in method overloading. You cannot declare two methods with the same name and same parameters but different return types; this will result in a compilation error. Overloading is a form of polymorphism, specifically compile-time polymorphism or static binding, because the decision of which method to call is made at compile time.",
            "code": "// Example 1\nclass Display {\n  public void show(int num) {\n    System.out.println(\"Displaying integer: \" + num);\n  }\n\n  public void show(String text) {\n    System.out.println(\"Displaying string: \" + text);\n  }\n}\n\npublic class OverloadDemo1 {\n  public static void main(String[] args) {\n    Display d = new Display();\n    d.show(100);\n    d.show(\"Hello Java\");\n  }\n}\n\n// Example 2\nclass Adder {\n  // Overloaded add methods\n  public int add(int a, int b) {\n    return a + b;\n  }\n\n  public int add(int a, int b, int c) {\n    return a + b + c;\n  }\n}\n\npublic class OverloadDemo2 {\n  public static void main(String[] args) {\n    Adder adder = new Adder();\n    System.out.println(\"Sum of two: \" + adder.add(10, 20));\n    System.out.println(\"Sum of three: \" + adder.add(10, 20, 30));\n  }\n}"
          }
        ]
      },
      {
        "id": "c4-oop",
        "title": "OOP Concepts",
        "desc": "Dive deeper into the pillars of Object-Oriented Programming: inheritance, polymorphism, abstraction, and encapsulation.",
        "notes": "Building upon the basics of classes and objects, this chapter explores the four fundamental pillars of Object-Oriented Programming (OOP) that enable the creation of complex and maintainable software systems. First is `Inheritance`, the mechanism by which one class (the subclass or child) can acquire the properties and methods of another class (the superclass or parent). This promotes code reuse and establishes a natural hierarchy between classes. We'll explore how to use the `extends` keyword and the concept of `super` to access parent class members. Next is `Polymorphism`, which means 'many forms'. In Java, it allows objects of different classes to be treated as objects of a common superclass. This is primarily achieved through method `overriding`, where a subclass provides a specific implementation for a method that is already defined in its superclass. We then move to `Abstraction`, which involves hiding complex implementation details and showing only the essential features of an object. This is achieved using `abstract classes` and `interfaces`. An abstract class cannot be instantiated and can contain both abstract methods (with no implementation) and concrete methods. An `interface` is a purely abstract template that defines a contract of methods that a class must implement. Finally, we revisit `Encapsulation`, the bundling of data (fields) and the methods that operate on that data into a single unit (a class), and controlling access to that data using access modifiers like `private`, which is a cornerstone of creating robust and secure code.",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-inheritance",
            "title": "Inheritance",
            "desc": "Reuse code and create class hierarchies by allowing a class to inherit fields and methods from another.",
            "note": "Inheritance is one of the core principles of OOP and represents an 'is-a' relationship between classes. It allows a new class, known as the subclass (or child class), to be based on an existing class, the superclass (or parent class). The subclass automatically inherits all the non-private members (fields and methods) of its superclass. This is a powerful mechanism for code reuse. For instance, you could have a `Vehicle` superclass with fields like `speed` and methods like `start()`. You could then create subclasses like `Car` and `Bicycle` that `extend` the `Vehicle` class. Both `Car` and `Bicycle` would automatically have the `speed` field and `start()` method without you having to rewrite them. They can also add their own specific fields and methods (e.g., `Car` could have a `numberOfDoors` field). The `super` keyword is used within a subclass to refer to its immediate superclass. It can be used to call the superclass's constructor (`super()`) or to call a superclass's method (`super.methodName()`), which is particularly useful when you override a method but still want to execute the parent's logic. Java supports single inheritance, meaning a class can only extend one other class. However, it supports multilevel inheritance through chaining (A extends B, B extends C). Inheritance is fundamental to building scalable and logical class structures in object-oriented design.",
            "code": "// Example 1\nclass Animal { // Superclass\n  void eat() {\n    System.out.println(\"This animal eats food.\");\n  }\n}\n\nclass Dog extends Animal { // Subclass\n  void bark() {\n    System.out.println(\"The dog barks.\");\n  }\n}\n\npublic class InheritanceDemo {\n  public static void main(String[] args) {\n    Dog myDog = new Dog();\n    myDog.eat(); // Inherited method\n    myDog.bark();\n  }\n}\n\n// Example 2\nclass Vehicle {\n  int speed = 50;\n}\n\nclass Car extends Vehicle {\n  int speed = 100;\n\n  void display() {\n    System.out.println(\"Car speed: \" + speed);\n    // Use 'super' to access superclass field\n    System.out.println(\"Vehicle speed: \" + super.speed);\n  }\n}\n\npublic class SuperDemo {\n  public static void main(String[] args) {\n    Car myCar = new Car();\n    myCar.display();\n  }\n}"
          },
          {
            "id": "t2-polymorphism",
            "title": "Polymorphism & Overriding",
            "desc": "Understand how objects can take on many forms and how subclasses can provide their own method implementations.",
            "note": "Polymorphism, meaning 'many forms', is a pillar of OOP that allows a single interface to represent different underlying forms (data types). In Java, runtime polymorphism is achieved through method overriding. Method overriding occurs when a subclass provides a specific implementation for a method that is already defined in its superclass. For the override to be valid, the method in the subclass must have the same name, same parameters, and same return type (or a subtype) as the method in the superclass. The power of polymorphism comes from the ability to use a superclass reference variable to refer to a subclass object. For example, if `Dog` and `Cat` are subclasses of `Animal`, you can write `Animal myPet = new Dog();`. When you call a method on `myPet`, like `myPet.makeSound()`, the Java Virtual Machine (JVM) determines at runtime which version of the method to execute based on the actual object type. If `myPet` refers to a `Dog` object, the `makeSound()` method from the `Dog` class is called. If it refers to a `Cat` object, the `Cat`'s version is called. This is also known as dynamic method dispatch or late binding. This allows for writing flexible and extensible code. You can write code that operates on objects of the superclass type, and it will work correctly with any new subclasses that are created later, without needing any modification.",
            "code": "// Example 1\nclass Animal {\n  public void makeSound() {\n    System.out.println(\"Some generic animal sound\");\n  }\n}\n\nclass Pig extends Animal {\n  @Override // Annotation to indicate method override\n  public void makeSound() {\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\npublic class PolymorphismDemo {\n  public static void main(String[] args) {\n    Animal myAnimal = new Animal();\n    Animal myPig = new Pig(); // Superclass reference, subclass object\n\n    myAnimal.makeSound();\n    myPig.makeSound(); // JVM calls the overridden method at runtime\n  }\n}\n\n// Example 2\nclass Shape {\n  void draw() {\n    System.out.println(\"Drawing a shape\");\n  }\n}\n\nclass Circle extends Shape {\n  @Override\n  void draw() {\n    System.out.println(\"Drawing a circle\");\n  }\n}\n\nclass Square extends Shape {\n  @Override\n  void draw() {\n    System.out.println(\"Drawing a square\");\n  }\n}"
          },
          {
            "id": "t3-abstraction",
            "title": "Abstract Classes & Interfaces",
            "desc": "Hide implementation details using abstract classes and define contracts with interfaces.",
            "note": "Abstraction is the OOP principle of hiding the implementation details from the user and only showing the functionality. In Java, this is primarily achieved using abstract classes and interfaces. An `abstract class` is a class that is declared with the `abstract` keyword and cannot be instantiated. It serves as a blueprint for other classes. It can contain both abstract methods (methods without a body) and concrete methods (regular methods with a body). A class that extends an abstract class must provide an implementation for all of its abstract methods, or it must also be declared abstract. This is useful when you want to provide some common, already implemented functionality in a base class but force subclasses to provide their own implementation for certain other methods. An `interface`, on the other hand, is a completely abstract type. It can only contain method signatures (implicitly `public` and `abstract`) and constant declarations (implicitly `public`, `static`, and `final`). A class can `implement` one or more interfaces, thereby agreeing to provide an implementation for all the methods defined in those interfaces. This is how Java achieves a form of multiple inheritance. The key difference is that an abstract class can have state (instance variables) and implemented methods, representing an 'is-a' relationship with some shared implementation, while an interface defines a 'can-do' relationship, a contract of capabilities, without any implementation details.",
            "code": "// Example 1: Abstract Class\nabstract class GraphicObject {\n  abstract void draw(); // Abstract method\n\n  void moveTo(int x, int y) { // Concrete method\n    System.out.println(\"Moving to \" + x + \", \" + y);\n  }\n}\n\nclass Circle extends GraphicObject {\n  void draw() {\n    System.out.println(\"Drawing a circle\");\n  }\n}\n\npublic class AbstractDemo {\n  public static void main(String[] args) {\n    GraphicObject circle = new Circle();\n    circle.draw();\n    circle.moveTo(10, 20);\n  }\n}\n\n// Example 2: Interface\ninterface Drivable {\n  void drive(); // Method signature\n}\n\nclass Car implements Drivable {\n  public void drive() {\n    System.out.println(\"Car is driving\");\n  }\n}\n\npublic class InterfaceDemo {\n  public static void main(String[] args) {\n    Drivable myCar = new Car();\n    myCar.drive();\n  }\n}"
          },
          {
            "id": "t4-enums",
            "title": "Enums",
            "desc": "Use enumerated types for a fixed set of constants.",
            "note": "Enums, short for enumerated types, are a special data type in Java that enables a variable to be a set of predefined constants. Before enums were introduced, the common practice was to use integer constants (e.g., `public static final int MONDAY = 1;`), but this approach is not type-safe. You could pass any integer to a method expecting a day, leading to potential bugs. Enums solve this problem by providing type-safety. You declare an enum using the `enum` keyword. For example, `public enum Day { SUNDAY, MONDAY, TUESDAY, ... }`. Now, if a method expects a `Day`, you can only pass it one of the predefined constants like `Day.MONDAY`, and the compiler will enforce this. Under the hood, Java enums are much more powerful than simple constants; they are a special type of class that implicitly extends the `java.lang.Enum` class. This means enums can have constructors, instance variables, and methods, just like regular classes. For example, you could add a field to your `Day` enum to indicate whether it's a weekday or a weekend and a method to check this. Enums are commonly used for things like days of the week, months of the year, states in a state machine, or any scenario where you have a fixed, known set of values. They improve code readability, reduce errors, and make the code more maintainable.",
            "code": "// Example 1\npublic enum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\n\nclass EnumDemo1 {\n  public static void main(String[] args) {\n    Level myVar = Level.MEDIUM;\n    System.out.println(\"Current level is: \" + myVar);\n  }\n}\n\n// Example 2\npublic enum Day {\n  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n\nclass EnumDemo2 {\n  public static void main(String[] args) {\n    Day today = Day.WEDNESDAY;\n\n    switch (today) {\n      case SATURDAY:\n      case SUNDAY:\n        System.out.println(\"It's the weekend!\");\n        break;\n      default:\n        System.out.println(\"It's a weekday.\");\n        break;\n    }\n  }\n}"
          }
        ]
      },
      {
        "id": "c5-strings-arrays",
        "title": "Strings, Arrays & Utilities",
        "desc": "Work with fundamental data structures like strings and arrays, and use utility classes.",
        "notes": "This chapter focuses on some of the most commonly used data structures and utility classes in Java. We start with the `String` class. In Java, strings are objects, not primitive types, and they are immutable, meaning once a `String` object is created, its value cannot be changed. We will explore various methods for manipulating strings, such as `length()`, `charAt()`, `substring()`, and `equals()`. Because strings are immutable, performing many modifications can be inefficient. For scenarios requiring mutable strings, Java provides `StringBuilder` and `StringBuffer`. `StringBuilder` is a fast, non-thread-safe string builder, while `StringBuffer` is its slower, thread-safe counterpart. Next, we cover `arrays`, which are fixed-size containers that hold a collection of elements of the same data type. You'll learn how to declare, initialize, and iterate over arrays. We'll also look at `varargs` (variable-length arguments), a feature that allows a method to accept zero or more arguments of a specified type. Finally, we'll touch upon useful utility classes provided by the Java API. A prime example is the `Math` class, which contains methods for performing basic numeric operations such as `Math.sqrt()` for square root, `Math.pow()` for exponentiation, and `Math.random()` for generating random numbers. Understanding these fundamental building blocks is essential for nearly any programming task in Java.",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-string",
            "title": "String, StringBuilder, StringBuffer",
            "desc": "Understand immutable strings and learn when to use mutable StringBuilder and StringBuffer.",
            "note": "Handling text is a fundamental part of programming, and in Java, this is primarily done through the `String` class. A crucial characteristic of Java's `String` objects is that they are immutable. This means that once a string object is created, its contents cannot be altered. Any method that appears to modify a string, like `concat()` or `toUpperCase()`, actually creates and returns a new `String` object with the modified content, leaving the original string unchanged. This immutability provides benefits like thread safety and security. However, it can be inefficient if you need to perform many string modifications in a loop, as each modification creates a new object, leading to memory overhead. To address this, Java provides two mutable string classes: `StringBuilder` and `StringBuffer`. Both classes allow you to modify the sequence of characters they contain without creating new objects each time. The main difference between them lies in thread safety. `StringBuffer` is thread-safe, meaning its methods are synchronized, and it can be safely used by multiple threads simultaneously. This synchronization, however, adds a performance overhead. `StringBuilder`, introduced in Java 5, is a non-thread-safe alternative. It provides the same API as `StringBuffer` but is faster because it doesn't have the overhead of synchronization. The general rule is: use `String` for text that won't change, use `StringBuilder` for mutable strings in a single-threaded environment (the most common case), and use `StringBuffer` only when you need a mutable string in a multi-threaded environment.",
            "code": "// Example 1\npublic class StringImmutability {\n  public static void main(String[] args) {\n    String s1 = \"Java\";\n    s1.concat(\" Rules\"); // Creates a new string, does not change s1\n    System.out.println(\"s1 is still: \" + s1);\n\n    String s2 = s1.concat(\" Rules\"); // Assign the new string to s2\n    System.out.println(\"s2 is: \" + s2);\n  }\n}\n\n// Example 2\npublic class StringBuilderDemo {\n  public static void main(String[] args) {\n    // Use StringBuilder for efficient string modifications\n    StringBuilder sb = new StringBuilder(\"Hello\");\n    sb.append(\" \");\n    sb.append(\"World\");\n    sb.append(\"!\");\n    String result = sb.toString();\n    System.out.println(result);\n  }\n}"
          },
          {
            "id": "t2-arrays",
            "title": "Arrays",
            "desc": "Learn to declare, initialize, and manipulate fixed-size arrays.",
            "note": "An array is a fundamental data structure in Java that stores a fixed-size, sequential collection of elements of the same type. Think of it as a container that can hold, for example, 10 integers or 5 strings. The size of an array is established when it is created and cannot be changed afterward. To declare an array, you specify the type of its elements followed by square brackets, for example, `int[] numbers;`. To create the array and allocate memory for it, you use the `new` keyword and specify the size, like `numbers = new int[10];`. This creates an array that can hold 10 integers. The elements in the array are accessed via an index, which is a zero-based integer. This means the first element is at index 0, the second at index 1, and so on, up to the last element at index `length - 1`. You can access or modify an element by using its index, for example, `numbers[0] = 5;`. Java provides a `length` property to get the size of an array. The most common way to process all elements in an array is by using a `for` loop, iterating from index 0 to `array.length - 1`. Java also provides an enhanced `for-each` loop, which offers a more concise syntax for iterating over array elements when you don't need the index. Arrays can be of any data type, including primitive types and object references. You can also have multi-dimensional arrays, which are essentially arrays of arrays, useful for representing grids or matrices.",
            "code": "// Example 1\npublic class ArrayDeclaration {\n  public static void main(String[] args) {\n    // Declare and initialize an array of integers\n    int[] numbers = {10, 20, 30, 40, 50};\n\n    // Access and print the third element (at index 2)\n    System.out.println(\"The third element is: \" + numbers[2]);\n  }\n}\n\n// Example 2\npublic class LoopThroughArray {\n  public static void main(String[] args) {\n    String[] fruits = {\"Apple\", \"Banana\", \"Orange\"};\n\n    // Using an enhanced for-each loop to print all elements\n    System.out.println(\"List of fruits:\");\n    for (String fruit : fruits) {\n      System.out.println(fruit);\n    }\n  }\n}"
          },
          {
            "id": "t3-varargs",
            "title": "Varargs",
            "desc": "Create methods that can accept a variable number of arguments.",
            "note": "Varargs, short for variable-length arguments, is a feature introduced in Java 5 that allows a method to accept zero or more arguments of a specified type. It simplifies the creation of methods that need to process a variable number of inputs. Before varargs, you would typically have to pass an array of elements to the method, which required the calling code to create and populate the array first. With varargs, the syntax is much cleaner. To declare a method with a vararg parameter, you follow the data type of the parameter with an ellipsis (`...`), for example, `public void printNumbers(int... numbers)`. Inside the method, the vararg parameter is treated as an array of the specified type. So, within the `printNumbers` method, `numbers` is an `int[]`. You can then iterate over it using a loop just like any other array to access the individual arguments that were passed. When calling a method with a vararg parameter, you can pass the arguments as a comma-separated list, like `printNumbers(1, 5, 9)` or `printNumbers(10, 20)`, or even with no arguments, `printNumbers()`. The Java compiler automatically takes the comma-separated list of arguments and creates an array to pass to the method. A method can have only one vararg parameter, and it must be the last parameter in the method's signature. Varargs are commonly used in methods like `System.out.printf()` for formatting strings with a variable number of replacement values.",
            "code": "// Example 1\npublic class VarargsSum {\n  // Method with a vararg parameter\n  public static int sum(int... numbers) {\n    int total = 0;\n    for (int num : numbers) {\n      total += num;\n    }\n    return total;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(\"Sum 1: \" + sum(1, 2, 3));\n    System.out.println(\"Sum 2: \" + sum(10, 20, 30, 40, 50));\n    System.out.println(\"Sum 3: \" + sum());\n  }\n}\n\n// Example 2\npublic class DisplayNames {\n  public static void display(String... names) {\n    System.out.println(\"List of names:\");\n    for (String name : names) {\n      System.out.println(\"- \" + name);\n    }\n  }\n\n  public static void main(String[] args) {\n    display(\"Alice\", \"Bob\", \"Charlie\");\n  }\n}"
          },
          {
            "id": "t4-math",
            "title": "Math Class",
            "desc": "Use the static methods in the Math class for common mathematical operations.",
            "note": "The `java.lang.Math` class is a utility class in Java that provides a collection of static methods and constants for performing common mathematical calculations. Since all its members are static, you don't need to create an instance of the `Math` class; you can call its methods directly using the class name, such as `Math.sqrt(25)`. The class includes methods for basic trigonometric functions like `sin()`, `cos()`, and `tan()`, which operate on angles in radians. It also provides exponential and logarithmic functions such as `pow(a, b)` to calculate 'a' raised to the power of 'b', `exp()` for Euler's number 'e' raised to a power, and `log()` for the natural logarithm. For rounding numbers, the `Math` class offers several options: `round()` rounds to the nearest long or int, `ceil()` (ceiling) rounds up to the nearest integer value as a double, and `floor()` rounds down. The `abs()` method returns the absolute value of a number, and `max(a, b)` and `min(a, b)` return the greater or smaller of two values, respectively. A particularly useful method is `random()`, which returns a pseudo-random `double` value greater than or equal to 0.0 and less than 1.0. This can be scaled and cast to generate random numbers within any desired range. The `Math` class also defines two important constants as `double` values: `Math.PI` (the ratio of the circumference of a circle to its diameter) and `Math.E` (the base of the natural logarithms).",
            "code": "// Example 1\npublic class BasicMathOps {\n  public static void main(String[] args) {\n    double number = 64.0;\n    double power = 3.0;\n\n    System.out.println(\"Square root of \" + number + \" is \" + Math.sqrt(number));\n    System.out.println(\"2 to the power of \" + power + \" is \" + Math.pow(2.0, power));\n    System.out.println(\"The absolute value of -10 is \" + Math.abs(-10));\n  }\n}\n\n// Example 2\npublic class RandomNumber {\n  public static void main(String[] args) {\n    // Generate a random integer between 1 and 10 (inclusive)\n    int min = 1;\n    int max = 10;\n    int randomNum = (int)(Math.random() * (max - min + 1)) + min;\n\n    System.out.println(\"A random number between 1 and 10: \" + randomNum);\n  }\n}"
          }
        ]
      },
      {
        "id": "c6-collections",
        "title": "Collections & Generics",
        "desc": "Learn to use the Java Collections Framework for dynamic data structures and write type-safe code with generics.",
        "notes": "While arrays are useful, they are fixed in size. The Java Collections Framework provides a powerful set of interfaces and classes for working with dynamic groups of objects. This chapter introduces the core components of this framework. We will start with the `List` interface, which represents an ordered collection of elements. The most common implementation is `ArrayList`, a resizable-array implementation that is excellent for storing and accessing data. Next, we will cover the `Set` interface, which represents a collection that contains no duplicate elements. `HashSet` is a popular implementation that uses a hash table for storage, offering very fast performance for adding and checking for the existence of elements. We will then explore the `Map` interface, which stores key-value pairs. A `HashMap` allows you to store a value associated with a unique key, enabling fast retrieval of the value if you know the key. You'll also learn how to iterate over collections using the `Iterator` interface and how to define custom sorting logic using the `Comparable` and `Comparator` interfaces. A crucial concept tied to collections is `Generics`. Generics allow you to create classes, interfaces, and methods that operate on types as parameters. This provides compile-time type safety, eliminating the need for casting and reducing the risk of runtime errors. For instance, instead of a raw `ArrayList`, you would declare `ArrayList<String>` to ensure that the list can only ever hold `String` objects.",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-collections-framework",
            "title": "Collections Framework",
            "desc": "Get an overview of the core interfaces: List, Set, and Map.",
            "note": "The Java Collections Framework is a unified architecture for representing and manipulating collections, which are groups of objects. It provides a set of interfaces and classes to help programmers manage data more effectively. At the top of the hierarchy is the `Collection` interface, which defines the basic operations for all collections, such as adding, removing, and querying elements. From `Collection`, two main interfaces are derived: `List` and `Set`. The `List` interface represents an ordered collection, also known as a sequence. Lists allow duplicate elements and provide control over where each element is inserted. Elements can be accessed by their integer index. Common implementations include `ArrayList` (a dynamic array) and `LinkedList` (a doubly-linked list). The `Set` interface represents a collection that cannot contain duplicate elements. It models the mathematical set abstraction. Sets are unordered by default. Common implementations are `HashSet`, which stores elements in a hash table for fast access, and `TreeSet`, which stores elements in a sorted order. Separate from the `Collection` hierarchy is the `Map` interface. A `Map` is an object that maps keys to values, and it cannot contain duplicate keys. Each key can map to at most one value. It's useful for key-value association data, like a dictionary. The primary implementations are `HashMap`, which provides unsorted, fast access, and `TreeMap`, which keeps the keys in sorted order. Understanding these core interfaces is the first step to effectively using Java's powerful data structure library.",
            "code": "// Example 1\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListExample {\n  public static void main(String[] args) {\n    List<String> names = new ArrayList<>();\n    names.add(\"Alice\");\n    names.add(\"Bob\");\n    names.add(\"Charlie\");\n    names.add(\"Alice\"); // Lists allow duplicates\n\n    System.out.println(\"Names: \" + names);\n    System.out.println(\"First name: \" + names.get(0));\n  }\n}\n\n// Example 2\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MapExample {\n  public static void main(String[] args) {\n    Map<String, Integer> studentScores = new HashMap<>();\n    studentScores.put(\"Alice\", 95);\n    studentScores.put(\"Bob\", 88);\n    studentScores.put(\"Charlie\", 92);\n\n    System.out.println(\"Bob's score: \" + studentScores.get(\"Bob\"));\n  }\n}"
          },
          {
            "id": "t2-generics",
            "title": "Generics",
            "desc": "Write type-safe code by creating classes and methods that work with different data types.",
            "note": "Generics, introduced in Java 5, are a powerful feature that brings type-safety to the Java Collections Framework and beyond. Before generics, collections like `ArrayList` stored objects of type `Object`. This meant you could add any type of object to a collection, for example, adding an `Integer` to an `ArrayList` that was intended to hold only `String`s. The compiler wouldn't complain, but you would get a `ClassCastException` at runtime when you tried to retrieve the element and cast it back to a `String`. This lack of compile-time checking was a common source of bugs. Generics solve this problem by allowing you to specify the type of objects that a collection can hold. This is done using angle brackets (`<>`). For instance, `ArrayList<String>` declares an `ArrayList` that is guaranteed by the compiler to contain only `String` objects. If you try to add an `Integer` to this list, you will get a compilation error. This is a huge benefit because it shifts type errors from runtime to compile-time, making them much easier to find and fix. When you retrieve an element from a generic collection, you also don't need to cast it, as the compiler already knows its type. For example, `String name = names.get(0);` works without a cast. While generics are most visibly used with collections, you can also create your own generic classes, interfaces, and methods, enabling you to write flexible and reusable code that is also type-safe.",
            "code": "// Example 1\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GenericList {\n  public static void main(String[] args) {\n    // A generic ArrayList that only accepts Strings\n    List<String> items = new ArrayList<>();\n    items.add(\"Laptop\");\n    items.add(\"Mouse\");\n    // items.add(123); // This would cause a compile-time error\n\n    String firstItem = items.get(0);\n    System.out.println(\"First item is: \" + firstItem.toUpperCase());\n  }\n}\n\n// Example 2\n// A generic class\nclass Box<T> {\n  private T content;\n\n  public void set(T content) {\n    this.content = content;\n  }\n\n  public T get() {\n    return content;\n  }\n}\n\npublic class GenericBoxDemo {\n  public static void main(String[] args) {\n    Box<Integer> integerBox = new Box<>();\n    integerBox.set(10);\n    System.out.println(\"Integer value: \" + integerBox.get());\n  }\n}"
          },
          {
            "id": "t3-comparator-comparable",
            "title": "Comparator & Comparable",
            "desc": "Define natural and custom ordering for objects in collections.",
            "note": "When working with sorted collections like `TreeSet` or when using utility methods like `Collections.sort()` or `Arrays.sort()`, Java needs to know how to compare the objects to determine their order. There are two primary ways to define this comparison logic: the `Comparable` interface and the `Comparator` interface. The `Comparable` interface is used to define the 'natural ordering' of a class. To use it, a class must implement `Comparable` and override its single method, `compareTo(Object obj)`. This method compares the current object (`this`) with the specified object (`obj`) and returns a negative integer, zero, or a positive integer if `this` object is less than, equal to, or greater than the specified object, respectively. For example, the `String` and `Integer` classes both implement `Comparable`, defining their natural alphabetical and numerical orders. The limitation of `Comparable` is that it provides only one way to sort objects, and you must be able to modify the class's source code to implement it. The `Comparator` interface provides a way to define custom or alternative orderings. It is useful when you cannot modify the class's source code or when you need to sort objects in multiple different ways (e.g., sorting a list of `Person` objects by name, then by age). To use it, you create a separate class that implements the `Comparator` interface and overrides its `compare(Object obj1, Object obj2)` method. An instance of this comparator class can then be passed to the sort method. In summary: use `Comparable` for the single, natural ordering of a class, and use `Comparator` for all other sorting requirements.",
            "code": "// Example 1: Comparable\nclass Student implements Comparable<Student> {\n  int id;\n  String name;\n\n  Student(int id, String name) {\n    this.id = id;\n    this.name = name;\n  }\n\n  // Natural ordering by ID\n  @Override\n  public int compareTo(Student other) {\n    return this.id - other.id;\n  }\n\n  @Override\n  public String toString() { return name + \"(\" + id + \")\"; }\n}\n// java.util.Collections.sort() would use compareTo()\n\n// Example 2: Comparator\nimport java.util.Comparator;\n\nclass SortByName implements Comparator<Student> {\n  // Custom ordering by name\n  @Override\n  public int compare(Student s1, Student s2) {\n    return s1.name.compareTo(s2.name);\n  }\n}\n// Collections.sort(studentList, new SortByName());"
          }
        ]
      },
      {
        "id": "c7-exceptions",
        "title": "Exception Handling & Debugging",
        "desc": "Learn to handle errors gracefully using exceptions and debug your applications.",
        "notes": "No matter how well you write your code, errors are inevitable. A robust application must be able to anticipate and handle errors gracefully without crashing. In Java, this is accomplished through exception handling. An exception is an event that disrupts the normal flow of a program's instructions. When an error occurs, an exception object is created and 'thrown'. This chapter teaches you how to 'catch' and handle these exceptions using the `try-catch-finally` block. The `try` block contains the code that might throw an exception. The `catch` block contains the code to handle the exception if it occurs. The optional `finally` block contains code that will always execute, regardless of whether an exception was thrown or caught, making it ideal for cleanup tasks like closing files or database connections. We will differentiate between checked exceptions (which the compiler forces you to handle) and unchecked exceptions (runtime errors that are often programming mistakes). You will also learn how to use the `throw` keyword to manually throw an exception and the `throws` keyword to declare that a method might throw certain exceptions. We will cover creating your own custom exception classes to represent specific errors in your application's domain. Finally, we'll discuss the importance of `logging`. Instead of just printing error messages to the console, using a logging framework like Log4j or SLF4j allows for configurable, flexible, and persistent logging of application events, which is crucial for debugging and monitoring applications in production.",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-try-catch-finally",
            "title": "try-catch-finally",
            "desc": "Handle exceptions using try-catch blocks and perform cleanup with finally.",
            "note": "The `try-catch-finally` construct is the cornerstone of exception handling in Java. It provides a structured way to manage errors and prevent program crashes. The `try` block is where you place the code that you anticipate might throw an exception. This could be anything from reading a file that might not exist to performing a division that could result in dividing by zero. If an exception occurs within the `try` block, the normal execution flow is immediately halted, and the Java Virtual Machine (JVM) looks for a corresponding `catch` block. The `catch` block is where you handle the exception. Each `catch` block is designed to handle a specific type of exception. For example, `catch (FileNotFoundException e)` will only execute if a `FileNotFoundException` is thrown. Inside the `catch` block, you can log the error, inform the user, or attempt to recover from the error. You can have multiple `catch` blocks to handle different types of exceptions. The `finally` block is optional, but it's very powerful. The code inside a `finally` block is guaranteed to be executed, regardless of what happens in the `try` block. It executes whether an exception is thrown or not, and even if a `return` statement is encountered in the `try` or `catch` blocks. This makes it the perfect place for cleanup code, such as closing file streams, database connections, or network sockets, ensuring that critical resources are always released.",
            "code": "// Example 1\npublic class DivideByZero {\n  public static void main(String[] args) {\n    try {\n      int result = 10 / 0;\n      System.out.println(\"Result: \" + result);\n    } catch (ArithmeticException e) {\n      System.out.println(\"Error: Cannot divide by zero.\");\n      // e.printStackTrace(); // Useful for debugging\n    }\n    System.out.println(\"Program continues after handling exception.\");\n  }\n}\n\n// Example 2\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FinallyExample {\n  public static void main(String[] args) {\n    FileReader reader = null;\n    try {\n      reader = new FileReader(\"file.txt\");\n      // ... code to read from the file ...\n    } catch (IOException e) {\n      System.out.println(\"Error reading file: \" + e.getMessage());\n    } finally {\n      System.out.println(\"Finally block executed.\");\n      if (reader != null) {\n        try {\n          reader.close();\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n    }\n  }\n}"
          },
          {
            "id": "t2-throw-throws",
            "title": "throw and throws",
            "desc": "Learn to manually throw exceptions and declare exceptions that a method might throw.",
            "note": "While `try-catch` is used to handle exceptions, the `throw` and `throws` keywords are used to generate and propagate them. The `throw` keyword is used to manually throw a specific exception from your code. You can throw any instance of a class that extends `Throwable`. This is useful when you encounter an error condition in your own logic that the standard Java libraries wouldn't know about. For example, if a method receives an invalid argument (e.g., a negative age), you can `throw new IllegalArgumentException(\"Age cannot be negative\");`. This creates a new exception object and throws it, immediately stopping the current method's execution and passing the exception up the call stack. The `throws` keyword, on the other hand, is used in a method's signature. It declares the types of checked exceptions that the method might throw but does not handle itself. This acts as a warning to any other method that calls it. The calling method is then responsible for either handling the declared exception with a `try-catch` block or propagating it further up the call stack by declaring it with its own `throws` clause. This mechanism enforces a 'catch or declare' policy for checked exceptions, ensuring that they are consciously dealt with by the programmer. For example, a method that reads from a file might be declared as `public void readFile() throws IOException;`, signaling that callers must handle potential I/O errors.",
            "code": "// Example 1\npublic class ValidateAge {\n  public static void checkAge(int age) {\n    if (age < 18) {\n      // Manually throw an exception\n      throw new ArithmeticException(\"Access denied - You must be at least 18 years old.\");\n    } else {\n      System.out.println(\"Access granted - You are old enough!\");\n    }\n  }\n\n  public static void main(String[] args) {\n    try {\n      checkAge(15);\n    } catch (ArithmeticException e) {\n      System.out.println(\"Caught exception: \" + e.getMessage());\n    }\n  }\n}\n\n// Example 2\nimport java.io.IOException;\n\nclass FileProcessor {\n  // Declare that this method can throw an IOException\n  public void readFile(String fileName) throws IOException {\n    System.out.println(\"Trying to read \" + fileName);\n    if (fileName.equals(\"bad.txt\")) {\n      throw new IOException(\"File is corrupt\");\n    }\n    System.out.println(\"File read successfully\");\n  }\n}\n\npublic class ThrowsDemo {\n  public static void main(String[] args) {\n    FileProcessor processor = new FileProcessor();\n    try {\n      // The caller must handle the declared exception\n      processor.readFile(\"bad.txt\");\n    } catch (IOException e) {\n      System.out.println(\"Error: \" + e.getMessage());\n    }\n  }\n}"
          },
          {
            "id": "t3-custom-exceptions",
            "title": "Custom Exceptions",
            "desc": "Create your own exception classes to represent application-specific errors.",
            "note": "While Java provides a wide range of built-in exception classes, sometimes you need to represent an error condition that is specific to your application's domain. In such cases, you can create your own custom exception classes. This makes your code more readable and your error handling more specific. To create a custom exception, you simply define a new class that extends one of the existing exception classes in the `java.lang` package. As a general rule, if you are creating a checked exception (one that the caller should be forced to handle), your class should extend `Exception`. If you are creating an unchecked exception (representing a programming error), your class should extend `RuntimeException`. It's good practice to provide at least two constructors for your custom exception class: a default constructor with no arguments, and a constructor that accepts a `String` message. This message can then be passed up to the superclass's constructor using `super(message)`, allowing the error message to be stored and later retrieved using the `getMessage()` method. For example, in a banking application, you could create a custom `InsufficientFundsException`. When a withdrawal method detects that the balance is too low, it can `throw new InsufficientFundsException(\"Not enough funds to complete transaction.\");`. The calling code can then have a specific `catch (InsufficientFundsException e)` block to handle this precise error scenario gracefully, perhaps by displaying a user-friendly message.",
            "code": "// Example 1\n// Custom checked exception\nclass InvalidInputException extends Exception {\n  public InvalidInputException(String message) {\n    super(message);\n  }\n}\n\npublic class CustomExceptionDemo {\n  public static void processInput(String input) throws InvalidInputException {\n    if (input == null || input.isEmpty()) {\n      throw new InvalidInputException(\"Input cannot be empty.\");\n    }\n    System.out.println(\"Input processed: \" + input);\n  }\n\n  public static void main(String[] args) {\n    try {\n      processInput(\"\");\n    } catch (InvalidInputException e) {\n      System.out.println(\"Error: \" + e.getMessage());\n    }\n  }\n}\n\n// Example 2\n// Custom unchecked exception\nclass AccountNotFoundException extends RuntimeException {\n  public AccountNotFoundException(String message) {\n    super(message);\n  }\n}\n\npublic class BankService {\n  public void getAccount(String id) {\n    if (!id.equals(\"123\")) {\n      throw new AccountNotFoundException(\"Account with ID \" + id + \" not found.\");\n    }\n    System.out.println(\"Found account 123.\");\n  }\n}"
          },
          {
            "id": "t4-logging",
            "title": "Logging",
            "desc": "Use logging frameworks to record application events for debugging and monitoring.",
            "note": "While `System.out.println()` is useful for quick debugging during development, it is a poor choice for logging in a real application. It offers no control over the output, cannot be easily disabled, and mixes application output with diagnostic information. A far better approach is to use a dedicated logging framework. Logging is the practice of recording application events, errors, and other important information to a persistent medium, such as a file or a database. This information is invaluable for debugging problems, monitoring the application's health, and auditing its activity. Java has several popular logging frameworks, such as Log4j, Logback, and the built-in `java.util.logging` package. A common practice is to use a logging facade like SLF4J (Simple Logging Facade for Java), which provides a common API that can be used with different underlying logging implementations. This decouples your application code from any specific logging framework. Logging frameworks introduce the concept of log levels, such as `TRACE`, `DEBUG`, `INFO`, `WARN`, and `ERROR`. You can configure the application to only record messages at or above a certain severity level. For example, in a production environment, you might only log `INFO` and higher, while in a development environment, you might enable `DEBUG` to get more detailed information. This configuration can be changed without modifying the application code, making logging a powerful and flexible tool for any serious Java developer.",
            "code": "// Example 1\n// This is a conceptual example. A real setup requires a logging library and configuration.\n// import org.slf4j.Logger;\n// import org.slf4j.LoggerFactory;\n\npublic class BasicLogging {\n  // private static final Logger logger = LoggerFactory.getLogger(BasicLogging.class);\n\n  public static void main(String[] args) {\n    // logger.info(\"Program has started.\");\n    // try {\n    //   int result = 10 / 0;\n    // } catch (Exception e) {\n    //   logger.error(\"An error occurred while dividing\", e);\n    // }\n    // logger.info(\"Program has finished.\");\n    System.out.println(\"This is a placeholder for a real logging example.\");\n  }\n}\n\n// Example 2\n// Using the built-in java.util.logging\nimport java.util.logging.Logger;\nimport java.util.logging.Level;\n\npublic class JulExample {\n  private static final Logger LOGGER = Logger.getLogger(JulExample.class.getName());\n\n  public static void main(String[] args) {\n    LOGGER.log(Level.INFO, \"This is an info message.\");\n    LOGGER.log(Level.WARNING, \"This is a warning message.\");\n    try {\n      throw new RuntimeException(\"A sample error\");\n    } catch (RuntimeException e) {\n      LOGGER.log(Level.SEVERE, \"An exception occurred\", e);\n    }\n  }\n}"
          }
        ]
      },
      {
        "id": "c8-io",
        "title": "File I/O & NIO.2",
        "desc": "Read from and write to files using classic I/O streams and the modern NIO.2 API.",
        "notes": "Interacting with the file system is a common requirement for many applications. This chapter covers the two main approaches to file input/output (I/O) in Java. We'll start with the classic `java.io` package, which is based on streams. An `InputStream` is used for reading byte-based data, and an `OutputStream` is for writing byte-based data. For character-based data, you use `Reader` and `Writer` classes. We'll explore how to combine these streams, for example, by wrapping a `FileInputStream` in a `BufferedReader` for efficient, line-by-line reading of a text file. We'll also cover `serialization`, the process of converting an object's state into a byte stream to be stored in a file or transmitted over a network, and deserialization, which is the reverse process. Then, we will move on to the modern approach, NIO.2 (New I/O), which was introduced in Java 7 and is part of the `java.nio` package. NIO.2 offers a more powerful and flexible API for file system operations. The central classes are `Path` and `Files`. A `Path` is an object that represents the location of a file or directory, and the `Files` utility class provides a rich set of static methods for operating on paths, such as creating, deleting, copying, and moving files and directories. NIO.2 methods are often more efficient and provide better error handling than their classic I/O counterparts. We'll also look at reading and writing `Properties` files, a common way to store application configuration settings.",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-streams-readers-writers",
            "title": "Streams, Readers/Writers",
            "desc": "Work with byte streams (InputStream, OutputStream) and character streams (Reader, Writer).",
            "note": "Java's classic I/O model, found in the `java.io` package, is built upon the concept of streams. A stream is a sequence of data flowing from a source to a destination. There are two main hierarchies of streams: byte streams and character streams. Byte streams are used for reading and writing binary data (sequences of 8-bit bytes). The two main abstract classes for byte streams are `InputStream` and `OutputStream`. Concrete implementations include `FileInputStream` and `FileOutputStream` for working with files, which handle raw byte data perfect for images, executables, or any non-textual data. Character streams are used for reading and writing character data (sequences of 16-bit Unicode characters). The main abstract classes are `Reader` and `Writer`. These automatically handle the conversion between bytes and characters based on a specified character encoding. This makes them ideal for working with text files. Concrete implementations include `FileReader` and `FileWriter`. A common and powerful technique is to wrap or 'decorate' streams to add more functionality. For example, you can wrap a `FileInputStream` in an `InputStreamReader` to convert it from a byte stream to a character stream, and then wrap that in a `BufferedReader`. The `BufferedReader` reads text from the character stream, buffering the characters to provide for the efficient reading of characters, arrays, and lines, using its `readLine()` method. This layering approach is a key design pattern in the `java.io` library.",
            "code": "// Example 1\nimport java.io.FileReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\n\npublic class ReadTextFile {\n  public static void main(String[] args) {\n    try (BufferedReader reader = new BufferedReader(new FileReader(\"example.txt\"))) {\n      String line;\n      while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n// Example 2\nimport java.io.FileWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\n\npublic class WriteTextFile {\n  public static void main(String[] args) {\n    try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"output.txt\"))) {\n      writer.write(\"Hello, this is a test.\");\n      writer.newLine();\n      writer.write(\"Writing to a file in Java.\");\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}"
          },
          {
            "id": "t2-nio2",
            "title": "Path and Files",
            "desc": "Use the modern NIO.2 API for more robust and efficient file system operations.",
            "note": "NIO.2 (New I/O), introduced in Java 7, provides a modern and comprehensive API for file system interaction, largely superseding the older `java.io.File` class. The core of NIO.2 revolves around two main entry points: the `Path` interface and the `Files` utility class. A `Path` object represents a path to a file or directory in the file system. Unlike the `File` class, a `Path` is just a representation and doesn't necessarily mean the file or directory actually exists. Paths are created using the `Paths.get()` factory method, for example, `Path p = Paths.get(\"C:/data/myfile.txt\");`. The `Files` class is a utility class that contains a rich set of static methods that operate on `Path` objects. These methods cover a wide range of common file operations. For example, you can check if a file exists with `Files.exists(p)`, create a directory with `Files.createDirectory(p)`, copy a file with `Files.copy(sourcePath, targetPath)`, and delete a file with `Files.delete(p)`. The `Files` class also provides highly efficient methods for reading and writing files. For small files, you can read all bytes or lines into memory with a single method call, such as `Files.readAllLines(p)`. For larger files, it provides stream-based access that is compatible with the classic I/O streams. The NIO.2 API generally provides better performance, more functionality (like access to file metadata), and throws more specific, helpful exceptions compared to the legacy `File` class, making it the recommended choice for modern Java applications.",
            "code": "// Example 1\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.List;\n\npublic class NioRead {\n  public static void main(String[] args) {\n    Path path = Paths.get(\"example.txt\");\n    try {\n      List<String> lines = Files.readAllLines(path);\n      for (String line : lines) {\n        System.out.println(line);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n// Example 2\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.io.IOException;\n\npublic class NioCopy {\n  public static void main(String[] args) {\n    Path source = Paths.get(\"original.txt\");\n    Path destination = Paths.get(\"copy.txt\");\n    try {\n      // Create a dummy source file first\n      Files.write(source, \"This is the original file.\".getBytes());\n      Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);\n      System.out.println(\"File copied successfully!\");\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}"
          },
          {
            "id": "t3-serialization",
            "title": "Serialization",
            "desc": "Convert objects into a byte stream to be stored or transmitted.",
            "note": "Serialization is the process of converting the state of a Java object into a byte stream. This byte stream can then be saved to a file on disk, stored in a database, or transmitted across a network. The reverse process, called deserialization, rebuilds the object from the byte stream. This mechanism allows you to persist objects beyond the lifetime of a single program execution. For a class to be serializable, it must implement the `java.io.Serializable` interface. This is a marker interface, meaning it has no methods to implement; its presence simply signals to the JVM that objects of this class are allowed to be serialized. The actual serialization and deserialization are typically done using `ObjectOutputStream` and `ObjectInputStream`. You wrap a file stream (like `FileOutputStream`) with an `ObjectOutputStream` and then call its `writeObject()` method to serialize an object. To deserialize, you wrap a `FileInputStream` with an `ObjectInputStream` and call its `readObject()` method, which returns an `Object` that you must cast back to its original type. It's important to note that not all fields of an object are serialized. Fields marked with the `transient` keyword are ignored during the serialization process and will be `null` or have their default value after deserialization. Static fields are also not serialized as they belong to the class, not the object. While built-in serialization is convenient, it can be brittle and has security vulnerabilities, so modern applications often prefer alternative formats like JSON or XML for data persistence and transfer.",
            "code": "// Example 1\nimport java.io.*;\n\nclass User implements Serializable {\n  String name;\n  transient String password; // This field will not be serialized\n}\n\npublic class SerializationDemo {\n  public static void main(String[] args) throws IOException {\n    User user = new User();\n    user.name = \"Alice\";\n    user.password = \"secret123\";\n    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"user.ser\"))) {\n      oos.writeObject(user);\n      System.out.println(\"User object serialized.\");\n    }\n  }\n}\n\n// Example 2\n// import java.io.*; // Assuming imports from Example 1\n\npublic class DeserializationDemo {\n  public static void main(String[] args) throws IOException, ClassNotFoundException {\n    User user = null;\n    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"user.ser\"))) {\n      user = (User) ois.readObject();\n    }\n    System.out.println(\"User object deserialized.\");\n    System.out.println(\"Name: \" + user.name);\n    System.out.println(\"Password: \" + user.password); // Will be null\n  }\n}"
          }
        ]
      },
      {
        "id": "c9-multithreading",
        "title": "Multithreading & Concurrency",
        "desc": "Write programs that can perform multiple tasks simultaneously.",
        "notes": "Modern computer processors have multiple cores, enabling them to execute several tasks at the same time. Multithreading is the feature that allows a Java program to take advantage of this by running multiple threads of execution concurrently within a single process. Each thread has its own path of execution but shares resources like memory with other threads in the same process. This chapter introduces the fundamentals of creating and managing threads. There are two primary ways to create a thread: by extending the `Thread` class or by implementing the `Runnable` interface. Implementing `Runnable` is generally preferred as it allows your class to extend another class. When multiple threads access shared data, problems like race conditions and data inconsistency can arise. To prevent this, we will cover `synchronization`. The `synchronized` keyword can be applied to methods or blocks of code to ensure that only one thread can execute that code at a time, creating a 'mutex' or mutual exclusion lock. While `synchronized` is a powerful tool, low-level thread management can be complex and error-prone. To simplify this, Java provides the high-level Concurrency API in the `java.util.concurrent` package. We will explore the `ExecutorService`, a framework for managing a pool of worker threads, which is a much more efficient and scalable way to handle concurrent tasks than creating new threads manually. We will also touch upon advanced locking mechanisms provided by the `java.util.concurrent.locks` package.",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-thread-runnable",
            "title": "Thread and Runnable",
            "desc": "Create and run threads by extending the Thread class or implementing the Runnable interface.",
            "note": "In Java, there are two primary ways to define a task that can be executed by a thread. The first method is to create a class that extends the `java.lang.Thread` class. This class must override the `run()` method, which contains the code that will be executed in the new thread. To start the execution, you create an instance of your custom thread class and call its `start()` method. The `start()` method is crucial; it allocates system resources for the new thread, schedules it to be run by the JVM, and calls the `run()` method in the new thread of execution. Calling `run()` directly would simply execute the code in the current thread, not a new one. The second, and generally preferred, method is to create a class that implements the `java.lang.Runnable` interface. The `Runnable` interface has a single method, `run()`. You place your task's logic inside this method. To execute this `Runnable`, you create an instance of it, then create a new `Thread` object, passing your `Runnable` instance to the `Thread`'s constructor. Finally, you call the `start()` method on the `Thread` object. The reason implementing `Runnable` is often better is that Java does not support multiple inheritance of classes. If your class already needs to extend another class, it cannot also extend `Thread`. By implementing `Runnable`, your class is free to extend any other class while still being executable by a thread. This approach promotes better object-oriented design by separating the task (the `Runnable`) from the execution mechanism (the `Thread`).",
            "code": "// Example 1: Extending Thread\nclass MyThread extends Thread {\n  public void run() {\n    System.out.println(\"This thread is running by extending Thread.\");\n  }\n}\n\npublic class ThreadExtendDemo {\n  public static void main(String[] args) {\n    MyThread t1 = new MyThread();\n    t1.start();\n  }\n}\n\n// Example 2: Implementing Runnable\nclass MyRunnable implements Runnable {\n  public void run() {\n    System.out.println(\"This thread is running by implementing Runnable.\");\n  }\n}\n\npublic class RunnableImplementDemo {\n  public static void main(String[] args) {\n    MyRunnable myTask = new MyRunnable();\n    Thread t2 = new Thread(myTask);\n    t2.start();\n  }\n}"
          },
          {
            "id": "t2-synchronization",
            "title": "Synchronization",
            "desc": "Prevent race conditions and ensure thread safety when accessing shared data.",
            "note": "When multiple threads have access to shared, mutable state (like a common object or variable), you can run into concurrency problems. A race condition occurs when the outcome of a computation depends on the unpredictable timing or interleaving of operations from multiple threads. For example, if two threads try to increment a shared counter simultaneously, one of the increments might be lost. To prevent such issues and ensure data consistency, Java provides the `synchronized` keyword. Synchronization works by establishing locks on objects. When a thread enters a `synchronized` method or block, it acquires the intrinsic lock for that object (or the class object for static methods). While the thread holds the lock, no other thread can enter any `synchronized` block or method for the same object. Other threads attempting to acquire the lock will be blocked until the first thread exits the `synchronized` code and releases the lock. You can apply the `synchronized` keyword to an entire method, which locks on the `this` object for instance methods. Alternatively, you can use a `synchronized` block to lock on a specific object and protect only a critical section of code, which can be more efficient as it reduces the scope of the lock. While `synchronized` is a powerful tool for achieving thread safety, it's important to use it judiciously, as overuse can lead to performance bottlenecks and potential deadlocks, a situation where two or more threads are blocked forever, waiting for each other to release locks.",
            "code": "// Example 1\nclass SharedCounter {\n  private int count = 0;\n\n  // This method is synchronized to prevent race conditions\n  public synchronized void increment() {\n    count++;\n  }\n\n  public int getCount() {\n    return count;\n  }\n}\n\n// A full demo would require creating and running multiple threads\n// that call increment() and showing the final correct count.\npublic class SyncMethodDemo {\n    public static void main(String[] args) {\n        System.out.println(\"The synchronized keyword protects shared data.\");\n    }\n}\n\n// Example 2\npublic class SyncBlockDemo {\n  private final Object lock = new Object();\n\n  public void doSomething() {\n    // some non-critical code here\n\n    synchronized (lock) {\n      // critical section of code that needs protection\n      System.out.println(\"This part is thread-safe.\");\n    }\n\n    // more non-critical code here\n  }\n}"
          },
          {
            "id": "t3-executorservice",
            "title": "ExecutorService",
            "desc": "Use high-level thread pools to manage and execute tasks efficiently.",
            "note": "Manually creating and managing threads (`new Thread(...)`) can be inefficient. Creating a new thread is a relatively expensive operation, and having too many active threads can degrade performance due to the overhead of context switching. A more robust and efficient approach is to use a thread pool. A thread pool is a managed collection of reusable worker threads. The `ExecutorService` framework, part of the `java.util.concurrent` package, is Java's high-level API for managing thread pools. Instead of creating a thread for each task, you submit your tasks (as `Runnable` or `Callable` objects) to an `ExecutorService`. The service then assigns the task to one of the available threads in its pool. If all threads are busy, the task is placed in a queue to wait for a thread to become free. This model decouples task submission from task execution and handles all the low-level details of thread management for you. You can create different types of thread pools using factory methods in the `Executors` class. For example, `Executors.newFixedThreadPool(10)` creates a pool with a fixed number of 10 threads. `Executors.newCachedThreadPool()` creates a pool that can grow and shrink dynamically based on demand. Using an `ExecutorService` not only improves performance by reusing threads but also provides better control over resource consumption and makes your concurrency code cleaner and more manageable. It is the modern, recommended way to handle concurrent tasks in Java.",
            "code": "// Example 1\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class FixedThreadPoolDemo {\n  public static void main(String[] args) {\n    // Create a pool of 2 threads\n    ExecutorService executor = Executors.newFixedThreadPool(2);\n\n    // Submit tasks for execution\n    for (int i = 0; i < 5; i++) {\n      int taskNum = i;\n      executor.submit(() -> {\n        System.out.println(\"Executing task \" + taskNum + \" by \" + Thread.currentThread().getName());\n      });\n    }\n\n    executor.shutdown(); // Initiates a graceful shutdown\n  }\n}\n\n// Example 2\nimport java.util.concurrent.*;\n\npublic class CallableExample {\n  public static void main(String[] args) throws ExecutionException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n\n    // Callable can return a value\n    Callable<Integer> task = () -> {\n      TimeUnit.SECONDS.sleep(2);\n      return 123;\n    };\n\n    Future<Integer> future = executor.submit(task);\n    System.out.println(\"Task submitted...\");\n\n    Integer result = future.get(); // Blocks until the result is available\n    System.out.println(\"Result from task: \" + result);\n\n    executor.shutdown();\n  }\n}"
          }
        ]
      },
      {
        "id": "c10-java8",
        "title": "Java 8+ Features",
        "desc": "Master modern Java features including lambdas, streams, functional interfaces, and the new Date/Time API.",
        "notes": "Java 8 marked one of the most significant updates to the language, introducing features that revolutionized how Java code is written. This chapter focuses on these modern paradigms. The most prominent feature is `lambda expressions`, which provide a concise syntax for representing anonymous functions. Lambdas enable a more functional style of programming, making code more readable and expressive, especially when working with collections. Closely related to lambdas are `functional interfaces`, which are interfaces with a single abstract method. They serve as the target type for lambda expressions. The introduction of lambdas paved the way for the `Streams API`, a powerful new way to process sequences of elements. The Streams API allows you to perform complex data processing operations like filtering, mapping, and reducing on collections in a declarative, chainable manner. This often results in cleaner and more efficient code compared to traditional loops. Another major improvement was the introduction of the `Optional` class. `Optional` is a container object that may or may not contain a non-null value. It provides a type-safe way to handle nullable values, helping to avoid dreaded `NullPointerException`s by encouraging developers to explicitly handle the case where a value might be absent. Finally, Java 8 introduced a completely new `Date and Time API` (`java.time` package). This API, based on the Joda-Time library, fixes the many design flaws of the old `java.util.Date` and `java.util.Calendar` classes, providing an immutable, fluent, and much more intuitive API for handling dates, times, and time zones.",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-lambdas",
            "title": "Lambdas & Functional Interfaces",
            "desc": "Use lambda expressions for concise anonymous functions and understand their relationship with functional interfaces.",
            "note": "Lambda expressions, a cornerstone of Java 8, provide a clear and concise way to represent a single-method interface (a functional interface) using an expression. They allow you to treat functionality as a method argument, or code as data. A lambda expression can be thought of as an anonymous function. The basic syntax is `(parameters) -> { body; }`. For example, a lambda that takes two integers and returns their sum can be written as `(int a, int b) -> a + b;`. This is significantly more compact than creating an anonymous inner class. Lambdas are intrinsically linked to `functional interfaces`. A functional interface is any interface that contains exactly one abstract method. Examples from the JDK include `Runnable`, `Callable`, and `Comparator`. Java 8 also introduced a new package, `java.util.function`, which contains a set of common functional interfaces like `Predicate<T>` (takes a T, returns a boolean), `Function<T, R>` (takes a T, returns an R), and `Consumer<T>` (takes a T, returns nothing). A lambda expression can be assigned to a variable whose type is a functional interface, as long as the lambda's signature matches the signature of the interface's abstract method. This combination enables the functional programming paradigm in Java, allowing you to pass behaviors as arguments to methods, making your code more flexible and expressive, especially when used with the Streams API.",
            "code": "// Example 1\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class LambdaForEach {\n  public static void main(String[] args) {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n    // Using a lambda expression with forEach\n    names.forEach(name -> System.out.println(\"Hello, \" + name));\n  }\n}\n\n// Example 2\n// A functional interface has only one abstract method.\n@FunctionalInterface\ninterface MathOperation {\n  int operate(int a, int b);\n}\n\npublic class FunctionalInterfaceDemo {\n  public static void main(String[] args) {\n    // Assigning a lambda to a functional interface variable\n    MathOperation addition = (a, b) -> a + b;\n    MathOperation subtraction = (a, b) -> a - b;\n\n    System.out.println(\"10 + 5 = \" + addition.operate(10, 5));\n    System.out.println(\"10 - 5 = \" + subtraction.operate(10, 5));\n  }\n}"
          },
          {
            "id": "t2-streams",
            "title": "Streams API",
            "desc": "Process collections of data in a declarative, functional style.",
            "note": "The Streams API, introduced in Java 8, provides a powerful and declarative way to process sequences of data. A stream is not a data structure that stores elements; instead, it's a sequence of elements from a source (like a `Collection`, an array, or an I/O channel) that supports aggregate operations. Stream operations are divided into two categories: intermediate and terminal. Intermediate operations, such as `filter()` (selects elements based on a predicate), `map()` (transforms each element), and `sorted()`, return a new stream. This allows you to chain multiple operations together to form a processing pipeline. These operations are lazy, meaning they are not executed until a terminal operation is invoked. Terminal operations, such as `forEach()` (performs an action for each element), `collect()` (gathers the stream elements into a collection), or `reduce()` (combines all elements into a single result), produce a result or a side-effect. Once a terminal operation is executed, the stream is considered consumed and cannot be reused. This functional approach to data processing often leads to more readable and concise code compared to traditional imperative loops. For example, to find all transactions of a certain type, sort them by value, and collect their IDs into a list, you can create a simple, elegant pipeline of stream operations. The Streams API also supports parallel processing. By simply calling `.parallelStream()` instead of `.stream()`, the framework can automatically process the data in parallel on multi-core processors, potentially offering significant performance improvements.",
            "code": "// Example 1\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class StreamFilterMap {\n  public static void main(String[] args) {\n    List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Anna\");\n\n    names.stream()\n      .filter(name -> name.startsWith(\"A\")) // Intermediate operation\n      .map(String::toUpperCase) // Intermediate operation\n      .forEach(System.out::println); // Terminal operation\n  }\n}\n\n// Example 2\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class StreamReduce {\n  public static void main(String[] args) {\n    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n    // Use reduce to find the sum of all numbers\n    int sum = numbers.stream()\n      .reduce(0, (a, b) -> a + b);\n\n    System.out.println(\"The sum is: \" + sum);\n  }\n}"
          },
          {
            "id": "t3-optional",
            "title": "Optional",
            "desc": "Avoid NullPointerExceptions by using the Optional container.",
            "note": "`NullPointerException` is one of the most common and frustrating errors in Java. It occurs when you try to access a member of a null reference. The `Optional<T>` class, introduced in Java 8, is a container object designed to address this problem by explicitly modeling the presence or absence of a value. An `Optional` can be in one of two states: it can be 'present', containing a non-null value of type `T`, or it can be 'empty'. The main goal of `Optional` is to change a method's signature to clearly communicate that it might not return a value. Instead of a method returning `null`, it can return an `Optional`. For example, a method `findUserById(String id)` that might not find a user can be declared to return `Optional<User>`. The calling code is then forced to deal with the possibility of an absent value. `Optional` provides several methods to handle the value. The `isPresent()` method checks if a value is present. `get()` returns the value if present, but throws an exception if it's empty. Safer alternatives include `orElse(defaultValue)`, which returns the contained value if present, or a specified default value otherwise. `ifPresent(consumer)` executes a block of code only if the value is present. Using `Optional` makes your code more robust and readable by making the cases where a value may be missing explicit, pushing the developer to handle them actively rather than relying on (and often forgetting) null checks.",
            "code": "// Example 1\nimport java.util.Optional;\n\npublic class OptionalBasic {\n  public static Optional<String> findName(String id) {\n    if (id.equals(\"123\")) {\n      return Optional.of(\"Alice\");\n    } else {\n      return Optional.empty();\n    }\n  }\n\n  public static void main(String[] args) {\n    Optional<String> nameOpt = findName(\"456\");\n\n    // Safely handle the absence of a value\n    String name = nameOpt.orElse(\"Unknown User\");\n    System.out.println(\"User: \" + name);\n  }\n}\n\n// Example 2\nimport java.util.Optional;\n\npublic class OptionalIfPresent {\n  public static void main(String[] args) {\n    Optional<String> value = Optional.of(\"Hello, Optional!\");\n\n    // The lambda is only executed if the value is present\n    value.ifPresent(v -> System.out.println(\"Found value: \" + v));\n\n    Optional<String> emptyValue = Optional.empty();\n    emptyValue.ifPresent(v -> System.out.println(\"This will not be printed.\"));\n  }\n}"
          },
          {
            "id": "t4-datetime-api",
            "title": "Date/Time API",
            "desc": "Use the modern, immutable java.time package for handling dates and times.",
            "note": "Before Java 8, working with dates and times in Java using `java.util.Date` and `java.util.Calendar` was notoriously difficult and error-prone. These classes had mutable state, were not thread-safe, had poor API design, and used a confusing zero-based month index. The new Date and Time API, located in the `java.time` package, solves all of these problems. The new API is based on the ISO-8601 calendar system and is designed to be immutable and thread-safe. Immutability means that once a date or time object is created, it cannot be changed. Any modification operation, like adding a day, returns a new object, which makes the code much safer, especially in concurrent environments. The core classes of the new API are more intuitive. `LocalDate` represents a date without time (e.g., 2023-10-27). `LocalTime` represents a time without a date (e.g., 15:30:00). `LocalDateTime` combines both date and time but without a time zone. For time zone-aware date and time, you use `ZonedDateTime`. The API provides a rich set of methods for manipulating dates and times, such as `plusDays()`, `minusHours()`, etc., in a fluent and readable style. It also includes classes like `Duration` for measuring time in seconds and nanoseconds, and `Period` for measuring time in years, months, and days. Formatting and parsing dates and times is handled by the `DateTimeFormatter` class, which is also thread-safe. This modern API is a massive improvement and should always be used for any date/time logic in new Java applications.",
            "code": "// Example 1\nimport java.time.LocalDate;\nimport java.time.Month;\n\npublic class LocalDateDemo {\n  public static void main(String[] args) {\n    // Get the current date\n    LocalDate today = LocalDate.now();\n    System.out.println(\"Today's date: \" + today);\n\n    // Create a specific date\n    LocalDate myBirthday = LocalDate.of(2000, Month.JANUARY, 1);\n    System.out.println(\"My birthday is on: \" + myBirthday);\n\n    // Manipulate dates\n    LocalDate nextWeek = today.plusWeeks(1);\n    System.out.println(\"Date next week: \" + nextWeek);\n  }\n}\n\n// Example 2\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class FormattingDateTime {\n  public static void main(String[] args) {\n    LocalDateTime now = LocalDateTime.now();\n\n    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\n    String formattedDateTime = now.format(formatter);\n\n    System.out.println(\"Current date and time: \" + now);\n    System.out.println(\"Formatted date and time: \" + formattedDateTime);\n  }\n}"
          }
        ]
      },
      {
        "id": "c11-networking",
        "title": "Networking & HTTP",
        "desc": "Learn to communicate over networks using sockets and perform HTTP requests.",
        "notes": "This chapter introduces the fundamentals of network programming in Java, enabling your applications to communicate with other services over the internet or a local network. We'll start with the basics provided by the `java.net` package. You'll learn about the `InetAddress` class, which represents an IP address, and the `URL` class for parsing and working with Uniform Resource Locators. We will then dive into low-level socket programming. Sockets provide a two-way communication link between two programs running on the network. You'll learn how to create a `ServerSocket` to build a server application that listens for incoming client connections, and how to use the `Socket` class to build a client application that connects to a server. This forms the basis of most network communication protocols. Building on this, we'll explore how to work with the most common application-layer protocol on the web: HTTP. While you can implement HTTP communication using raw sockets, it's much easier and more robust to use a higher-level API. We will focus on the modern `HttpClient` API, introduced in Java 11. This API provides a clean, fluent, and asynchronous way to send HTTP requests (like GET and POST) and handle their responses. It supports both HTTP/1.1 and HTTP/2 and is the recommended way to interact with web services and REST APIs in modern Java. We'll also briefly touch on the basics of `WebSocket`, a protocol that allows for full-duplex, real-time communication between a client and a server.",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-sockets",
            "title": "Sockets",
            "desc": "Implement low-level client-server communication using TCP sockets.",
            "note": "Socket programming is the foundation of network communication in Java. A socket provides an endpoint for sending or receiving data across a computer network. The `java.net` package contains the necessary classes, primarily `Socket` and `ServerSocket`, for creating TCP-based client-server applications. TCP (Transmission Control Protocol) is a connection-oriented protocol that guarantees reliable, ordered delivery of data. The server side of the communication creates a `ServerSocket` object, specifying a port number to listen on. A port is a numerical identifier that distinguishes different services running on the same machine. The server then calls the `accept()` method on the `ServerSocket`. This is a blocking call, meaning the server's execution will pause and wait until a client tries to connect. The client side creates a `Socket` object, providing the IP address or hostname of the server and the port number it's listening on. This initiates a connection request to the server. Once the server receives the request, the `accept()` method returns a new `Socket` object that is connected to the client. Now, both the client and the server have a `Socket` object, and a two-way communication channel is established. Each socket has an `InputStream` and an `OutputStream`, which can be used to read data from and write data to the other end of the connection, respectively. This low-level control is powerful but requires careful management of the communication protocol and error handling.",
            "code": "// Example 1: A simple server (conceptual)\nimport java.net.*;\nimport java.io.*;\n\npublic class SimpleServer {\n  public static void main(String[] args) throws IOException {\n    // ServerSocket server = new ServerSocket(6666);\n    // System.out.println(\"Server is waiting for a client...\");\n    // Socket clientSocket = server.accept();\n    // System.out.println(\"Client connected!\");\n    // // ... code to read from and write to the clientSocket ...\n    // server.close();\n    System.out.println(\"This is a conceptual server example.\");\n  }\n}\n\n// Example 2: A simple client (conceptual)\n// import java.net.*;\n// import java.io.*;\n\npublic class SimpleClient {\n  public static void main(String[] args) throws IOException {\n    // Socket socket = new Socket(\"localhost\", 6666);\n    // System.out.println(\"Connected to the server.\");\n    // // ... code to communicate with the server ...\n    // socket.close();\n    System.out.println(\"This is a conceptual client example.\");\n  }\n}"
          },
          {
            "id": "t2-httpclient",
            "title": "HttpClient",
            "desc": "Use the modern Java 11 HttpClient to interact with web services and APIs.",
            "note": "Interacting with web services and REST APIs is a cornerstone of modern application development. The standard way to do this is by sending HTTP requests. Java 11 introduced a new, modern `HttpClient` API in the `java.net.http` package, which is designed to be more flexible, easier to use, and more performant than the legacy `HttpURLConnection` class. The new API is built around three main classes: `HttpClient`, `HttpRequest`, and `HttpResponse`. The `HttpClient` is the entry point for sending requests. You typically create one client instance and reuse it for multiple requests. The `HttpRequest` object represents the request you want to send. It is built using a fluent builder pattern, allowing you to easily specify the URI, the HTTP method (GET, POST, etc.), headers, and the request body. `HttpRequest` objects are immutable, making them safe to share. Once the request is built, you use the client's `send()` or `sendAsync()` method to send it. The `send()` method is synchronous and blocks until the response is received. The `sendAsync()` method is asynchronous and returns a `CompletableFuture`, allowing your application to perform other tasks while waiting for the response. The `HttpResponse` object contains the response from the server, including the status code, headers, and the response body. This modern API supports HTTP/1.1, HTTP/2, and WebSockets, making it the definitive choice for any HTTP communication in new Java applications.",
            "code": "// Example 1\n// This code requires Java 11 or later.\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class HttpGetDemo {\n  public static void main(String[] args) throws Exception {\n    HttpClient client = HttpClient.newHttpClient();\n    HttpRequest request = HttpRequest.newBuilder()\n      .uri(URI.create(\"https://jsonplaceholder.typicode.com/posts/1\"))\n      .build();\n\n    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n    System.out.println(\"Status Code: \" + response.statusCode());\n    System.out.println(\"Body: \" + response.body());\n  }\n}\n\n// Example 2\n// A simple POST request\n// import java.net.URI;\n// import java.net.http.*;\n\npublic class HttpPostDemo {\n  public static void main(String[] args) throws Exception {\n    HttpClient client = HttpClient.newHttpClient();\n    String jsonBody = \"{\\\"title\\\": \\\"foo\\\", \\\"body\\\": \\\"bar\\\", \\\"userId\\\": 1}\";\n\n    HttpRequest request = HttpRequest.newBuilder()\n      .uri(URI.create(\"https://jsonplaceholder.typicode.com/posts\"))\n      .header(\"Content-Type\", \"application/json\")\n      .POST(HttpRequest.BodyPublishers.ofString(jsonBody))\n      .build();\n\n    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n    System.out.println(response.body());\n  }\n}"
          }
        ]
      },
      {
        "id": "c12-jdbc",
        "title": "JDBC & Persistence",
        "desc": "Connect to and interact with relational databases using JDBC and get an introduction to ORM with Hibernate.",
        "notes": "Most enterprise applications need to store and retrieve data from a database. This chapter covers how Java applications interact with relational databases. The standard API for this is JDBC (Java Database Connectivity). JDBC provides a set of classes and interfaces in the `java.sql` package that allow for a standardized way to connect to a database, execute SQL queries, and process the results. We will cover the core JDBC workflow: loading the database driver, establishing a connection, creating a `Statement` or `PreparedStatement` object, executing queries (like SELECT, INSERT, UPDATE, DELETE), and processing the results from a `ResultSet`. We will emphasize the use of `PreparedStatement` to prevent SQL injection attacks, a critical security vulnerability. You will learn how to perform CRUD (Create, Read, Update, Delete) operations. We will also discuss how to manage database `transactions` to ensure data integrity, and the importance of `connection pooling` in a real-world application to efficiently manage database connections. While JDBC is powerful, it can be verbose, requiring a lot of boilerplate code. To simplify database interactions, developers often use Object-Relational Mapping (ORM) frameworks. We will provide a brief introduction to `Hibernate`, one of the most popular ORM frameworks in the Java ecosystem. Hibernate maps Java objects to database tables, allowing you to perform database operations using object-oriented syntax instead of writing raw SQL, which can significantly speed up development.",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-jdbc-crud",
            "title": "CRUD with PreparedStatement",
            "desc": "Perform Create, Read, Update, and Delete operations on a database using JDBC.",
            "note": "JDBC (Java Database Connectivity) is the standard Java API for connecting to relational databases and executing SQL commands. Performing CRUD (Create, Read, Update, Delete) operations is the foundation of database interaction. The core workflow involves several steps. First, you need to establish a `Connection` to the database using the `DriverManager` class, providing the database URL, username, and password. Once connected, you create a statement object to execute your SQL query. While `Statement` can be used, it's highly recommended to use `PreparedStatement` for any query that involves user input. A `PreparedStatement` is a pre-compiled SQL statement. You use placeholders (`?`) in your SQL query for the parameters. Then, you bind the actual values to these placeholders using setter methods like `setString()` or `setInt()`. This approach is not only more efficient for queries that are executed multiple times but, more importantly, it automatically handles the escaping of special characters, which prevents SQL injection attacks. For `Create` (INSERT), `Update` (UPDATE), and `Delete` (DELETE) operations, you use the `executeUpdate()` method, which returns the number of rows affected. For `Read` (SELECT) operations, you use the `executeQuery()` method, which returns a `ResultSet` object. The `ResultSet` is a table of data representing the query results, which you can iterate through row by row to retrieve the data from each column.",
            "code": "// Example 1: Conceptual SELECT with PreparedStatement\n// Requires a database and JDBC driver to be set up.\n// import java.sql.*;\npublic class JdbcSelect {\n  public static void main(String[] args) {\n    // String url = \"jdbc:mysql://localhost:3306/mydb\";\n    // String user = \"user\";\n    // String password = \"pass\";\n    // String sql = \"SELECT name, email FROM users WHERE id = ?\";\n    // try (Connection conn = DriverManager.getConnection(url, user, password);\n    //      PreparedStatement pstmt = conn.prepareStatement(sql)) {\n    //   pstmt.setInt(1, 101);\n    //   ResultSet rs = pstmt.executeQuery();\n    //   while(rs.next()) { System.out.println(rs.getString(\"name\")); }\n    // }\n    System.out.println(\"Conceptual JDBC SELECT example.\");\n  }\n}\n\n// Example 2: Conceptual INSERT with PreparedStatement\n// import java.sql.*;\npublic class JdbcInsert {\n  public static void main(String[] args) {\n    // String url = \"jdbc:mysql://localhost:3306/mydb\";\n    // String sql = \"INSERT INTO users(name, email) VALUES(?, ?)\";\n    // try (Connection conn = DriverManager.getConnection(url, \"u\", \"p\");\n    //      PreparedStatement pstmt = conn.prepareStatement(sql)) {\n    //   pstmt.setString(1, \"New User\");\n    //   pstmt.setString(2, \"new.user@example.com\");\n    //   int rows = pstmt.executeUpdate();\n    // }\n    System.out.println(\"Conceptual JDBC INSERT example.\");\n  }\n}"
          },
          {
            "id": "t2-transactions",
            "title": "Transactions",
            "desc": "Ensure data integrity by grouping multiple SQL statements into a single atomic transaction.",
            "note": "A database transaction is a sequence of operations performed as a single logical unit of work. The key property of a transaction is that it is atomic, meaning either all of the operations within it are successfully completed, or none of them are. If any operation fails, the entire transaction is 'rolled back', and the database is returned to the state it was in before the transaction began. This is crucial for maintaining data integrity. A classic example is transferring money between two bank accounts. This involves two separate UPDATE operations: debiting one account and crediting another. If the debit succeeds but the credit fails (e.g., due to a system crash), you would have lost money. By wrapping both operations in a transaction, you guarantee that both must succeed for the changes to be made permanent. In JDBC, transaction control is managed through the `Connection` object. By default, JDBC connections are in auto-commit mode, meaning each individual SQL statement is treated as its own transaction and is automatically committed upon execution. To manage transactions manually, you must first disable auto-commit by calling `conn.setAutoCommit(false);`. After this, you can execute a series of SQL statements. If all statements execute without error, you make the changes permanent by calling `conn.commit();`. If an error occurs at any point, you can revert all changes made since the transaction began by calling `conn.rollback();` in a `catch` block.",
            "code": "// Example 1\n// Conceptual transaction management in JDBC\n// import java.sql.*;\npublic class TransactionDemo {\n  public static void main(String[] args) {\n    // Connection conn = null;\n    // try {\n    //   conn.setAutoCommit(false);\n    //   // ... execute multiple SQL statements (UPDATE 1, UPDATE 2) ...\n    //   conn.commit();\n    //   System.out.println(\"Transaction successful!\");\n    // } catch (SQLException e) {\n    //   if (conn != null) conn.rollback();\n    //   System.out.println(\"Transaction failed and was rolled back.\");\n    // } finally {\n    //   if (conn != null) conn.close();\n    // }\n    System.out.println(\"Conceptual JDBC Transaction example.\");\n  }\n}\n\n// Example 2\npublic class TransactionPseudoCode {\n  public void transferMoney(int fromAcct, int toAcct, double amount) {\n    // 1. Start Transaction\n    // 2. WITHDRAW from fromAcct\n    // 3. If withdraw fails, ROLLBACK and exit\n    // 4. DEPOSIT into toAcct\n    // 5. If deposit fails, ROLLBACK and exit\n    // 6. If both succeed, COMMIT\n    System.out.println(\"Transactions ensure atomicity.\");\n  }\n}"
          },
          {
            "id": "t3-hibernate-basics",
            "title": "Hibernate Basics",
            "desc": "Get an introduction to Object-Relational Mapping (ORM) with Hibernate.",
            "note": "Object-Relational Mapping (ORM) is a programming technique that bridges the gap between the object-oriented world of your application and the relational world of your database. Instead of writing manual JDBC code and SQL queries, an ORM framework like Hibernate allows you to map your Java objects directly to database tables. Each object instance corresponds to a row in the table, and each object field corresponds to a column. Hibernate is a popular, powerful ORM framework that greatly simplifies database persistence in Java applications. To use Hibernate, you first create your Plain Old Java Objects (POJOs), often called entity classes. You then use annotations (like `@Entity`, `@Table`, `@Id`, `@Column`) to tell Hibernate how these classes and their fields map to your database schema. Hibernate takes care of the rest. It provides an API to perform CRUD operations on your objects. When you call a method like `session.save(myObject)`, Hibernate automatically generates and executes the appropriate SQL INSERT statement. When you query for an object, Hibernate generates the SELECT statement, executes it, and populates your POJO with the data from the `ResultSet`. This abstraction allows developers to think in terms of objects rather than database tables and SQL, which can significantly increase productivity and make the data access layer more maintainable. Hibernate also provides many advanced features like caching, lazy loading, and a powerful query language (HQL - Hibernate Query Language), which is an object-oriented version of SQL.",
            "code": "// Example 1\n// Conceptual Hibernate Entity\n// import javax.persistence.*;\n\n// @Entity\n// @Table(name = \"employees\")\npublic class Employee {\n  // @Id\n  // @GeneratedValue(strategy = GenerationType.IDENTITY)\n  private int id;\n\n  // @Column(name = \"first_name\")\n  private String firstName;\n\n  // ... getters and setters\n}\npublic class HibernateEntityDemo {\n    public static void main(String[] args) {\n        System.out.println(\"Hibernate maps objects to database tables.\");\n    }\n}\n\n// Example 2\n// Conceptual Hibernate Usage\n// import org.hibernate.Session;\n// import org.hibernate.SessionFactory;\n\npublic class HibernateUsage {\n  public void saveEmployee() {\n    // SessionFactory sf = ...;\n    // Session session = sf.openSession();\n    // session.beginTransaction();\n    // Employee emp = new Employee();\n    // emp.setFirstName(\"John\");\n    // session.save(emp);\n    // session.getTransaction().commit();\n    // session.close();\n    System.out.println(\"Hibernate simplifies saving objects.\");\n  }\n}"
          }
        ]
      },
      {
        "id": "c13-web-dev",
        "title": "Web Development & Spring",
        "desc": "Build web applications using Servlets, JSP, and the powerful Spring Framework.",
        "notes": "This chapter transitions from core Java to building dynamic, enterprise-level web applications. We begin with the foundational technologies of Java web development: `Servlets` and `JSP` (JavaServer Pages). A Servlet is a Java class that runs on a web server and handles incoming HTTP requests and generates responses. JSP is a technology that helps create dynamic web pages with a more HTML-like syntax, which is often easier for presentation logic. Together, they form the basis for understanding how Java web applications work. We'll introduce the `MVC` (Model-View-Controller) design pattern, a standard architecture for separating application logic, data, and presentation. While Servlets and JSP are powerful, building large applications with them can be complex. This is where the `Spring Framework` comes in. Spring is a comprehensive framework that simplifies enterprise Java development. We'll start with `Spring Core`, which introduces the concepts of Inversion of Control (IoC) and Dependency Injection (DI), fundamental principles for building loosely coupled and testable applications. Then we'll move to `Spring Boot`, a project that makes it incredibly easy to create stand-alone, production-grade Spring-based applications with minimal configuration. You'll learn how to build REST APIs quickly. We will also cover `Spring Data` for simplifying database access and `Spring Security` for adding authentication and authorization to your applications, providing a complete toolkit for modern web development.",
        "duration": "4 weeks",
        "topics": [
          {
            "id": "t1-servlets-jsp-mvc",
            "title": "Servlets, JSP, and MVC",
            "desc": "Learn the fundamentals of Java web applications and the Model-View-Controller pattern.",
            "note": "Servlets and JavaServer Pages (JSP) are the foundational technologies for building web applications in Java. A Servlet is a Java program that runs on a web server (like Apache Tomcat) and extends the capabilities of the server. It intercepts HTTP requests from a web browser, processes them, and generates an HTTP response. Servlets are written entirely in Java, which makes them powerful for handling business logic but cumbersome for generating complex HTML content. JSP, on the other hand, is designed to simplify the creation of the presentation layer (the 'View'). A JSP file looks much like an HTML file but can contain special tags and embedded Java code (called scriptlets) that allow for dynamic content generation. Under the hood, the web server translates a JSP file into a Servlet. The Model-View-Controller (MVC) pattern is a software architectural pattern that separates the application into three interconnected components. The Model represents the application's data and business logic. The View is responsible for rendering the user interface (this is where JSP shines). The Controller (typically a Servlet) acts as the intermediary, receiving user input from the View, processing it (by interacting with the Model), and then selecting the next View to display. This separation of concerns makes the application much more organized, easier to maintain, and testable. Understanding this fundamental pattern is crucial before moving on to modern frameworks like Spring, which are built upon these same principles.",
            "code": "// Example 1\n// Conceptual Servlet Code\n// import javax.servlet.http.*;\n// import java.io.IOException;\n\n// public class HelloServlet extends HttpServlet {\n//   protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n//       throws IOException {\n//     resp.setContentType(\"text/html\");\n//     resp.getWriter().println(\"<h1>Hello from Servlet!</h1>\");\n//   }\n// }\npublic class ServletExample {\n    public static void main(String[] args) {\n        System.out.println(\"Servlets handle HTTP requests on the server.\");\n    }\n}\n\n// Example 2\n// Conceptual JSP Code (this would be in a .jsp file)\n/*\n<html>\n  <body>\n    <h2>Hello from JSP!</h2>\n    <p>The current time is <%= new java.util.Date() %>.</p>\n  </body>\n</html>\n*/\npublic class JspExample {\n    public static void main(String[] args) {\n        System.out.println(\"JSP is used to create dynamic web pages.\");\n    }\n}"
          },
          {
            "id": "t2-spring-boot",
            "title": "Spring Boot",
            "desc": "Rapidly build production-ready, stand-alone web applications with Spring Boot.",
            "note": "While the Spring Framework is incredibly powerful, setting up a new project traditionally required a significant amount of boilerplate configuration in XML files. Spring Boot is an opinionated extension of the Spring platform that radically simplifies this process. Its primary goal is to let developers get a new Spring application up and running as quickly as possible. Spring Boot achieves this through several key features. First, it provides 'starters', which are convenient dependency descriptors. For example, if you want to build a web application, you simply include the `spring-boot-starter-web` dependency, and Spring Boot will automatically bring in all the necessary libraries like Spring MVC and an embedded web server (like Tomcat). Second, Spring Boot features powerful autoconfiguration. It attempts to automatically configure your Spring application based on the JAR dependencies you have added. If it sees the web starter, it will automatically configure beans for a web application. If it sees a database starter, it will try to configure a data source. This 'convention over configuration' approach eliminates most of the manual setup. Third, Spring Boot applications are typically packaged as executable JAR files with an embedded server, which means you can run your entire web application from the command line with `java -jar myapp.jar`, without needing to deploy it to an external web server. This makes development, testing, and deployment significantly simpler.",
            "code": "// Example 1\n// A minimal Spring Boot Application main class\n// import org.springframework.boot.SpringApplication;\n// import org.springframework.boot.autoconfigure.SpringBootApplication;\n\n// @SpringBootApplication\npublic class MyApplication {\n  public static void main(String[] args) {\n    // SpringApplication.run(MyApplication.class, args);\n    System.out.println(\"This is the entry point for a Spring Boot app.\");\n  }\n}\n\n// Example 2\n// A simple REST Controller in Spring Boot\n// import org.springframework.web.bind.annotation.GetMapping;\n// import org.springframework.web.bind.annotation.RestController;\n\n// @RestController\npublic class HelloController {\n  // @GetMapping(\"/\")\n  public String hello() {\n    return \"Greetings from Spring Boot!\";\n  }\n}"
          },
          {
            "id": "t3-spring-data-security",
            "title": "Spring Data & Spring Security",
            "desc": "Simplify database access with Spring Data and secure your application with Spring Security.",
            "note": "Spring Boot starters make it easy to integrate other powerful Spring projects into your application. Two of the most essential are Spring Data and Spring Security. Spring Data's mission is to make it easier to work with data access technologies. The Spring Data JPA module, in particular, dramatically simplifies the creation of a data access layer. You start by defining an interface that extends `JpaRepository<EntityType, IdType>`. By doing this, you automatically get a full set of CRUD (Create, Read, Update, Delete) methods for your entity without writing any implementation code. Spring Data generates the implementation for you at runtime. You can also define custom query methods just by declaring their signature in the interface, for example, `List<User> findByLastName(String lastName);`. Spring Data will parse the method name and create the appropriate database query for you. This removes a massive amount of boilerplate code associated with JDBC or even standard JPA. Spring Security is the de facto standard for securing Spring-based applications. It is a powerful and highly customizable framework that handles authentication (who are you?) and authorization (what are you allowed to do?). It provides comprehensive support for various authentication mechanisms like form-based login, basic authentication, and OAuth2. You can configure it to define access control rules for your web endpoints, for example, specifying that only users with an 'ADMIN' role can access URLs under `/admin/**`. Spring Security integrates deeply with the Spring framework to protect your application from common security threats.",
            "code": "// Example 1\n// Conceptual Spring Data JPA Repository\n// import org.springframework.data.jpa.repository.JpaRepository;\n// import java.util.List;\n\n// public interface UserRepository extends JpaRepository<User, Long> {\n//   // Spring Data automatically implements this method!\n//   List<User> findByStatus(String status);\n// }\npublic class SpringDataExample {\n    public static void main(String[] args) {\n        System.out.println(\"Spring Data JPA simplifies database access.\");\n    }\n}\n\n// Example 2\n// Conceptual Spring Security Configuration\n// import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n// import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n// public class SecurityConfig extends WebSecurityConfigurerAdapter {\n//   @Override\n//   protected void configure(HttpSecurity http) throws Exception {\n//     http.authorizeRequests()\n//       .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n//       .anyRequest().authenticated()\n//       .and()\n//       .formLogin();\n//   }\n// }\npublic class SpringSecurityExample {\n    public static void main(String[] args) {\n        System.out.println(\"Spring Security provides authentication and authorization.\");\n    }\n}"
          }
        ]
      },
      {
        "id": "c14-tools",
        "title": "Tools, Testing & Deployment",
        "desc": "Learn essential tools for building, testing, versioning, and deploying Java applications.",
        "notes": "Writing code is only one part of the software development lifecycle. This final chapter covers the essential ecosystem of tools and practices that professional Java developers use to build, test, and deploy high-quality software. We revisit `Maven` and `Gradle` in more detail, solidifying your understanding of how these tools manage dependencies and automate the build process. We then introduce `Git`, the industry-standard distributed version control system. You'll learn the basic concepts of repositories, commits, branches, and merges, which are fundamental for collaborating with other developers and tracking changes in your codebase. A critical aspect of modern software development is automated testing. We will cover `JUnit`, the most popular framework for writing unit tests in Java, which allows you to test individual components of your application in isolation. We'll also look at `Mockito`, a mocking framework that is often used with JUnit to create mock objects, allowing you to test a class without relying on its real dependencies. We will discuss the principles of `CI/CD` (Continuous Integration/Continuous Deployment), a practice where code changes are automatically built, tested, and deployed. We'll touch upon popular design patterns that provide reusable solutions to common software design problems. Finally, we'll introduce `Docker`, a platform for containerizing applications. Docker allows you to package your application and its dependencies into a standardized unit for software development, which simplifies deployment to any environment, including `Cloud` platforms like AWS, Google Cloud, or Azure.",
        "duration": "3 weeks",
        "topics": [
          {
            "id": "t1-maven-gradle",
            "title": "Maven & Gradle",
            "desc": "Deepen your understanding of build automation and dependency management.",
            "note": "Maven and Gradle are the two dominant build automation tools in the Java ecosystem. They provide a standardized way to build projects, manage dependencies, and run tests. Maven uses a declarative approach with its `pom.xml` file. You define what you want to do (e.g., package the project) and what you need (e.g., dependencies), and Maven's rigid lifecycle handles the how. It follows a strong 'convention over configuration' principle, expecting your project to have a standard directory structure. This makes it easy to understand any Maven project once you know the conventions. Maven's dependency management is powerful; it resolves transitive dependencies and handles version conflicts, downloading required JARs from a central repository like Maven Central. Gradle offers a more flexible and powerful approach. It uses a Domain Specific Language (DSL) based on Groovy or Kotlin in its `build.gradle` files. This makes build scripts more concise and readable than Maven's XML. Gradle's build process is based on a graph of tasks, giving you fine-grained control over the build process. While it also has conventions, it's easier to override them than in Maven. Gradle often boasts better performance due to its incremental build capabilities and build cache, which avoid re-running tasks that haven't changed. While both tools are excellent, Gradle is often favored in modern projects, especially in the Android ecosystem, for its flexibility and performance, whereas Maven remains a very solid and widely used choice in the enterprise world.",
            "code": "// Example 1: Conceptual Maven pom.xml dependency\n/*\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n*/\npublic class MavenExample {\n    public static void main(String[] args) {\n        System.out.println(\"Maven uses an XML-based pom.xml file.\");\n        System.out.println(\"It's declarative and relies on a fixed lifecycle.\");\n    }\n}\n\n// Example 2: Conceptual Gradle build.gradle dependency\n/*\nimplementation 'org.springframework.boot:spring-boot-starter-web'\n*/\npublic class GradleExample {\n    public static void main(String[] args) {\n        System.out.println(\"Gradle uses a Groovy or Kotlin-based script.\");\n        System.out.println(\"It's more flexible and often faster.\");\n    }\n}"
          },
          {
            "id": "t2-git",
            "title": "Git",
            "desc": "Master version control with Git for tracking changes and collaborating on code.",
            "note": "Git is an essential, distributed version control system that is the standard for modern software development. It allows you to track the history of changes to your codebase over time. At its core, Git works with a repository, which is a directory that contains your project files and a hidden `.git` subdirectory where Git stores all the history and metadata. The basic workflow involves making changes to your files and then 'committing' those changes. A commit is a snapshot of your project at a specific point in time. Each commit has a unique ID and a commit message where you describe the changes you made. This creates a detailed history, allowing you to revert to previous versions of your code if something goes wrong. Git's real power comes from its branching capabilities. A branch is an independent line of development. You can create a new branch to work on a new feature or a bug fix without affecting the main line of development (often called the `main` or `master` branch). Once your work on the branch is complete and tested, you can 'merge' it back into the main branch. This branching and merging model is fundamental to collaborative workflows, allowing multiple developers to work on different parts of a project simultaneously without interfering with each other. Platforms like GitHub, GitLab, and Bitbucket provide remote hosting for Git repositories, adding features like pull requests and code reviews to facilitate teamwork.",
            "code": "// Example 1\n// These are Git commands, not Java code. They are run in the terminal.\npublic class GitCommands1 {\n  public static void main(String[] args) {\n    System.out.println(\"// To stage a file for commit:\");\n    System.out.println(\"git add MyFile.java\");\n\n    System.out.println(\"\\n// To commit the staged changes:\");\n    System.out.println(\"git commit -m \\\"Implemented new feature\\\"\");\n  }\n}\n\n// Example 2\npublic class GitCommands2 {\n  public static void main(String[] args) {\n    System.out.println(\"// To create a new branch and switch to it:\");\n    System.out.println(\"git checkout -b new-feature-branch\");\n\n    System.out.println(\"\\n// To switch back to the main branch:\");\n    System.out.println(\"git checkout main\");\n\n    System.out.println(\"\\n// To merge the new branch into main:\");\n    System.out.println(\"git merge new-feature-branch\");\n  }\n}"
          },
          {
            "id": "t3-junit-mockito",
            "title": "JUnit & Mockito",
            "desc": "Write unit tests with JUnit and create mock objects with Mockito.",
            "note": "Automated testing is a critical practice for ensuring software quality and maintainability. Unit testing involves testing the smallest, isolated parts of your application (the 'units', typically individual methods or classes) to verify they behave as expected. JUnit is the most widely used testing framework for Java. It provides a test runner and a rich set of annotations and assertion methods to help you write and organize your tests. You create a separate test class for the class you want to test. Test methods are annotated with `@Test`. Inside a test method, you set up a scenario, call the method you are testing, and then use assertion methods (like `assertEquals()`, `assertTrue()`, `assertNotNull()`) to check if the actual outcome matches the expected outcome. Often, the class you want to test has dependencies on other classes (e.g., a service class that depends on a repository class). To test the service class in isolation, you don't want to use a real repository that connects to a database. This is where mocking comes in. Mockito is a popular mocking framework that allows you to create 'mock' or 'fake' objects that simulate the behavior of real dependencies. You can tell your mock repository what to return when a specific method is called on it. This allows you to test your service class's logic without any external dependencies, making your tests faster, more reliable, and truly focused on the unit under test.",
            "code": "// Example 1: A simple JUnit test\n// Requires JUnit 5 library\n// import static org.junit.jupiter.api.Assertions.assertEquals;\n// import org.junit.jupiter.api.Test;\n\nclass Calculator {\n  public int add(int a, int b) { return a + b; }\n}\n\n// public class CalculatorTest {\n//   @Test\n//   void testAdd() {\n//     Calculator calc = new Calculator();\n//     int result = calc.add(2, 3);\n//     assertEquals(5, result, \"2 + 3 should equal 5\");\n//   }\n// }\npublic class JunitExample {\n    public static void main(String[] args) {\n        System.out.println(\"JUnit is used for unit testing Java code.\");\n    }\n}\n\n// Example 2: Conceptual Mockito usage\n// Requires JUnit and Mockito libraries\n// import static org.mockito.Mockito.*;\n// import java.util.List;\n\n// public class MockitoTest {\n//   @Test\n//   void testList() {\n//     // Create a mock List\n//     List<String> mockedList = mock(List.class);\n\n//     // Stub the get(0) method\n//     when(mockedList.get(0)).thenReturn(\"first\");\n\n//     // Test the mock\n//     assertEquals(\"first\", mockedList.get(0));\n//   }\n// }\npublic class MockitoExample {\n    public static void main(String[] args) {\n        System.out.println(\"Mockito creates mock objects for testing dependencies.\");\n    }\n}"
          },
          {
            "id": "t4-docker-cloud",
            "title": "Docker & Cloud Deployment",
            "desc": "Containerize your Java application with Docker for easy deployment to the cloud.",
            "note": "Deployment is the process of getting your application running in a production environment. Modern deployment practices heavily rely on containerization, and Docker is the leading platform for this. A container is a lightweight, standalone, executable package that includes everything needed to run a piece of software: the code, a runtime (like the JRE), system tools, and libraries. Docker allows you to define the environment for your application in a text file called a `Dockerfile`. The Dockerfile contains instructions to build a Docker image. This image is a blueprint for your containers. For a Java application, the Dockerfile would typically start from a base image that has Java installed, copy your application's JAR file into the image, and specify the command to run the JAR file. The key benefit of this approach is that a Docker container runs the same way regardless of the underlying infrastructure. This solves the classic 'it works on my machine' problem. Once you have a Docker image, you can run it as a container on any machine that has Docker installed, from a developer's laptop to a production server. This consistency makes deployment much simpler and more reliable. Cloud platforms like Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure provide services specifically designed to run and manage Docker containers at scale (e.g., AWS ECS, Google Kubernetes Engine). By containerizing your Java application, you make it portable and ready for modern, cloud-native deployment.",
            "code": "// Example 1: A simple Dockerfile for a Spring Boot app\n/*\n# Use a base image with Java 17 installed\nFROM openjdk:17-jdk-slim\n\n# Set the working directory inside the container\nWORKDIR /app\n\n# Copy the executable JAR file into the container\nCOPY target/my-app-0.0.1-SNAPSHOT.jar app.jar\n\n# Specify the command to run the application\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n*/\npublic class DockerfileExample {\n    public static void main(String[] args) {\n        System.out.println(\"A Dockerfile defines the steps to build a container image.\");\n    }\n}\n\n// Example 2\n// Basic Docker commands to build and run the image\npublic class DockerCommands {\n    public static void main(String[] args) {\n        System.out.println(\"// To build the Docker image from a Dockerfile:\");\n        System.out.println(\"docker build -t my-java-app .\");\n\n        System.out.println(\"\\n// To run the application in a container:\");\n        System.out.println(\"docker run -p 8080:8080 my-java-app\");\n    }\n}"
          }
        ]
      }
    ]
  }
]
