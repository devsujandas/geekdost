[
  {
    "id": "java",
    "title": "Java",
    "desc": "A comprehensive guide to learning Java programming from basics to advanced concepts",
    "description": "Java is a powerful, object-oriented programming language known for its portability, performance, and security. This roadmap covers everything from basic syntax to enterprise development, including OOP principles, collections, multithreading, modern Java features, Spring framework, and deployment strategies. Perfect for beginners starting their programming journey and experienced developers looking to master Java ecosystem.",
    "category": "Programming",
    "categories": ["Programming", "Enterprise", "Backend"],
    "difficulty": "Beginner to Advanced",
    "image": "/images/java.png",
    "icon": "FaJava",
    "chapters": [
      {
        "id": "c1-introduction",
        "title": "Introduction & Setup",
        "desc": "Setup Java development environment and understand basics",
        "notes": "Java was created by James Gosling at Sun Microsystems in 1995 and has since become one of the most popular programming languages worldwide. It follows the 'write once, run anywhere' principle, meaning compiled Java code can run on all platforms that support Java without recompilation. The Java ecosystem consists of three main components: JVM (Java Virtual Machine) that executes bytecode, JRE (Java Runtime Environment) that provides libraries and JVM for running applications, and JDK (Java Development Kit) that includes development tools along with JRE. To start programming, you'll need to install JDK and choose an IDE like IntelliJ IDEA, Eclipse, or VS Code. Modern Java development also involves build tools like Maven and Gradle for dependency management and project automation. Understanding this foundation is crucial for effective Java development.",
        "code": "// Example 1\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n\n// Example 2\npublic class JavaVersion {\n    public static void main(String[] args) {\n        System.out.println(\"Java Version: \" + System.getProperty(\"java.version\"));\n        System.out.println(\"JVM Version: \" + System.getProperty(\"java.vm.version\"));\n    }\n}",
        "duration": "1 week",
        "topics": [
          {
            "id": "t1-history",
            "title": "History of Java",
            "desc": "Origin and evolution of Java",
            "note": "Java was initially developed by James Gosling and his team at Sun Microsystems in 1991 as part of the 'Green Project' aimed at developing software for digital devices. Originally called Oak after a tree outside Gosling's office, it was renamed Java in 1995. The first public implementation was Java 1.0 in 1995 with the promise of 'Write Once, Run Anywhere'. Key milestones include Java 1.1 (1997) with JDBC and RMI, Java 2 (1998) with collections framework and JIT compiler, Java 5 (2004) with generics and annotations, Java 8 (2014) with lambdas and streams, and recent LTS versions like Java 11 (2018) and Java 17 (2021). Oracle acquired Sun Microsystems in 2010 and now oversees Java's development through the OpenJDK project and Java Community Process. Java's design principles of simplicity, portability, security, and performance have made it dominant in enterprise applications, Android development, web servers, and big data technologies.",
            "code": "// Example 1\npublic class JavaHistory {\n    public static void main(String[] args) {\n        int releaseYear = 1995;\n        String creator = \"James Gosling\";\n        System.out.println(\"Java was created by \" + creator + \" in \" + releaseYear);\n    }\n}\n\n// Example 2\npublic class JavaVersions {\n    public static void main(String[] args) {\n        String[] majorVersions = {\"Java 1.0\", \"Java 1.2\", \"Java 5\", \"Java 8\", \"Java 11\", \"Java 17\"};\n        int[] releaseYears = {1995, 1998, 2004, 2014, 2018, 2021};\n        \n        for (int i = 0; i < majorVersions.length; i++) {\n            System.out.println(majorVersions[i] + \" released in \" + releaseYears[i]);\n        }\n    }\n}"
          },
          {
            "id": "t2-jvm-jdk-jre",
            "title": "JVM, JDK, JRE",
            "desc": "Explain components of Java runtime and development kit",
            "note": "The Java ecosystem consists of three core components that work together: JVM, JRE, and JDK. The JVM (Java Virtual Machine) is an abstract computing machine that provides runtime environment for executing Java bytecode. It performs optimization, memory management, and security checks. The JRE (Java Runtime Environment) includes the JVM plus core libraries and other components needed to run Java applications. End-users only need JRE to run Java programs. The JDK (Java Development Kit) contains the JRE plus development tools like compiler (javac), debugger (jdb), documentation generator (javadoc), and other utilities needed for Java development. When you write Java code, the compiler converts it to bytecode which is platform-independent. The JVM then interprets or compiles this bytecode to machine code specific to the host system. This architecture enables Java's cross-platform compatibility. Modern JDK distributions include OpenJDK (open source), Oracle JDK, and variants from other vendors like Amazon Corretto and Azul Zulu.",
            "code": "// Example 1\npublic class JVMInfo {\n    public static void main(String[] args) {\n        System.out.println(\"JVM Name: \" + System.getProperty(\"java.vm.name\"));\n        System.out.println(\"JVM Version: \" + System.getProperty(\"java.vm.version\"));\n        System.out.println(\"JVM Vendor: \" + System.getProperty(\"java.vm.vendor\"));\n    }\n}\n\n// Example 2\npublic class JDKCheck {\n    public static void main(String[] args) {\n        String javaVersion = System.getProperty(\"java.version\");\n        String javaHome = System.getProperty(\"java.home\");\n        \n        System.out.println(\"Java Version: \" + javaVersion);\n        System.out.println(\"Java Home: \" + javaHome);\n        \n        if (javaHome.contains(\"jdk\")) {\n            System.out.println(\"JDK is installed\");\n        } else {\n            System.out.println(\"JRE is installed\");\n        }\n    }\n}"
          },
          {
            "id": "t3-ide-setup",
            "title": "IDE Setup",
            "desc": "Setting up development environment with popular IDEs",
            "note": "An Integrated Development Environment (IDE) significantly enhances productivity by providing code editing, debugging, testing, and project management features in a single application. For Java development, the most popular IDEs are IntelliJ IDEA, Eclipse, and NetBeans. IntelliJ IDEA, developed by JetBrains, is widely considered the most powerful with excellent code completion, refactoring tools, and framework support. Eclipse is open-source with a large plugin ecosystem and strong community support. NetBeans is also open-source and known for its simplicity and good Swing GUI builder. When setting up an IDE, you need to configure the JDK path, set up project structure, and optionally install plugins for additional functionality. Modern IDEs also integrate with build tools like Maven and Gradle, version control systems like Git, and provide database tools. Choosing the right IDE depends on personal preference, project requirements, and team standards. Most professional Java developers use IntelliJ IDEA Ultimate edition which offers advanced features for enterprise development.",
            "code": "// Example 1 - Simple class demonstrating IDE features\npublic class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public int subtract(int a, int b) {\n        return a - b;\n    }\n    \n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n        System.out.println(\"5 + 3 = \" + calc.add(5, 3));\n        System.out.println(\"5 - 3 = \" + calc.subtract(5, 3));\n    }\n}\n\n// Example 2 - Using IDE debugging features\npublic class DebugExample {\n    public static void main(String[] args) {\n        int sum = 0;\n        for (int i = 1; i <= 5; i++) {\n            sum += i; // Set breakpoint here to debug\n            System.out.println(\"i=\" + i + \", sum=\" + sum);\n        }\n        System.out.println(\"Final sum: \" + sum);\n    }\n}"
          },
          {
            "id": "t4-hello-world",
            "title": "Hello World Program",
            "desc": "Writing and running your first Java program",
            "note": "The 'Hello World' program is the traditional first program when learning a new programming language. In Java, this involves creating a class with a main method that serves as the entry point for execution. The class must be public and match the filename (HelloWorld.java must contain public class HelloWorld). The main method must be public, static, void, and accept a String array parameter. Inside main, we use System.out.println to output text to the console. To compile and run the program, you use javac HelloWorld.java to compile into bytecode (HelloWorld.class) and java HelloWorld to execute it. Understanding this basic structure is fundamental as all Java applications start with a main method. Modern IDEs automate the compilation process, but it's important to understand what happens behind the scenes. This simple program introduces key concepts like classes, methods, statements, and the standard library.",
            "code": "// Example 1 - Basic Hello World\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n\n// Example 2 - Hello World with command line arguments\npublic class HelloYou {\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            System.out.println(\"Hello, \" + args[0] + \"!\");\n        } else {\n            System.out.println(\"Hello, stranger!\");\n        }\n    }\n}"
          },
          {
            "id": "t5-maven-gradle",
            "title": "Maven/Gradle Introduction",
            "desc": "Introduction to build tools and dependency management",
            "note": "Maven and Gradle are build automation tools primarily used for Java projects. They manage project dependencies, compile code, run tests, and package applications. Maven uses XML-based configuration (pom.xml) and follows convention over configuration, making projects standardized and easy to understand. It has a large repository of libraries and plugins. Gradle uses Groovy or Kotlin DSL for configuration, offering more flexibility and performance through incremental builds and build caching. Both tools resolve dependencies from repositories like Maven Central. A typical build configuration specifies project coordinates (groupId, artifactId, version), dependencies, plugins, and build phases. Maven has lifecycle phases like compile, test, package, install, deploy. Gradle uses tasks which can be customized more easily. Choosing between them depends on project needs - Maven is simpler for standard projects, while Gradle offers more power for complex builds. Most modern Java projects use one of these tools for consistent, reproducible builds.",
            "code": "// Example 1 - Simple Maven pom.xml (not Java code but shown for understanding)\n/*\n<project>\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>com.example</groupId>\n  <artifactId>my-app</artifactId>\n  <version>1.0.0</version>\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.13.2</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n*/\n\n// Example 2 - Simple Java class that would be built with Maven/Gradle\npublic class App {\n    public String getGreeting() {\n        return \"Hello from my Maven/Gradle built app!\";\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(new App().getGreeting());\n    }\n}"
          }
        ]
      },
      {
        "id": "c2-syntax",
        "title": "Syntax & Data Types",
        "desc": "Learn Java syntax, primitive types, operators, and control flow",
        "notes": "Java syntax is similar to C and C++ but with simplified features and stronger object-oriented principles. The basic building blocks include variables, data types, operators, and control flow statements. Java has two categories of data types: primitive types (byte, short, int, long, float, double, char, boolean) and reference types (objects, arrays). Variables must be declared with a specific type before use. Java supports various operators: arithmetic (+, -, *, /, %), relational (==, !=, <, >), logical (&&, ||, !), and assignment (=, +=, etc.). Control flow statements include conditional statements (if-else, switch), looping statements (for, while, do-while), and branching statements (break, continue, return). Java also supports input operations through Scanner class for reading user input. Understanding these fundamental concepts is crucial for writing basic Java programs and forms the foundation for more advanced topics.",
        "code": "// Example 1 - Basic syntax and variables\npublic class BasicSyntax {\n    public static void main(String[] args) {\n        // Variable declaration and initialization\n        int number = 10;\n        double decimal = 5.5;\n        char letter = 'A';\n        boolean flag = true;\n        \n        // Output variables\n        System.out.println(\"Number: \" + number);\n        System.out.println(\"Decimal: \" + decimal);\n        System.out.println(\"Letter: \" + letter);\n        System.out.println(\"Flag: \" + flag);\n    }\n}\n\n// Example 2 - Control flow examples\npublic class ControlFlow {\n    public static void main(String[] args) {\n        // If-else statement\n        int score = 85;\n        if (score >= 90) {\n            System.out.println(\"Grade: A\");\n        } else if (score >= 80) {\n            System.out.println(\"Grade: B\");\n        } else {\n            System.out.println(\"Grade: C or below\");\n        }\n        \n        // For loop\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(\"Count: \" + i);\n        }\n    }\n}",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-primitive-types",
            "title": "Primitive Data Types",
            "desc": "Understanding Java's built-in primitive types",
            "note": "Java has eight primitive data types that are built into the language and are not objects. These include four integer types: byte (8-bit), short (16-bit), int (32-bit), and long (64-bit); two floating-point types: float (32-bit) and double (64-bit); one character type: char (16-bit Unicode); and one boolean type: boolean (true/false). Each type has a specific range and purpose. Integers are used for whole numbers, with int being the most commonly used. Floating-point types represent decimal numbers, with double being the default choice. Char represents single characters using Unicode encoding. Boolean represents logical values true or false. Primitive types are stored directly in memory and are more efficient than objects. They have default values when declared as instance variables (0 for numbers, false for boolean, '\\u0000' for char) but must be initialized when declared as local variables. Understanding the characteristics and appropriate usage of each primitive type is fundamental to writing efficient Java programs.",
            "code": "// Example 1 - Demonstrating primitive types\npublic class PrimitiveTypes {\n    public static void main(String[] args) {\n        // Integer types\n        byte smallNumber = 100;          // 8-bit\n        short mediumNumber = 10000;      // 16-bit\n        int largeNumber = 1000000000;    // 32-bit (most common)\n        long veryLargeNumber = 1000000000000L; // 64-bit (note L suffix)\n        \n        // Floating-point types\n        float singlePrecision = 3.14f;   // 32-bit (note f suffix)\n        double doublePrecision = 3.1415926535; // 64-bit (default)\n        \n        // Other types\n        char letter = 'J';               // 16-bit Unicode\n        boolean flag = true;             // true or false\n        \n        // Output all values\n        System.out.println(\"byte: \" + smallNumber);\n        System.out.println(\"short: \" + mediumNumber);\n        System.out.println(\"int: \" + largeNumber);\n        System.out.println(\"long: \" + veryLargeNumber);\n        System.out.println(\"float: \" + singlePrecision);\n        System.out.println(\"double: \" + doublePrecision);\n        System.out.println(\"char: \" + letter);\n        System.out.println(\"boolean: \" + flag);\n    }\n}\n\n// Example 2 - Type ranges and properties\npublic class TypeProperties {\n    public static void main(String[] args) {\n        System.out.println(\"byte range: \" + Byte.MIN_VALUE + \" to \" + Byte.MAX_VALUE);\n        System.out.println(\"short range: \" + Short.MIN_VALUE + \" to \" + Short.MAX_VALUE);\n        System.out.println(\"int range: \" + Integer.MIN_VALUE + \" to \" + Integer.MAX_VALUE);\n        System.out.println(\"long range: \" + Long.MIN_VALUE + \" to \" + Long.MAX_VALUE);\n        System.out.println(\"float range: \" + Float.MIN_VALUE + \" to \" + Float.MAX_VALUE);\n        System.out.println(\"double range: \" + Double.MIN_VALUE + \" to \" + Double.MAX_VALUE);\n    }\n}"
          },
          {
            "id": "t2-literals-constants",
            "title": "Literals and Constants",
            "desc": "Working with literal values and constants in Java",
            "note": "Literals are fixed values that appear directly in code without computation. Java supports various types of literals: integer literals (42, 0xFF, 0b1010), floating-point literals (3.14, 6.022e23), character literals ('A', '\\n', '\\u0041'), string literals (\"hello\"), and boolean literals (true, false). Constants are variables whose values cannot change after initialization. In Java, constants are created using the final keyword. By convention, constant names use uppercase letters with underscores separating words. For compile-time constants that are known at compile time, we use both final and static keywords. Literals can use underscores for readability in large numbers (1_000_000). Understanding literals and constants is important for writing clear, maintainable code. Constants improve code readability and prevent accidental modification of values that should remain fixed. They also help with performance optimization as compile-time constants are inlined by the compiler.",
            "code": "// Example 1 - Different types of literals\npublic class LiteralsDemo {\n    public static void main(String[] args) {\n        // Integer literals (decimal, hex, binary)\n        int decimal = 100;\n        int hex = 0x64;         // 100 in hexadecimal\n        int binary = 0b1100100; // 100 in binary\n        \n        // Floating-point literals\n        float piFloat = 3.14f;\n        double piDouble = 3.1415926535;\n        double scientific = 6.022e23; // Avogadro's number\n        \n        // Character and string literals\n        char newline = '\\n';\n        char unicodeChar = '\\u03C0'; // Greek pi character\n        String message = \"Hello World\\n\";\n        \n        // Boolean literal\n        boolean isJavaFun = true;\n        \n        // Output all values\n        System.out.println(\"Decimal: \" + decimal);\n        System.out.println(\"Hex: \" + hex);\n        System.out.println(\"Binary: \" + binary);\n        System.out.println(\"Pi (float): \" + piFloat);\n        System.out.println(\"Pi (double): \" + piDouble);\n        System.out.println(\"Scientific: \" + scientific);\n        System.out.println(\"Unicode char: \" + unicodeChar);\n        System.out.println(\"Message: \" + message);\n        System.out.println(\"Is Java fun? \" + isJavaFun);\n    }\n}\n\n// Example 2 - Constants with final keyword\npublic class ConstantsDemo {\n    // Class constants (static final)\n    public static final double PI = 3.141592653589793;\n    public static final int MAX_USERS = 1000;\n    \n    // Instance constant (final but not static)\n    public final String APPLICATION_NAME = \"MyJavaApp\";\n    \n    public static void main(String[] args) {\n        // Local constant\n        final int LOCAL_CONSTANT = 42;\n        \n        System.out.println(\"PI: \" + PI);\n        System.out.println(\"MAX_USERS: \" + MAX_USERS);\n        System.out.println(\"LOCAL_CONSTANT: \" + LOCAL_CONSTANT);\n        \n        ConstantsDemo demo = new ConstantsDemo();\n        System.out.println(\"APPLICATION_NAME: \" + demo.APPLICATION_NAME);\n        \n        // Error: cannot assign value to final variable\n        // LOCAL_CONSTANT = 100; \n    }\n}"
          },
          {
            "id": "t3-casting-conversion",
            "title": "Type Casting and Conversion",
            "desc": "Converting between different data types in Java",
            "note": "Type casting is the process of converting a value from one data type to another. Java supports two types of casting: implicit casting (widening conversion) and explicit casting (narrowing conversion). Implicit casting happens automatically when converting from a smaller type to a larger type (byte → short → int → long → float → double). This is safe as no data loss occurs. Explicit casting is required when converting from a larger type to a smaller type and may result in data loss. The syntax is (targetType)value. Besides primitive type casting, Java also supports object type casting between classes in an inheritance hierarchy. Additionally, type conversion can occur through methods like Integer.parseInt() for converting strings to numbers. Understanding when and how to cast types is crucial for preventing compilation errors and avoiding unexpected behavior due to data loss. Care must be taken with narrowing conversions and with object casting to avoid ClassCastException.",
            "code": "// Example 1 - Primitive type casting\npublic class TypeCasting {\n    public static void main(String[] args) {\n        // Implicit casting (widening)\n        int intValue = 100;\n        long longValue = intValue;      // automatic\n        float floatValue = longValue;   // automatic\n        double doubleValue = floatValue; // automatic\n        \n        System.out.println(\"int: \" + intValue);\n        System.out.println(\"long: \" + longValue);\n        System.out.println(\"float: \" + floatValue);\n        System.out.println(\"double: \" + doubleValue);\n        \n        // Explicit casting (narrowing)\n        double largeDouble = 123.456;\n        int intFromDouble = (int) largeDouble;    // truncates decimal part\n        byte byteFromInt = (byte) intFromDouble;  // may lose data\n        \n        System.out.println(\"largeDouble: \" + largeDouble);\n        System.out.println(\"intFromDouble: \" + intFromDouble);\n        System.out.println(\"byteFromInt: \" + byteFromInt);\n        \n        // Special case: char to int is widening\n        char letter = 'A';\n        int letterCode = letter; // automatic\n        System.out.println(\"Letter: \" + letter + \", Code: \" + letterCode);\n    }\n}\n\n// Example 2 - Type conversion methods\npublic class TypeConversion {\n    public static void main(String[] args) {\n        // String to number conversion\n        String numberStr = \"123\";\n        int intValue = Integer.parseInt(numberStr);\n        double doubleValue = Double.parseDouble(\"45.67\");\n        \n        System.out.println(\"intValue: \" + intValue);\n        System.out.println(\"doubleValue: \" + doubleValue);\n        \n        // Number to String conversion\n        String intStr = String.valueOf(42);\n        String doubleStr = String.valueOf(98.76);\n        String concatStr = \"Value: \" + 123; // implicit conversion\n        \n        System.out.println(\"intStr: \" + intStr);\n        System.out.println(\"doubleStr: \" + doubleStr);\n        System.out.println(\"concatStr: \" + concatStr);\n        \n        // Error handling for invalid conversions\n        try {\n            int invalid = Integer.parseInt(\"abc\");\n        } catch (NumberFormatException e) {\n            System.out.println(\"Cannot convert 'abc' to number: \" + e.getMessage());\n        }\n    }\n}"
          },
          {
            "id": "t4-operators",
            "title": "Operators",
            "desc": "Using arithmetic, relational, logical and other operators",
            "note": "Java provides a rich set of operators for performing operations on variables and values. These include arithmetic operators (+, -, *, /, %, ++, --) for mathematical operations; relational operators (==, !=, <, >, <=, >=) for comparisons; logical operators (&&, ||, !) for boolean logic; assignment operators (=, +=, -=, *=, /=, %=) for assigning values; bitwise operators (&, |, ^, ~, <<, >>, >>>) for bit-level operations; and ternary operator (?:) for conditional expressions. Operators have precedence that determines the order of evaluation in expressions. Understanding operator precedence is important for writing correct expressions without excessive parentheses. Some operators like + also work with strings for concatenation. The instanceof operator is used for type checking with objects. Java operators are mostly similar to those in C/C++ but with some differences in behavior, particularly with the + operator for string concatenation and the lack of operator overloading (except for + with strings).",
            "code": "// Example 1 - Basic operators\npublic class OperatorsDemo {\n    public static void main(String[] args) {\n        // Arithmetic operators\n        int a = 10, b = 3;\n        System.out.println(\"a + b = \" + (a + b));\n        System.out.println(\"a - b = \" + (a - b));\n        System.out.println(\"a * b = \" + (a * b));\n        System.out.println(\"a / b = \" + (a / b));    // integer division\n        System.out.println(\"a % b = \" + (a % b));    // modulus\n        \n        // Increment/decrement operators\n        int x = 5;\n        System.out.println(\"x++ = \" + x++); // post-increment\n        System.out.println(\"++x = \" + ++x); // pre-increment\n        \n        // Relational operators\n        System.out.println(\"a == b: \" + (a == b));\n        System.out.println(\"a != b: \" + (a != b));\n        System.out.println(\"a > b: \" + (a > b));\n        \n        // Logical operators\n        boolean p = true, q = false;\n        System.out.println(\"p && q: \" + (p && q));\n        System.out.println(\"p || q: \" + (p || q));\n        System.out.println(\"!p: \" + (!p));\n        \n        // Assignment operators\n        int num = 10;\n        num += 5; // equivalent to num = num + 5\n        System.out.println(\"num after += 5: \" + num);\n    }\n}\n\n// Example 2 - Special operators and precedence\npublic class AdvancedOperators {\n    public static void main(String[] args) {\n        // Ternary operator\n        int age = 20;\n        String status = (age >= 18) ? \"Adult\" : \"Minor\";\n        System.out.println(\"Status: \" + status);\n        \n        // Bitwise operators\n        int m = 5; // binary: 0101\n        int n = 3; // binary: 0011\n        System.out.println(\"m & n = \" + (m & n)); // AND: 0001 (1)\n        System.out.println(\"m | n = \" + (m | n)); // OR: 0111 (7)\n        System.out.println(\"m ^ n = \" + (m ^ n)); // XOR: 0110 (6)\n        \n        // Shift operators\n        int value = 8; // binary: 1000\n        System.out.println(\"value << 1 = \" + (value << 1)); // left shift: 10000 (16)\n        System.out.println(\"value >> 1 = \" + (value >> 1)); // right shift: 0100 (4)\n        \n        // Operator precedence\n        int result1 = 2 + 3 * 4;   // multiplication first: 2 + 12 = 14\n        int result2 = (2 + 3) * 4; // parentheses first: 5 * 4 = 20\n        System.out.println(\"Result1: \" + result1);\n        System.out.println(\"Result2: \" + result2);\n        \n        // String concatenation with +\n        String hello = \"Hello\" + \" \" + \"World\";\n        System.out.println(hello);\n    }\n}"
          },
          {
            "id": "t5-control-flow",
            "title": "Control Flow Statements",
            "desc": "Using conditional and looping statements to control program flow",
            "note": "Control flow statements determine the order in which statements are executed in a program. Java provides several types of control flow statements: conditional statements (if-else, switch) for decision making; looping statements (for, while, do-while) for repetition; and branching statements (break, continue, return) for altering normal flow. The if-else statement executes code based on boolean conditions. Switch statements allow multi-way branching based on a value. For loops are used when the number of iterations is known beforehand. While loops continue while a condition is true. Do-while loops guarantee at least one execution. Break exits loops or switch statements. Continue skips the current iteration. Return exits methods with optional values. Understanding control flow is essential for implementing program logic. Java also provides enhanced for-each loops for iterating over collections and arrays. Proper use of control flow statements makes code more readable, maintainable, and efficient. Modern Java versions have enhanced switch expressions with more concise syntax and better functionality.",
            "code": "// Example 1 - Conditional statements\npublic class ConditionalStatements {\n    public static void main(String[] args) {\n        // If-else statement\n        int number = 10;\n        \n        if (number > 0) {\n            System.out.println(\"Positive number\");\n        } else if (number < 0) {\n            System.out.println(\"Negative number\");\n        } else {\n            System.out.println(\"Zero\");\n        }\n        \n        // Switch statement (traditional)\n        int day = 3;\n        String dayName;\n        \n        switch (day) {\n            case 1: dayName = \"Monday\"; break;\n            case 2: dayName = \"Tuesday\"; break;\n            case 3: dayName = \"Wednesday\"; break;\n            case 4: dayName = \"Thursday\"; break;\n            case 5: dayName = \"Friday\"; break;\n            case 6: dayName = \"Saturday\"; break;\n            case 7: dayName = \"Sunday\"; break;\n            default: dayName = \"Invalid day\";\n        }\n        \n        System.out.println(\"Day \" + day + \" is \" + dayName);\n    }\n}\n\n// Example 2 - Looping statements\npublic class LoopingStatements {\n    public static void main(String[] args) {\n        // For loop\n        System.out.println(\"For loop:\");\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(\"Count: \" + i);\n        }\n        \n        // While loop\n        System.out.println(\"\\nWhile loop:\");\n        int j = 1;\n        while (j <= 3) {\n            System.out.println(\"Count: \" + j);\n            j++;\n        }\n        \n        // Do-while loop\n        System.out.println(\"\\nDo-while loop:\");\n        int k = 1;\n        do {\n            System.out.println(\"Count: \" + k);\n            k++;\n        } while (k <= 3);\n        \n        // Enhanced for-each loop (for arrays)\n        System.out.println(\"\\nFor-each loop:\");\n        int[] numbers = {1, 2, 3, 4, 5};\n        for (int num : numbers) {\n            System.out.println(\"Number: \" + num);\n        }\n        \n        // Break and continue\n        System.out.println(\"\\nBreak and continue:\");\n        for (int i = 1; i <= 10; i++) {\n            if (i == 5) {\n                continue; // skip 5\n            }\n            if (i == 8) {\n                break; // exit at 8\n            }\n            System.out.println(\"i = \" + i);\n        }\n    }\n}"
          },
          {
            "id": "t6-user-input",
            "title": "User Input Handling",
            "desc": "Reading input from users via console",
            "note": "Java provides several ways to read input from users, with the Scanner class being the most common approach for console input. Scanner is part of java.util package and can parse primitive types and strings using regular expressions. To use Scanner, you create an instance tied to System.in, then use methods like next(), nextInt(), nextDouble(), etc., to read different types of input. It's important to handle input validation and exceptions when reading user input. BufferedReader coupled with InputStreamReader is another approach that offers better performance for reading large amounts of text but requires more code for parsing. Java also supports command-line arguments through the args parameter in the main method. For more complex input scenarios, there are GUI input dialogs and web-based input forms. Understanding how to properly read and validate user input is crucial for building interactive applications. Always consider edge cases like invalid input types, empty input, and input that might cause exceptions.",
            "code": "// Example 1 - Using Scanner for input\nimport java.util.Scanner;\n\npublic class ScannerInput {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        System.out.print(\"Enter your name: \");\n        String name = scanner.nextLine();\n        \n        System.out.print(\"Enter your age: \");\n        int age = scanner.nextInt();\n        \n        System.out.print(\"Enter your height (meters): \");\n        double height = scanner.nextDouble();\n        \n        // Consume the leftover newline\n        scanner.nextLine();\n        \n        System.out.print(\"Enter your city: \");\n        String city = scanner.nextLine();\n        \n        System.out.println(\"\\n--- User Information ---\");\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Height: \" + height + \"m\");\n        System.out.println(\"City: \" + city);\n        \n        scanner.close();\n    }\n}\n\n// Example 2 - Input validation and error handling\nimport java.util.Scanner;\n\npublic class InputValidation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Validate integer input\n        int number = 0;\n        boolean validInput = false;\n        \n        while (!validInput) {\n            System.out.print(\"Enter a number between 1 and 100: \");\n            \n            if (scanner.hasNextInt()) {\n                number = scanner.nextInt();\n                if (number >= 1 && number <= 100) {\n                    validInput = true;\n                } else {\n                    System.out.println(\"Number must be between 1 and 100. Try again.\");\n                }\n            } else {\n                System.out.println(\"That's not a valid number. Try again.\");\n                scanner.next(); // clear invalid input\n            }\n        }\n        \n        System.out.println(\"You entered: \" + number);\n        \n        // Using command-line arguments\n        if (args.length > 0) {\n            System.out.println(\"\\nCommand-line arguments:\");\n            for (int i = 0; i < args.length; i++) {\n                System.out.println(\"Argument \" + (i + 1) + \": \" + args[i]);\n            }\n        }\n        \n        scanner.close();\n    }\n}"
          }
        ]
      },
      {
        "id": "c3-classes-objects",
        "title": "Classes, Objects & Methods",
        "desc": "Understanding object-oriented programming with classes and objects",
        "notes": "Classes and objects are fundamental concepts in Java's object-oriented programming paradigm. A class is a blueprint or template that defines the properties (fields) and behaviors (methods) that objects of that class will have. An object is an instance of a class created at runtime. Classes encapsulate data and methods that operate on that data, promoting modularity and code reuse. Key concepts include constructors for initializing objects, the 'this' keyword for referring to the current object, static members that belong to the class rather than instances, method overloading for multiple methods with the same name but different parameters, and encapsulation through access modifiers (public, private, protected) that control access to class members. Packages are used to organize related classes and avoid naming conflicts. Understanding these concepts is crucial for effective Java programming as they form the foundation of object-oriented design and enable the creation of modular, maintainable, and reusable code.",
        "code": "// Example 1 - Basic class and object creation\npublic class Car {\n    // Fields (properties)\n    String brand;\n    String model;\n    int year;\n    \n    // Constructor\n    public Car(String brand, String model, int year) {\n        this.brand = brand;\n        this.model = model;\n        this.year = year;\n    }\n    \n    // Method\n    public void displayInfo() {\n        System.out.println(year + \" \" + brand + \" \" + model);\n    }\n    \n    public static void main(String[] args) {\n        // Create objects\n        Car car1 = new Car(\"Toyota\", \"Camry\", 2020);\n        Car car2 = new Car(\"Honda\", \"Civic\", 2022);\n        \n        // Call methods\n        car1.displayInfo();\n        car2.displayInfo();\n    }\n}\n\n// Example 2 - Static members and method overloading\npublic class Calculator {\n    // Static field (class variable)\n    public static int operationCount = 0;\n    \n    // Static method\n    public static void incrementCount() {\n        operationCount++;\n    }\n    \n    // Method overloading - same name, different parameters\n    public int add(int a, int b) {\n        incrementCount();\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        incrementCount();\n        return a + b;\n    }\n    \n    public int add(int a, int b, int c) {\n        incrementCount();\n        return a + b + c;\n    }\n    \n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n        \n        System.out.println(\"2 + 3 = \" + calc.add(2, 3));\n        System.out.println(\"2.5 + 3.7 = \" + calc.add(2.5, 3.7));\n        System.out.println(\"1 + 2 + 3 = \" + calc.add(1, 2, 3));\n        \n        System.out.println(\"Total operations: \" + Calculator.operationCount);\n    }\n}",
        "duration": "2 weeks",
        "topics": [
          {
            "id": "t1-classes-objects",
            "title": "Classes and Objects",
            "desc": "Creating and using classes and objects",
            "note": "Classes are the fundamental building blocks of Java programs, serving as templates for creating objects. A class defines the structure and behavior that its objects will have. It contains fields (variables) that represent the state of objects and methods that define their behavior. Objects are instances of classes created using the 'new' keyword followed by a constructor call. Each object has its own copy of instance variables but shares class (static) variables. The process of creating objects is called instantiation. Objects interact with each other by invoking methods and accessing fields (subject to access control). Understanding the relationship between classes and objects is crucial for object-oriented programming. Classes promote code organization, reusability, and maintenance. Good class design follows principles like high cohesion (class has a single well-defined purpose) and low coupling (minimal dependencies between classes). Java also supports nested classes (classes within classes) for better encapsulation and organization.",
            "code": "// Example 1 - Basic class definition and object creation\npublic class Student {\n    // Instance variables (fields)\n    String name;\n    int age;\n    String studentId;\n    \n    // Constructor\n    public Student(String name, int age, String studentId) {\n        this.name = name;\n        this.age = age;\n        this.studentId = studentId;\n    }\n    \n    // Method to display student information\n    public void displayInfo() {\n        System.out.println(\"Student ID: \" + studentId);\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n    }\n    \n    // Method to update age\n    public void haveBirthday() {\n        age++;\n        System.out.println(name + \" is now \" + age + \" years old!\");\n    }\n    \n    public static void main(String[] args) {\n        // Create Student objects\n        Student student1 = new Student(\"Alice\", 20, \"S1001\");\n        Student student2 = new Student(\"Bob\", 21, \"S1002\");\n        \n        // Call methods on objects\n        System.out.println(\"--- Student 1 ---\");\n        student1.displayInfo();\n        \n        System.out.println(\"\\n--- Student 2 ---\");\n        student2.displayInfo();\n        \n        // Modify object state\n        student1.haveBirthday();\n        student1.displayInfo();\n    }\n}\n\n// Example 2 - Multiple classes and object interaction\nclass BankAccount {\n    String accountNumber;\n    double balance;\n    String ownerName;\n    \n    public BankAccount(String accountNumber, double initialBalance, String ownerName) {\n        this.accountNumber = accountNumber;\n        this.balance = initialBalance;\n        this.ownerName = ownerName;\n    }\n    \n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount);\n        }\n    }\n    \n    public void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            System.out.println(\"Withdrew: $\" + amount);\n        } else {\n            System.out.println(\"Invalid withdrawal amount\");\n        }\n    }\n    \n    public void displayBalance() {\n        System.out.println(\"Account: \" + accountNumber);\n        System.out.println(\"Balance: $\" + balance);\n    }\n}\n\nclass BankDemo {\n    public static void main(String[] args) {\n        BankAccount account1 = new BankAccount(\"123456\", 1000.0, \"John Doe\");\n        BankAccount account2 = new BankAccount(\"789012\", 500.0, \"Jane Smith\");\n        \n        account1.displayBalance();\n        account1.deposit(250.0);\n        account1.withdraw(100.0);\n        account1.displayBalance();\n        \n        System.out.println();\n        \n        account2.displayBalance();\n        account2.withdraw(600.0); // Should fail\n        account2.displayBalance();\n    }\n}"
          },
          {
            "id": "t2-constructors-this",
            "title": "Constructors and this Keyword",
            "desc": "Using constructors for object initialization and this keyword",
            "note": "Constructors are special methods used to initialize newly created objects. They have the same name as the class and no return type. Java provides a default constructor (no-argument) if no constructors are defined. Constructors can be overloaded to provide different ways to initialize objects. The 'this' keyword refers to the current object instance and is used to: 1) differentiate between instance variables and parameters with the same name, 2) call other constructors in the same class (constructor chaining) using this(), and 3) pass the current object as a parameter to other methods. Constructor chaining helps avoid code duplication by allowing one constructor to call another. The call to another constructor must be the first statement in a constructor. Understanding proper constructor usage is essential for creating well-initialized objects. Constructors ensure that objects start in a valid state, which is a fundamental principle of object-oriented design. They work together with encapsulation to maintain object integrity throughout its lifecycle.",
            "code": "// Example 1 - Basic constructors and this keyword\npublic class Person {\n    String name;\n    int age;\n    String email;\n    \n    // Default constructor\n    public Person() {\n        this.name = \"Unknown\";\n        this.age = 0;\n        this.email = \"not provided\";\n    }\n    \n    // Parameterized constructor\n    public Person(String name, int age) {\n        this.name = name; // this distinguishes instance variable from parameter\n        this.age = age;\n        this.email = \"not provided\";\n    }\n    \n    // Fully parameterized constructor\n    public Person(String name, int age, String email) {\n        this.name = name;\n        this.age = age;\n        this.email = email;\n    }\n    \n    // Method using this to refer to current object\n    public void displayInfo() {\n        System.out.println(\"Name: \" + this.name);\n        System.out.println(\"Age: \" + this.age);\n        System.out.println(\"Email: \" + this.email);\n    }\n    \n    // Method that returns the current object\n    public Person withEmail(String email) {\n        this.email = email;\n        return this; // enables method chaining\n    }\n    \n    public static void main(String[] args) {\n        Person person1 = new Person(); // uses default constructor\n        Person person2 = new Person(\"Alice\", 25); // uses 2-parameter constructor\n        Person person3 = new Person(\"Bob\", 30, \"bob@email.com\"); // uses 3-parameter constructor\n        \n        person1.displayInfo();\n        System.out.println();\n        \n        person2.displayInfo();\n        System.out.println();\n        \n        person3.displayInfo();\n        System.out.println();\n        \n        // Method chaining using this\n        person2.withEmail(\"alice@email.com\").displayInfo();\n    }\n}\n\n// Example 2 - Constructor chaining\npublic class Rectangle {\n    int width;\n    int height;\n    String color;\n    \n    // Default constructor chains to parameterized constructor\n    public Rectangle() {\n        this(1, 1, \"black\"); // must be first statement\n    }\n    \n    // Constructor with dimensions only\n    public Rectangle(int width, int height) {\n        this(width, height, \"black\"); // chains to full constructor\n    }\n    \n    // Full parameterized constructor\n    public Rectangle(int width, int height, String color) {\n        this.width = width;\n        this.height = height;\n        this.color = color;\n    }\n    \n    public int getArea() {\n        return width * height;\n    }\n    \n    public void displayInfo() {\n        System.out.println(color + \" rectangle: \" + width + \"x\" + height);\n        System.out.println(\"Area: \" + getArea());\n    }\n    \n    public static void main(String[] args) {\n        Rectangle rect1 = new Rectangle(); // uses default\n        Rectangle rect2 = new Rectangle(5, 3); // uses 2-parameter\n        Rectangle rect3 = new Rectangle(4, 6, \"blue\"); // uses full\n        \n        rect1.displayInfo();\n        System.out.println();\n        \n        rect2.displayInfo();\n        System.out.println();\n        \n        rect3.displayInfo();\n    }\n}"
          },
          {
            "id": "t3-static-members",
            "title": "Static Members",
            "desc": "Understanding static fields, methods, and blocks",
            "note": "Static members belong to the class rather than to individual objects. Static variables (class variables) are shared by all instances of the class. Static methods can be called without creating an object and can only access static members directly. Static blocks are used for static initialization and run when the class is loaded. The main method must be static as it's called before any objects are created. Constants are often declared as static final. Static imports allow using static members without class name qualification. Static nested classes are classes declared as static inside another class. Understanding when to use static members is important: use them for utility methods, constants, shared data, or factory methods. However, overuse of static members can lead to code that's hard to test and maintain, as it introduces global state and tight coupling. Static methods should generally be stateless and operate only on their parameters. The Singleton pattern often uses static methods to provide global access to a single instance.",
            "code": "// Example 1 - Static variables and methods\npublic class Counter {\n    // Instance variable - each object has its own copy\n    private int instanceCount = 0;\n    \n    // Static variable - shared by all objects\n    private static int staticCount = 0;\n    \n    public Counter() {\n        instanceCount++;\n        staticCount++;\n    }\n    \n    // Instance method\n    public int getInstanceCount() {\n        return instanceCount;\n    }\n    \n    // Static method\n    public static int getStaticCount() {\n        return staticCount;\n    }\n    \n    // Static utility method\n    public static int add(int a, int b) {\n        return a + b;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Initial static count: \" + Counter.getStaticCount());\n        \n        Counter c1 = new Counter();\n        Counter c2 = new Counter();\n        Counter c3 = new Counter();\n        \n        System.out.println(\"c1 instance count: \" + c1.getInstanceCount());\n        System.out.println(\"c2 instance count: \" + c2.getInstanceCount());\n        System.out.println(\"Static count after 3 objects: \" + Counter.getStaticCount());\n        \n        // Call static utility method\n        System.out.println(\"5 + 3 = \" + Counter.add(5, 3));\n    }\n}\n\n// Example 2 - Static blocks and constants\npublic class MathUtils {\n    // Static constants\n    public static final double PI = 3.141592653589793;\n    public static final double E = 2.718281828459045;\n    \n    // Static variable with initialization\n    private static int usageCount = 0;\n    \n    // Static block for initialization\n    static {\n        System.out.println(\"MathUtils class is being loaded\");\n        // Can perform complex initialization here\n    }\n    \n    // Static methods\n    public static double circleArea(double radius) {\n        usageCount++;\n        return PI * radius * radius;\n    }\n    \n    public static double circleCircumference(double radius) {\n        usageCount++;\n        return 2 * PI * radius;\n    }\n    \n    public static int getUsageCount() {\n        return usageCount;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"PI: \" + MathUtils.PI);\n        System.out.println(\"Area of circle with radius 5: \" + MathUtils.circleArea(5));\n        System.out.println(\"Circumference of circle with radius 5: \" + MathUtils.circleCircumference(5));\n        System.out.println(\"Total operations: \" + MathUtils.getUsageCount());\n    }\n}"
          },
          {
            "id": "t4-method-overloading",
            "title": "Method Overloading",
            "desc": "Creating multiple methods with the same name but different parameters",
            "note": "Method overloading allows a class to have multiple methods with the same name but different parameters. Overloaded methods must differ in: 1) number of parameters, 2) types of parameters, or 3) order of parameters. Return type alone is not sufficient to overload methods. Constructor overloading is also possible and common. Overloading is a form of compile-time polymorphism. The compiler determines which method to call based on the arguments provided. Overloading improves code readability and provides flexibility in how methods can be called. Common uses include providing convenience methods with default parameters, handling different data types, and supporting multiple ways to perform an operation. However, overloading should be used judiciously to avoid confusion. Methods with the same name should perform similar operations. Overloading is different from overriding, which occurs in inheritance and is runtime polymorphism. Varargs (variable arguments) can be used with overloading to handle variable numbers of parameters, but care must be taken to avoid ambiguity.",
            "code": "// Example 1 - Basic method overloading\npublic class MathOperations {\n    // Overloaded add methods\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n    \n    // Different parameter types\n    public String add(String a, String b) {\n        return a + b; // string concatenation\n    }\n    \n    // Different parameter order\n    public void printDetails(String name, int age) {\n        System.out.println(\"Name: \" + name + \", Age: \" + age);\n    }\n    \n    public void printDetails(int id, String name) {\n        System.out.println(\"ID: \" + id + \", Name: \" + name);\n    }\n    \n    public static void main(String[] args) {\n        MathOperations ops = new MathOperations();\n        \n        System.out.println(\"2 + 3 = \" + ops.add(2, 3));\n        System.out.println(\"2.5 + 3.7 = \" + ops.add(2.5, 3.7));\n        System.out.println(\"1 + 2 + 3 = \" + ops.add(1, 2, 3));\n        System.out.println(\"\"Hello\" + \"World\" = \" + ops.add(\"Hello\", \"World\"));\n        \n        ops.printDetails(\"Alice\", 25);\n        ops.printDetails(1001, \"Bob\");\n    }\n}\n\n// Example 2 - Constructor overloading and varargs\npublic class Printer {\n    private String message;\n    private int copies;\n    \n    // Constructor overloading\n    public Printer() {\n        this.message = \"Default message\";\n        this.copies = 1;\n    }\n    \n    public Printer(String message) {\n        this.message = message;\n        this.copies = 1;\n    }\n    \n    public Printer(String message, int copies) {\n        this.message = message;\n        this.copies = copies;\n    }\n    \n    // Method with varargs (variable arguments)\n    public void printMessages(String... messages) {\n        for (String msg : messages) {\n            System.out.println(msg);\n        }\n    }\n    \n    // Overloaded method with different parameter types\n    public void printMessages(int times, String message) {\n        for (int i = 0; i < times; i++) {\n            System.out.println(message);\n        }\n    }\n    \n    public void print() {\n        for (int i = 0; i < copies; i++) {\n            System.out.println(message);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Printer p1 = new Printer(); // default\n        Printer p2 = new Printer(\"Hello\"); // message only\n        Printer p3 = new Printer(\"Java\", 3); // message and copies\n        \n        p1.print();\n        System.out.println();\n        \n        p2.print();\n        System.out.println();\n        \n        p3.print();\n        System.out.println();\n        \n        // Using varargs\n        p1.printMessages(\"One\", \"Two\", \"Three\");\n        System.out.println();\n        \n        p1.printMessages(2, \"Repeated\");\n    }\n}"
          },
          {
            "id": "t5-encapsulation",
            "title": "Encapsulation",
            "desc": "Data hiding and access control using encapsulation",
            "note": "Encapsulation is a fundamental object-oriented programming concept that bundles data (fields) and methods that operate on that data within a class, and restricts direct access to some of the object's components. In Java, encapsulation is achieved through access modifiers: private (accessible only within the class), protected (accessible within package and subclasses), public (accessible from anywhere), and package-private (default, accessible within package). Fields are typically made private and accessed through public getter and setter methods. This approach protects the object's internal state from invalid modifications and allows the implementation to change without affecting clients. Encapsulation promotes maintainability, flexibility, and reusability. It also enables validation in setter methods and computed values in getter methods. JavaBeans convention recommends getXxx() and setXxx() methods for accessing properties. Immutable classes take encapsulation further by making fields final and not providing setters. Proper encapsulation is key to building robust, secure, and maintainable Java applications.",
            "code": "// Example 1 - Basic encapsulation with getters and setters\npublic class BankAccount {\n    // Private fields - encapsulated data\n    private String accountNumber;\n    private double balance;\n    private String ownerName;\n    \n    // Constructor\n    public BankAccount(String accountNumber, double initialBalance, String ownerName) {\n        this.accountNumber = accountNumber;\n        this.balance = initialBalance;\n        this.ownerName = ownerName;\n    }\n    \n    // Public getter methods (accessors)\n    public String getAccountNumber() {\n        return accountNumber;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    public String getOwnerName() {\n        return ownerName;\n    }\n    \n    // Public setter methods (mutators) with validation\n    public void setOwnerName(String ownerName) {\n        if (ownerName != null && !ownerName.trim().isEmpty()) {\n            this.ownerName = ownerName;\n        } else {\n            System.out.println(\"Invalid owner name\");\n        }\n    }\n    \n    // Public methods to manipulate balance with business logic\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount);\n        } else {\n            System.out.println(\"Deposit amount must be positive\");\n        }\n    }\n    \n    public void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            System.out.println(\"Withdrew: $\" + amount);\n        } else {\n            System.out.println(\"Invalid withdrawal amount\");\n        }\n    }\n    \n    // Public method to display account info\n    public void displayAccountInfo() {\n        System.out.println(\"Account Number: \" + accountNumber);\n        System.out.println(\"Owner: \" + ownerName);\n        System.out.println(\"Balance: $\" + balance);\n    }\n    \n    public static void main(String[] args) {\n        BankAccount account = new BankAccount(\"123456789\", 1000.0, \"John Doe\");\n        \n        account.displayAccountInfo();\n        System.out.println();\n        \n        // Using public methods to interact with object\n        account.deposit(500.0);\n        account.withdraw(200.0);\n        account.setOwnerName(\"John Smith\");\n        \n        System.out.println();\n        account.displayAccountInfo();\n        \n        // Direct access to private fields is not allowed\n        // account.balance = 1000000; // Compilation error\n        // System.out.println(account.balance); // Compilation error\n    }\n}\n\n// Example 2 - Immutable class (strong encapsulation)\npublic final class ImmutablePerson {\n    // Final fields - cannot be changed after construction\n    private final String name;\n    private final int age;\n    private final List<String> hobbies;\n    \n    // Constructor\n    public ImmutablePerson(String name, int age, List<String> hobbies) {\n        this.name = name;\n        this.age = age;\n        // Defensive copy to prevent external modification\n        this.hobbies = new ArrayList<>(hobbies);\n    }\n    \n    // Getter methods\n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    // Return defensive copy of mutable field\n    public List<String> getHobbies() {\n        return new ArrayList<>(hobbies);\n    }\n    \n    // No setter methods - object is immutable\n    \n    // Method that returns new object instead of modifying current one\n    public ImmutablePerson withAge(int newAge) {\n        return new ImmutablePerson(name, newAge, hobbies);\n    }\n    \n    @Override\n    public String toString() {\n        return \"Person{name='\" + name + \"', age=\" + age + \", hobbies=\" + hobbies + \"}\";\n    }\n    \n    public static void main(String[] args) {\n        List<String> hobbies = new ArrayList<>();\n        hobbies.add(\"Reading\");\n        hobbies.add(\"Swimming\");\n        \n        ImmutablePerson person = new ImmutablePerson(\"Alice\", 30, hobbies);\n        System.out.println(\"Original: \" + person);\n        \n        // Attempt to modify the original list\n        hobbies.add(\"Gaming\"); // Doesn't affect the immutable object\n        System.out.println(\"After modifying original list: \" + person);\n        \n        // Attempt to modify the returned list\n        List<String> personHobbies = person.getHobbies();\n        personHobbies.add(\"Gaming\"); // Doesn't affect the immutable object\n        System.out.println(\"After modifying returned list: \" + person);\n        \n        // Create new object with different age\n        ImmutablePerson olderPerson = person.withAge(31);\n        System.out.println(\"New person: \" + olderPerson);\n        System.out.println(\"Original person: \" + person);\n    }\n}"
          },
          {
            "id": "t6-packages",
            "title": "Packages",
            "desc": "Organizing classes into packages for better structure",
            "note": "Packages are Java's mechanism for organizing related classes and interfaces into namespaces. They help avoid naming conflicts, control access through package visibility, and make large codebases more manageable. Packages follow a hierarchical naming convention using reverse domain names (e.g., com.example.myapp). The package statement must be the first non-comment line in a Java file. Classes can be imported using import statements for easier access. Java provides several built-in packages like java.lang (automatically imported), java.util, java.io, etc. Access control includes package-private (default) visibility which allows access within the same package. Packages are mapped to directory structures in the file system. Understanding package organization is crucial for building maintainable applications. Modern build tools like Maven and Gradle enforce standard package structures. Package naming conventions improve code readability and help others understand the purpose of your classes. Java also supports static imports for importing static members directly. Proper package organization is a key aspect of professional Java development.",
            "code": "// Example 1 - Package declaration and import statements\n// File: com/example/model/Person.java\npackage com.example.model;\n\npublic class Person {\n    private String name;\n    private int age;\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    @Override\n    public String toString() {\n        return \"Person{name='\" + name + \"', age=\" + age + \"}\";\n    }\n}\n\n// File: com/example/util/Calculator.java\npackage com.example.util;\n\npublic class Calculator {\n    public static int add(int a, int b) {\n        return a + b;\n    }\n    \n    public static double add(double a, double b) {\n        return a + b;\n    }\n}\n\n// File: com/example/Main.java\npackage com.example;\n\n// Import classes from other packages\nimport com.example.model.Person;\nimport com.example.util.Calculator;\n// import java.util.List; // Example of importing Java standard library\n// import java.util.*;    // Wildcard import (not recommended generally)\n\npublic class Main {\n    public static void main(String[] args) {\n        Person person = new Person(\"Alice\", 25);\n        System.out.println(person);\n        \n        int sum = Calculator.add(5, 3);\n        System.out.println(\"5 + 3 = \" + sum);\n        \n        double doubleSum = Calculator.add(2.5, 3.7);\n        System.out.println(\"2.5 + 3.7 = \" + doubleSum);\n    }\n}\n\n// Example 2 - Package visibility and access control\n// File: com/example/library/Book.java\npackage com.example.library;\n\npublic class Book {\n    private String title;      // private - only accessible within class\n    String author;             // package-private - accessible within package\n    protected int pageCount;   // protected - accessible within package and subclasses\n    public String isbn;        // public - accessible from anywhere\n    \n    public Book(String title, String author, int pageCount, String isbn) {\n        this.title = title;\n        this.author = author;\n        this.pageCount = pageCount;\n        this.isbn = isbn;\n    }\n    \n    // Public getter for private field\n    public String getTitle() {\n        return title;\n    }\n    \n    // Package-private method\n    void printDetails() {\n        System.out.println(\"Title: \" + title);\n        System.out.println(\"Author: \" + author);\n        System.out.println(\"Pages: \" + pageCount);\n        System.out.println(\"ISBN: \" + isbn);\n    }\n}\n\n// File: com/example/library/Library.java\npackage com.example.library;\n\npublic class Library {\n    public void demonstrateAccess() {\n        Book book = new Book(\"Java Programming\", \"John Doe\", 350, \"123-4567890123\");\n        \n        // Can access package-private and protected fields within same package\n        System.out.println(\"Author: \" + book.author);      // OK - same package\n        System.out.println(\"Pages: \" + book.pageCount);    // OK - same package\n        System.out.println(\"ISBN: \" + book.isbn);          // OK - public\n        \n        // Cannot access private field directly\n        // System.out.println(book.title); // Compilation error\n        \n        // Can access through public getter\n        System.out.println(\"Title: \" + book.getTitle());   // OK - public method\n        \n        // Can call package-private method\n        book.printDetails(); // OK - same package\n    }\n}\n\n// File: com/example/Main2.java\npackage com.example;\n\nimport com.example.library.Book;\n\npublic class Main2 {\n    public static void main(String[] args) {\n        Book book = new Book(\"Java Programming\", \"John Doe\", 350, \"123-4567890123\");\n        \n        // Can only access public members from different package\n        System.out.println(\"ISBN: \" + book.isbn);          // OK - public\n        System.out.println(\"Title: \" + book.getTitle());   // OK - public method\n        \n        // Cannot access package-private, protected, or private members\n        // System.out.println(book.author);     // Compilation error - different package\n        // System.out.println(book.pageCount);  // Compilation error - different package\n        // book.printDetails();                 // Compilation error - different package\n    }\n}"
                    }
        ]
      }
    ]
  }
]
    
    

    
      