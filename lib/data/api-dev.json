[
  {
    "id": "api-dev",
    "title": "API Development & Testing",
    "desc": "A one-week intensive course to master REST APIs, from design and authentication to hands-on testing.",
    "description": "This complete API roadmap provides a structured, week-long learning path with in-depth theoretical notes and practical, runnable Python examples using Flask, FastAPI, and the requests library. It is designed for intermediate developers looking to build and test robust backend services.",
    "category": "Backend Development",
    "categories": ["APIs", "Web Development", "Testing", "Python"],
    "difficulty": "Intermediate",
    "image": "/images/api-development.jpg",
    "icon": "FaServer",
    "chapters": [
      {
        "id": "c1-intro-api",
        "title": "Day 1: Introduction to APIs & REST Principles",
        "desc": "Understand the fundamentals of APIs, the client-server model, and the core principles of RESTful architecture.",
        "notes": "The first day is dedicated to building a solid foundation. An API (Application Programming Interface) acts as a contract between a provider and a user, defining the methods of communication between different software components. We will focus on web APIs, specifically REST (Representational State Transfer), which is an architectural style, not a protocol. Understanding its constraints is key to designing scalable and maintainable web services. This chapter covers the essential terminology and concepts you'll use throughout the week.",
        "duration": "1 day",
        "topics": [
          {
            "id": "t1-what-is-api",
            "title": "What is an API?",
            "desc": "Learn the definition of an API, its importance in modern software, and see a simple interaction.",
            "note": "An Application Programming Interface (API) is a set of rules, protocols, and tools for building software applications. Essentially, an API specifies how software components should interact. In the context of web development, APIs allow different applications to communicate with each other over the internet. For example, when you use a weather app on your phone, the app sends a request to a weather service's API to fetch the latest forecast. The API defines the structure of the request (e.g., what city to get weather for) and the structure of the response (the data returned, like temperature and humidity). This abstraction is powerful because it allows developers to use complex functionality without needing to know the intricate details of its implementation. A front-end developer building a user interface doesn't need to understand the backend database or server logic; they only need to know how to interact with the API. This separation of concerns is a cornerstone of modern application design, enabling microservices, mobile apps, and third-party integrations to work seamlessly. APIs promote modularity and reusability, accelerating development and fostering innovation by allowing developers to build upon existing platforms and services.",
            "code": "import requests\nimport json\n\n# Example 1: Consuming a public API with 'requests'\n# This code sends a GET request to the JSONPlaceholder API to fetch a list of posts.\nprint('--- Example 1: Fetching data from a public API ---')\nresponse = requests.get('https://jsonplaceholder.typicode.com/posts/1')\nif response.status_code == 200:\n    print(json.dumps(response.json(), indent=2))\nelse:\n    print(f'Error: {response.status_code}')\n\n# Example 2: Creating a basic API endpoint with Flask\n# This code creates a simple web server that responds with a JSON message.\n# To run: save as app.py, run 'pip install Flask', then 'flask run'.\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route('/api/hello', methods=['GET'])\ndef hello():\n    return jsonify({'message': 'Hello, World! This is your first API.'})\n\n# To test, run this script and navigate to http://127.0.0.1:5000/api/hello"
          },
          {
            "id": "t2-rest-principles",
            "title": "Understanding REST Principles",
            "desc": "Dive into the six guiding constraints of REST architecture, including statelessness and client-server separation.",
            "note": "REST, or Representational State Transfer, is an architectural style that defines a set of constraints for creating web services. Adhering to these principles leads to scalable, reliable, and easy-to-use APIs. The six core constraints are: 1. **Client-Server Architecture**: This principle enforces a separation of concerns. The client (e.g., a web browser or mobile app) is responsible for the user interface, while the server is responsible for data storage and business logic. They communicate over a network, and this separation allows them to be developed and scaled independently. 2. **Statelessness**: Each request from a client to the server must contain all the information needed to understand and complete the request. The server does not store any client context (or session state) between requests. This enhances scalability, as any server can handle any request, making it easier to manage server load. 3. **Cacheability**: Responses from the server should be defined as cacheable or non-cacheable. If a response is cacheable, the client can reuse that data for subsequent requests, reducing latency and server load. 4. **Layered System**: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way. Intermediary servers (like proxies or load balancers) can be introduced to improve scalability, security, and caching without affecting the client or server. 5. **Uniform Interface**: This is a key constraint that simplifies and decouples the architecture. It consists of four sub-constraints: resource identification in requests (e.g., using URIs), resource manipulation through representations (e.g., using JSON), self-descriptive messages, and HATEOAS (Hypermedia as the Engine of Application State), where the server provides links to guide the client on what actions it can take next. 6. **Code on Demand (Optional)**: Servers can temporarily extend or customize the functionality of a client by transferring executable code, such as JavaScript. This is the only optional constraint.",
            "code": "from flask import Flask, request, jsonify\n\n# Example 1: A stateless Flask endpoint\n# The server does not remember anything about the client. \n# Every request must contain all necessary information (like the name).\napp = Flask(__name__)\n\n@app.route('/api/greet')\ndef greet():\n    name = request.args.get('name', 'Guest') # Get name from query parameter\n    # No session state is stored on the server.\n    return jsonify({'greeting': f'Hello, {name}!'})\n\n\nimport requests\n\n# Example 2: Client request to the stateless endpoint\n# The client sends two independent requests. The server processes each without any memory of the previous one.\nprint('--- Example 2: Interacting with a stateless API ---')\nresponse1 = requests.get('http://127.0.0.1:5000/api/greet?name=Alice')\nif response1.status_code == 200:\n    print(f\"First Response: {response1.json()['greeting']}\")\n\nresponse2 = requests.get('http://127.0.0.1:5000/api/greet') # No name provided\nif response2.status_code == 200:\n    print(f\"Second Response: {response2.json()['greeting']}\")"
          },
          {
            "id": "t3-http-methods",
            "title": "HTTP Methods (Verbs)",
            "desc": "Explore the standard HTTP methods (GET, POST, PUT, DELETE) and their semantic meaning in REST APIs.",
            "note": "In a RESTful API, HTTP methods, often called 'verbs', define the action to be performed on a resource. Using these methods semantically is crucial for creating a clear and predictable API. The primary methods are: 1. **GET**: Used to retrieve data. A GET request should only fetch data and have no other effect (this property is known as 'idempotence' and 'safety'). For example, `GET /users/123` retrieves the user with ID 123. 2. **POST**: Used to create a new resource. A POST request submits data to the server, which then creates a new entity. For example, `POST /users` would create a new user with the data provided in the request body. POST is not idempotent; making the same POST request multiple times will create multiple new resources. 3. **PUT**: Used to update an existing resource completely. A PUT request replaces the entire resource at a specific URI with the data provided in the request body. If the resource doesn't exist, PUT can be configured to create it. For instance, `PUT /users/123` replaces the entire user 123 record. PUT is idempotent; making the same PUT request multiple times has the same effect as making it once. 4. **PATCH**: Used for partial updates to an existing resource. Unlike PUT, PATCH only modifies the fields specified in the request body, leaving other fields unchanged. For example, `PATCH /users/123` could be used to update only the user's email address. 5. **DELETE**: Used to remove a resource. A DELETE request to a specific URI, like `DELETE /users/123`, will delete the user with ID 123. DELETE operations are idempotent. Other less common but useful methods include HEAD (fetches headers without the body), OPTIONS (describes communication options for the target resource), and TRACE (performs a message loop-back test).",
            "code": "from flask import Flask, jsonify, request\n\n# Example 1: Flask app demonstrating different HTTP methods\napp = Flask(__name__)\n\n# In-memory data store for demonstration\nusers = { '1': {'name': 'Alice', 'email': 'alice@example.com'} }\n\n@app.route('/api/users/1', methods=['GET', 'PUT', 'DELETE'])\ndef handle_user(user_id='1'):\n    if request.method == 'GET':\n        return jsonify(users.get(user_id, {}))\n    elif request.method == 'PUT':\n        users[user_id] = request.json\n        return jsonify({'message': 'User updated successfully', 'user': users[user_id]})\n    elif request.method == 'DELETE':\n        if user_id in users:\n            del users[user_id]\n            return jsonify({'message': 'User deleted'})\n        return jsonify({'error': 'User not found'}), 404\n\n\nimport requests\nimport json\n\n# Example 2: Using 'requests' to interact with the Flask API\nBASE_URL = 'http://127.0.0.1:5000/api'\n\nprint('--- Example 2: Testing HTTP methods ---')\n# GET\nget_res = requests.get(f'{BASE_URL}/users/1')\nprint(f\"GET Response: {get_res.json()}\")\n\n# PUT\nupdated_user = {'name': 'Alice Smith', 'email': 'alice.s@example.com'}\nput_res = requests.put(f'{BASE_URL}/users/1', json=updated_user)\nprint(f\"PUT Response: {put_res.json()}\")\n\n# DELETE\ndel_res = requests.delete(f'{BASE_URL}/users/1')\nprint(f\"DELETE Response: {del_res.json()}\")"
          },
          {
            "id": "t4-endpoints-uri",
            "title": "Endpoints and URIs",
            "desc": "Learn how to design clean, predictable, and hierarchical URIs for your API resources.",
            "note": "In the context of a REST API, a URI (Uniform Resource Identifier), or more specifically an endpoint, is the address used to identify and access a resource. Well-designed URIs are crucial for a good developer experience; they should be intuitive, predictable, and easy to understand. Several best practices guide URI design. First, URIs should represent resources, not actions. This means using nouns instead of verbs. For example, use `/users/123` to identify a specific user, not `/getUserById?id=123`. The action to be performed on that resource is determined by the HTTP method (e.g., GET to retrieve, DELETE to remove). Second, use plural nouns for collections to maintain consistency. For example, `/users` represents the collection of all users, and `/users/123` represents a specific user within that collection. Third, maintain a clear and consistent hierarchy to represent relationships. For instance, to get all articles written by user 123, a logical URI would be `/users/123/articles`. This structure is easy to read and follows a natural path. Finally, use hyphens (`-`) to improve the readability of long path segments (e.g., `/api/user-profiles`) and stick to lowercase letters to avoid case-sensitivity issues, which can cause confusion and errors. The goal is to create a URI structure that is stable and doesn't change over time, even if the underlying implementation of the API does. A well-designed URI is a fundamental part of creating a clean, professional, and easy-to-use API.",
            "code": "from flask import Flask, jsonify\n\n# Example 1: Flask app with well-designed, resource-oriented URIs\napp = Flask(__name__)\n\n# Data for demonstration\nposts = {'1': {'author_id': 'user1', 'content': 'First post'}}\nauthors = {'user1': {'name': 'John Doe'}}\n\n# URI for a collection of posts\n@app.route('/api/posts', methods=['GET'])\ndef get_posts():\n    return jsonify(posts)\n\n# URI for a specific post\n@app.route('/api/posts/<post_id>', methods=['GET'])\ndef get_post_by_id(post_id):\n    return jsonify(posts.get(post_id, {}))\n\n# Hierarchical URI to get the author of a specific post\n@app.route('/api/posts/<post_id>/author', methods=['GET'])\ndef get_author_of_post(post_id):\n    post = posts.get(post_id)\n    if post:\n        author_id = post['author_id']\n        return jsonify(authors.get(author_id, {}))\n    return jsonify({'error': 'Post not found'}), 404\n\n\nimport requests\n\n# Example 2: Client consuming the well-designed URIs\nBASE_URL = 'http://127.0.0.1:5000/api'\n\nprint('--- Example 2: Consuming resource-oriented URIs ---')\n# Get all posts\nall_posts_res = requests.get(f'{BASE_URL}/posts')\nprint(f'All Posts: {all_posts_res.json()}')\n\n# Get a specific post\nspecific_post_res = requests.get(f'{BASE_URL}/posts/1')\nprint(f'Post 1: {specific_post_res.json()}')\n\n# Get the author of that post\nauthor_res = requests.get(f'{BASE_URL}/posts/1/author')\nprint(f'Author of Post 1: {author_res.json()}')"
          }
        ]
      },
      {
        "id": "c2-json-data",
        "title": "Day 2: JSON & Data Handling",
        "desc": "Master JSON, the de facto standard for API data exchange. Learn serialization, parsing, and data validation.",
        "notes": "On day two, we focus on the data itself. JSON (JavaScript Object Notation) is a lightweight, human-readable data-interchange format that has become the standard for APIs. We'll cover its syntax and data types. More importantly, we'll practice the two fundamental operations: serialization (converting a data structure, like a Python dictionary, into a JSON string to send over the network) and deserialization or parsing (converting a JSON string received from an API back into a native data structure). We will also introduce the concept of data validation—ensuring that the data received by your API is in the correct format and meets specific criteria before processing it. This is a critical step for building robust and secure applications.",
        "duration": "1 day",
        "topics": [
          {
            "id": "t5-intro-json",
            "title": "Introduction to JSON",
            "desc": "Understand the syntax, data types (string, number, boolean, array, object), and role of JSON in APIs.",
            "note": "JSON (JavaScript Object Notation) is the most widely used data format for data exchange on the web, especially in the context of REST APIs. Its popularity stems from its simplicity and readability for both humans and machines. The syntax is derived from JavaScript object literal notation but is language-independent, with parsers available for nearly every programming language. JSON is built on two primary structures: 1. **A collection of name/value pairs**: In most languages, this is realized as an object, dictionary, or hash map. An object is an unordered set of key-value pairs, where the key is a string and the value can be any valid JSON data type. The object is enclosed in curly braces `{}`. 2. **An ordered list of values**: This is realized as an array or list, enclosed in square brackets `[]`. The values in the array can be of any JSON data type. JSON supports a few fundamental data types: **strings** (in double quotes), **numbers** (integer or floating-point), **booleans** (`true` or `false`), **arrays** (an ordered collection of values), **objects** (an unordered collection of key/value pairs), and the value `null`. Because of its lightweight nature and close mapping to common data structures in programming languages, it's an ideal choice for transmitting data between a server and a web application, serving as a more efficient alternative to XML. When an API returns data, it's typically formatted as a JSON string. The client application then parses this string into a native data object to easily access and manipulate the data.",
            "code": "import json\n\n# Example 1: Serializing a Python dictionary to a JSON string\n# This process is called serialization or encoding.\nprint('--- Example 1: Python Dict to JSON String ---')\ndata_dict = {\n    'name': 'John Doe',\n    'age': 30,\n    'isStudent': False,\n    'courses': [\n        {'title': 'History', 'credits': 3},\n        {'title': 'Math', 'credits': 4}\n    ],\n    'address': None\n}\n\n# json.dumps() converts a Python object into a JSON formatted string.\n# The 'indent' parameter makes the output human-readable.\njson_string = json.dumps(data_dict, indent=2)\nprint('Serialized JSON String:')\nprint(json_string)\nprint(f'Type of result: {type(json_string)}')\n\n\n# Example 2: Deserializing a JSON string to a Python dictionary\n# This process is called deserialization or decoding.\nprint('\\n--- Example 2: JSON String to Python Dict ---')\njson_data_from_api = '{\"id\": \"user123\", \"username\": \"jane_doe\", \"isActive\": true, \"roles\": [\"editor\", \"viewer\"]}'\n\n# json.loads() parses a JSON string and converts it into a Python dictionary.\npython_dict = json.loads(json_data_from_api)\nprint('Deserialized Python Dictionary:')\nprint(python_dict)\nprint(f'Type of result: {type(python_dict)}')\n# Now you can access data using standard dictionary syntax.\nprint(f\"Username: {python_dict['username']}\")"
          },
          {
            "id": "t6-json-requests",
            "title": "Crafting JSON Requests",
            "desc": "Learn to send data to an API by including a JSON payload in POST and PUT requests.",
            "note": "While GET requests are used to retrieve data, POST and PUT requests are used to send data to an API, either to create a new resource or update an existing one. This data is typically sent in the 'body' of the HTTP request, and the most common format for this payload is JSON. When sending a JSON payload, two things are crucial. First, the data itself must be a correctly formatted JSON string. In client-side code, like a Python script using the `requests` library, you would typically construct a dictionary and let the library handle the serialization into a JSON string. Second, you must set the `Content-Type` header of the request to `application/json`. This header tells the server what kind of data to expect in the request body so it can parse it correctly. If this header is missing or incorrect, the server might fail to understand the request, leading to a `400 Bad Request` or `415 Unsupported Media Type` error. The server-side application (e.g., one built with Flask or FastAPI) is then responsible for receiving this request, reading the `Content-Type` header, and using a JSON parser to deserialize the request body back into a native data structure (like a dictionary) that can be easily worked with. Properly crafting JSON requests is a fundamental skill for interacting with virtually any modern API that involves data creation or modification.",
            "code": "from flask import Flask, request, jsonify\n\n# Example 1: Flask server that handles incoming JSON data\napp = Flask(__name__)\n\n@app.route('/api/items', methods=['POST'])\ndef create_item():\n    # request.is_json checks if the Content-Type header is 'application/json'\n    if request.is_json:\n        data = request.get_json() # Parses the incoming JSON into a Python dict\n        item_name = data.get('name')\n        item_price = data.get('price')\n        if not item_name or not item_price:\n            return jsonify({'error': 'Missing name or price'}), 400\n        \n        # In a real app, you would save this to a database.\n        print(f'Received new item: {item_name} at price {item_price}')\n        return jsonify({'message': 'Item created successfully', 'item': data}), 201\n    else:\n        return jsonify({'error': 'Request must be JSON'}), 415\n\n\nimport requests\nimport json\n\n# Example 2: Client sending a POST request with a JSON payload\nprint('--- Example 2: Sending JSON data to an API ---')\nAPI_URL = 'http://127.0.0.1:5000/api/items'\n\n# The data we want to send, as a Python dictionary\nnew_item = {\n    'name': 'Laptop',\n    'price': 1200.50,\n    'category': 'Electronics'\n}\n\n# The 'requests' library automatically sets the Content-Type header to 'application/json'\n# and serializes the dictionary when using the 'json' parameter.\nresponse = requests.post(API_URL, json=new_item)\n\nprint(f'Status Code: {response.status_code}')\nif response.status_code == 201:\n    print('Response JSON:')\n    print(json.dumps(response.json(), indent=2))\nelse:\n    print(f'Error: {response.text}')"
          },
          {
            "id": "t7-json-responses",
            "title": "Parsing JSON Responses",
            "desc": "Effectively handle and extract data from JSON responses returned by an API.",
            "note": "After a client sends a request to an API, the server processes it and sends back an HTTP response. This response consists of a status code, headers, and often a body containing data. For REST APIs, this body is typically a JSON string. The first step for a client is to check the HTTP status code to determine if the request was successful. A code in the `2xx` range (e.g., `200 OK`, `201 Created`) indicates success, while codes in the `4xx` range (e.g., `404 Not Found`, `400 Bad Request`) indicate a client error, and `5xx` codes indicate a server error. If the request was successful, the next step is to parse the JSON body. Most HTTP client libraries, like Python's `requests`, provide a convenient helper method (e.g., `response.json()`) that handles this for you. This method reads the response body, verifies that it's valid JSON, and deserializes it into a native data structure (a dictionary or list in Python). Once the JSON is parsed, you can access the data within it just like you would with any other dictionary or list in your programming language, using keys or indices to retrieve specific values. It's also good practice to wrap data access in error handling (like a `try...except` block) in case the API response doesn't contain the expected keys, which can happen if the API is updated or if there was an unexpected issue. Properly parsing and handling JSON responses is essential for building applications that consume API data.",
            "code": "from flask import Flask, jsonify\n\n# Example 1: Flask server that returns a JSON response\napp = Flask(__name__)\n\n@app.route('/api/products/123', methods=['GET'])\ndef get_product():\n    # This data would typically come from a database\n    product_data = {\n        'id': 123,\n        'name': 'Wireless Mouse',\n        'price': 25.99,\n        'in_stock': True,\n        'specs': {\n            'dpi': 1600,\n            'connectivity': 'Bluetooth'\n        }\n    }\n    return jsonify(product_data)\n\n\nimport requests\nimport json\n\n# Example 2: Client that receives and parses a JSON response\nprint('--- Example 2: Parsing a JSON response from an API ---')\nAPI_URL = 'http://127.0.0.1:5000/api/products/123'\n\nresponse = requests.get(API_URL)\n\n# Step 1: Check the status code\nif response.status_code == 200:\n    print('Request successful!')\n    # Step 2: Use the .json() method to parse the response\n    data = response.json()\n    \n    print('\\n--- Parsed Data ---')\n    print(json.dumps(data, indent=2))\n    \n    # Step 3: Access specific data points from the parsed object\n    print('\\n--- Accessing Specific Data ---')\n    product_name = data.get('name')\n    product_price = data.get('price')\n    connectivity_type = data.get('specs', {}).get('connectivity')\n\n    print(f'Product Name: {product_name}')\n    print(f'Price: ${product_price}')\n    print(f'Connectivity: {connectivity_type}')\nelse:\n    print(f'Request failed with status code: {response.status_code}')"
          },
          {
            "id": "t8-data-validation",
            "title": "Data Validation with Pydantic",
            "desc": "Ensure data integrity by validating incoming API requests using Pydantic in FastAPI.",
            "note": "Receiving data from clients is a major vulnerability point for any application. A user might send malformed data, incorrect data types, or leave out required fields. Processing such invalid data can lead to bugs, crashes, and security vulnerabilities. Therefore, data validation—the process of ensuring that incoming data is correct, complete, and secure—is not optional; it's a necessity. While you can write manual validation logic (e.g., a series of `if` statements to check for keys and types), this can become tedious, error-prone, and hard to maintain. This is where data validation libraries shine. Pydantic is a popular Python library that uses type annotations to validate data. You define the 'shape' of your expected data as a class, specifying the fields and their types. Pydantic then automatically parses and validates incoming data against that shape. If the data is valid, it returns a clean, type-coerced model object. If it's invalid, it raises a detailed validation error, indicating exactly what was wrong. The FastAPI framework has first-class support for Pydantic. You can simply use your Pydantic model as a type hint in your endpoint's parameters, and FastAPI will automatically handle the request body parsing, validation, and error reporting. This declarative approach makes your code cleaner, more robust, and self-documenting, as the Pydantic model itself clearly defines the API's expected input.",
            "code": "from fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Optional\n\n# Example 1: FastAPI app using a Pydantic model for validation\n# To run: 'pip install fastapi uvicorn pydantic', then 'uvicorn filename:app --reload'\napp = FastAPI()\n\n# Define the 'shape' of the expected data using a Pydantic model.\n# This model specifies that 'name' is a required string, 'price' is a required float,\n# and 'description' is an optional string.\nclass Item(BaseModel):\n    name: str\n    price: float\n    description: Optional[str] = None\n\n@app.post('/api/items_validated/')\nasync def create_item_validated(item: Item):\n    # If the request body doesn't match the Item model, FastAPI automatically\n    # returns a 422 Unprocessable Entity error with details.\n    # If validation passes, 'item' is a Pydantic model instance.\n    return {\"message\": \"Item received successfully\", \"item_data\": item.dict()}\n\n\nimport requests\nimport json\n\n# Example 2: Client sending valid and invalid data to the FastAPI endpoint\nBASE_URL = 'http://127.0.0.1:8000/api'\n\nprint('--- Example 2: Testing data validation ---')\n\n# --- Test Case 1: Sending VALID data ---\nprint('\\n--- Sending valid data ---')\nvalid_item = {'name': 'Pen', 'price': 1.99}\nresponse_valid = requests.post(f'{BASE_URL}/items_validated/', json=valid_item)\nprint(f'Status Code: {response_valid.status_code}')\nprint(f'Response: {json.dumps(response_valid.json(), indent=2)}')\n\n# --- Test Case 2: Sending INVALID data (price is a string) ---\nprint('\\n--- Sending invalid data (wrong type) ---')\ninvalid_item = {'name': 'Notebook', 'price': 'ten dollars'}\nresponse_invalid = requests.post(f'{BASE_URL}/items_validated/', json=invalid_item)\nprint(f'Status Code: {response_invalid.status_code}')\n# FastAPI will return a 422 status code with a detailed error message.\nprint(f'Response: {json.dumps(response_invalid.json(), indent=2)}')"
          }
        ]
      },
      {
        "id": "c3-auth-security",
        "title": "Day 3: Authentication & Security",
        "desc": "Secure your API. Implement API Key and JWT-based authentication to protect your endpoints.",
        "notes": "An unprotected API is a massive security risk. Day three is all about securing your endpoints to ensure that only authorized clients can access them. We'll start with the simplest form of protection: API Key authentication. This method is straightforward and effective for many use cases. Then, we will dive into a more robust, token-based authentication standard: JSON Web Tokens (JWT). We'll explore the structure of a JWT and understand how this stateless mechanism can be used to manage user sessions in a scalable way. We will also briefly touch on the concepts of OAuth 2.0, a widely used authorization framework, to give you a broader understanding of the API security landscape. By the end of the day, you'll be able to implement fundamental security layers for your APIs.",
        "duration": "1 day",
        "topics": [
          {
            "id": "t9-api-key",
            "title": "API Key Authentication",
            "desc": "Implement a basic but effective security layer using static API keys sent in request headers.",
            "note": "API Key authentication is one of the simplest and most common methods for securing an API. The basic principle is that the server issues a unique, secret string of characters (the API key) to each authorized client. The client must then include this key in every request it makes to protected endpoints. The server, upon receiving a request, checks for the presence and validity of the API key. If the key is valid, the request is processed; otherwise, it's rejected, typically with a `401 Unauthorized` or `403 Forbidden` status code. The key is usually sent in a custom HTTP header, such as `X-API-Key` or `Authorization: ApiKey <key>`. Sending the key in a header is generally preferred over sending it in the URL as a query parameter, as URLs are often logged, potentially exposing the key. While simple to implement, API key authentication has its limitations. The keys are often long-lived and, if compromised, can grant an attacker full access until the key is manually revoked. It's primarily an authentication mechanism (identifying the calling application), not an authorization mechanism (determining what the application is allowed to do). Despite these drawbacks, it's an excellent choice for public APIs with usage tiers, internal microservice communication, or any scenario where a simple, shared secret is sufficient to grant access.",
            "code": "from flask import Flask, request, jsonify\n\n# Example 1: Flask app protected by a simple API key\napp = Flask(__name__)\n\n# In a real app, keys would be stored securely, not hardcoded.\nVALID_API_KEY = 'my-super-secret-key'\n\n@app.route('/api/secure-data')\ndef get_secure_data():\n    api_key = request.headers.get('X-API-Key')\n    if api_key and api_key == VALID_API_KEY:\n        return jsonify({'message': 'This is secure data.', 'data': [1, 2, 3]})\n    else:\n        return jsonify({'error': 'Unauthorized. Invalid or missing API Key.'}), 401\n\n\nimport requests\n\n# Example 2: Client accessing the protected endpoint with and without an API key\nBASE_URL = 'http://127.0.0.1:5000/api'\nVALID_KEY = 'my-super-secret-key'\n\nprint('--- Example 2: Testing API Key Authentication ---')\n\n# --- Test Case 1: Request without API Key ---\nprint('\\n--- Request with no key ---')\nresponse_no_key = requests.get(f'{BASE_URL}/secure-data')\nprint(f'Status: {response_no_key.status_code}, Response: {response_no_key.json()}')\n\n# --- Test Case 2: Request with an invalid API Key ---\nprint('\\n--- Request with invalid key ---')\ninvalid_headers = {'X-API-Key': 'wrong-key'}\nresponse_invalid_key = requests.get(f'{BASE_URL}/secure-data', headers=invalid_headers)\nprint(f'Status: {response_invalid_key.status_code}, Response: {response_invalid_key.json()}')\n\n# --- Test Case 3: Request with the valid API Key ---\nprint('\\n--- Request with valid key ---')\nvalid_headers = {'X-API-Key': VALID_KEY}\nresponse_valid = requests.get(f'{BASE_URL}/secure-data', headers=valid_headers)\nprint(f'Status: {response_valid.status_code}, Response: {response_valid.json()}')"
          },
          {
            "id": "t10-jwt-intro",
            "title": "Introduction to JWT",
            "desc": "Understand the structure (Header, Payload, Signature) and purpose of JSON Web Tokens.",
            "note": "JSON Web Tokens (JWT), pronounced 'jot', are an open, industry-standard (RFC 7519) method for securely representing claims between two parties. They are a cornerstone of modern stateless authentication. A JWT is a compact, URL-safe string that consists of three parts separated by dots (`.`): 1. **Header**: This part typically consists of two fields: the token type (`typ`), which is `JWT`, and the signing algorithm (`alg`) being used, such as HMAC SHA256 (`HS256`) or RSA. The header is then Base64Url encoded to form the first part of the JWT. 2. **Payload**: This part contains the 'claims'. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private. Registered claims are a predefined set of claims like `iss` (issuer), `exp` (expiration time), and `sub` (subject). Public claims are defined by those using JWTs, but should be defined in the IANA JSON Web Token Registry or be a URI to avoid collisions. Private claims are custom claims created to share information between parties that agree on using them. The payload is also Base64Url encoded. 3. **Signature**: To create the signature, you take the encoded header, the encoded payload, a secret key, and the algorithm specified in the header, and sign them. For example, if you are using HS256, the signature is created by `HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret)`. The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way. Because the token is signed, it is tamper-proof. The server can verify the signature and trust the claims within the payload, making JWTs a powerful tool for building stateless, scalable authentication systems.",
            "code": "import jwt\nimport datetime\n\n# Example 1: Creating (encoding) a JWT\n# To run: 'pip install PyJWT'\nprint('--- Example 1: Creating a JWT ---')\n\n# The secret key should be kept private and secure in a real application.\nSECRET_KEY = 'my-jwt-secret'\n\n# The payload contains the claims about the user.\npayload_data = {\n    'sub': '1234567890', # Subject (user ID)\n    'name': 'John Doe',\n    'admin': True,\n    'iat': datetime.datetime.utcnow(), # Issued at\n    'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=30) # Expiration time\n}\n\n# Encode the payload into a JWT string.\nencoded_jwt = jwt.encode(\n    payload=payload_data,\n    key=SECRET_KEY,\n    algorithm='HS256'\n)\n\nprint(f'Generated JWT: {encoded_jwt}')\n\n\n# Example 2: Decoding and verifying a JWT\nprint('\\n--- Example 2: Decoding a JWT ---')\n\n# In a server, you would receive this token from the client's Authorization header.\ntoken_to_verify = encoded_jwt\n\ntry:\n    # The decode function automatically verifies the signature and expiration time.\n    # If the signature is invalid or the token is expired, it will raise an exception.\n    decoded_payload = jwt.decode(\n        jwt=token_to_verify, \n        key=SECRET_KEY, \n        algorithms=['HS256']\n    )\n    print('Token is valid!')\n    print('Decoded Payload:')\n    print(decoded_payload)\nexcept jwt.ExpiredSignatureError:\n    print('Token has expired!')\nexcept jwt.InvalidTokenError:\n    print('Invalid token!')"
          },
          {
            "id": "t11-jwt-fastapi",
            "title": "Implementing JWT in FastAPI",
            "desc": "Create a login endpoint to issue JWTs and a protected endpoint that requires a valid token.",
            "note": "Implementing JWT authentication in a web framework like FastAPI involves a few key steps. First, you need an endpoint, typically `/login` or `/token`, where a user can authenticate with their credentials (e.g., username and password). Upon successful verification of credentials, this endpoint generates a JWT containing claims about the user (like their ID and roles) and an expiration time. This token is then returned to the client. Second, the client must store this token securely (e.g., in memory or `localStorage` in a browser) and send it with every subsequent request to protected endpoints. The standard way to send the token is in the `Authorization` header, using the `Bearer` schema: `Authorization: Bearer <your-jwt-here>`. Third, you need to create protected endpoints that require this token. In FastAPI, this is typically done using dependencies. You create a dependency function that extracts the token from the `Authorization` header, decodes it, and verifies its signature and claims (like expiration). If the token is invalid or missing, the dependency raises an `HTTPException`, immediately stopping the request and returning a `401 Unauthorized` error. If the token is valid, the dependency can return the payload (e.g., the user ID), which the protected endpoint can then use to perform its logic. This pattern provides a clean and reusable way to secure multiple routes, ensuring that only authenticated users can access sensitive data or perform privileged actions. This stateless approach is highly scalable, as the server doesn't need to maintain a session store; it just needs to verify the token on each request.",
            "code": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nimport jwt\nfrom datetime import datetime, timedelta\n\n# Example 1: FastAPI app with JWT authentication\n# Note: This is a simplified example. A real app would have password hashing and a user database.\napp = FastAPI()\n\nSECRET_KEY = 'your-very-secret-key'\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl='token')\n\nclass User(BaseModel):\n    username: str\n\n@app.post('/token')\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    # In a real app, you'd verify form_data.username and form_data.password against a DB.\n    if form_data.username == 'testuser' and form_data.password == 'testpass':\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n        to_encode = {'sub': form_data.username, 'exp': expire}\n        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n        return {'access_token': encoded_jwt, 'token_type': 'bearer'}\n    raise HTTPException(status_code=400, detail='Incorrect username or password')\n\n@app.get('/users/me')\nasync def read_users_me(token: str = Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get('sub')\n        if username is None:\n            raise HTTPException(status_code=401, detail='Could not validate credentials')\n        return {'username': username}\n    except jwt.PyJWTError:\n        raise HTTPException(status_code=401, detail='Could not validate credentials')\n\n\nimport requests\n\n# Example 2: Client script to log in and access a protected route\nBASE_URL = 'http://127.0.0.1:8000'\n\nprint('--- Example 2: Authenticating with JWT ---')\n\n# --- Step 1: Log in to get the token ---\nlogin_payload = {'username': 'testuser', 'password': 'testpass'}\nlogin_res = requests.post(f'{BASE_URL}/token', data=login_payload)\n\nif login_res.status_code == 200:\n    token_data = login_res.json()\n    access_token = token_data['access_token']\n    print('Login successful! Token received.')\n\n    # --- Step 2: Use the token to access a protected route ---\n    headers = {'Authorization': f'Bearer {access_token}'}\n    profile_res = requests.get(f'{BASE_URL}/users/me', headers=headers)\n    \n    if profile_res.status_code == 200:\n        print('Successfully accessed protected route:')\n        print(profile_res.json())\n    else:\n        print(f'Failed to access protected route. Status: {profile_res.status_code}')\nelse:\n    print('Login failed.')\n    print(login_res.json())"
          },
          {
            "id": "t12-oauth-intro",
            "title": "Understanding OAuth 2.0 (Conceptual)",
            "desc": "Get a high-level overview of the OAuth 2.0 authorization framework, its roles, and common grant types.",
            "note": "OAuth 2.0 is not an authentication protocol; it's an authorization framework. Its primary purpose is to enable a third-party application to obtain limited access to a user's resources on another service, without exposing the user's credentials (like their password) to the third-party app. Think of it as a valet key for your car: you can give the valet a key that only allows them to drive the car, not open the trunk or glove compartment. In the OAuth 2.0 world, there are four key roles: 1. **Resource Owner**: The user who owns the data and can grant access to it. 2. **Client**: The third-party application that wants to access the Resource Owner's data. 3. **Authorization Server**: The server that authenticates the Resource Owner and issues access tokens after getting their consent. 4. **Resource Server**: The server that hosts the user's data (the API) and accepts the access tokens. The process, known as a 'flow' or 'grant type', generally works like this: The Client redirects the user to the Authorization Server. The user logs in and gives consent. The Authorization Server redirects the user back to the Client with an 'authorization code'. The Client then exchanges this code (along with its own client ID and secret) with the Authorization Server to get an 'access token'. Finally, the Client uses this access token to make requests to the Resource Server to access the user's data. The most common grant type is the 'Authorization Code' grant, described above, which is ideal for traditional web applications. Other grant types exist for different scenarios, like the 'Implicit' grant for single-page apps and the 'Client Credentials' grant for service-to-service communication.",
            "code": "from flask import Flask, request, jsonify\n\n# Example 1: Conceptual server-side callback endpoint for OAuth\n# This is a highly simplified demonstration of the final step in an OAuth flow.\napp = Flask(__name__)\n\n@app.route('/oauth/callback')\ndef oauth_callback():\n    # In a real flow, the Authorization Server redirects the user here with a code.\n    auth_code = request.args.get('code')\n    if not auth_code:\n        return jsonify({'error': 'Authorization code not found'}), 400\n\n    print(f'Received authorization code: {auth_code}')\n    # --- Next steps in a real application ---\n    # 1. Exchange this 'auth_code' with the Authorization Server for an access token.\n    #    This involves a secure, server-to-server POST request.\n    # 2. Receive the access token and optionally a refresh token.\n    # 3. Store the tokens securely, associated with the user's session.\n    # 4. Use the access token to make API calls on behalf of the user.\n\n    return jsonify({'message': 'Successfully received auth code. Token exchange would happen next.'})\n\n\nimport requests\nfrom requests_oauthlib import OAuth2Session\n\n# Example 2: Conceptual client-side initiation of an OAuth flow\n# This code does not run on its own but illustrates how a client library is used.\n# To install: 'pip install requests_oauthlib'\nprint('--- Example 2: Conceptual Client-Side OAuth Flow ---')\n\n# --- Step 1: Prepare OAuth session ---\n# These would be provided by the service you're connecting to (e.g., Google, GitHub).\nclient_id = 'YOUR_CLIENT_ID'\nclient_secret = 'YOUR_CLIENT_SECRET'\nredirect_uri = 'http://127.0.0.1:5000/oauth/callback' \nauthorization_base_url = 'https://provider.com/auth' # Fictional URL\n\n# Create a session object.\n# The 'scope' defines the permissions the application is requesting.\nscope = ['read:user', 'read:repos']\noauth_session = OAuth2Session(client_id, redirect_uri=redirect_uri, scope=scope)\n\n# --- Step 2: Generate the authorization URL ---\n# The user must be redirected to this URL to log in and grant consent.\nauthorization_url, state = oauth_session.authorization_url(authorization_base_url)\n\nprint('Please go to this URL and authorize access:')\nprint(authorization_url)\nprint('\\nAfter authorization, the user will be redirected to your callback URL with a code.')"
          }
        ]
      },
      {
        "id": "c4-api-testing",
        "title": "Day 4: API Testing",
        "desc": "Learn to thoroughly test your API, from manual testing with Postman to automated testing with Pytest.",
        "notes": "Building an API is only half the battle; ensuring it works correctly, reliably, and as expected is equally important. Day four is dedicated to API testing. We'll start with manual testing using dedicated API clients like Postman or Insomnia. These tools are indispensable for development, allowing you to quickly craft and send requests, inspect responses, and debug issues. Next, we'll transition to automated testing using Python's `pytest` framework. Automated tests are crucial for maintaining code quality over time, preventing regressions, and enabling continuous integration. We will cover how to write tests that check for correct data, proper HTTP status codes, and effective error handling. Finally, we'll touch on more advanced concepts like mocking to isolate your tests from external dependencies, ensuring they are fast and reliable.",
        "duration": "1 day",
        "topics": [
          {
            "id": "t13-postman-manual",
            "title": "Manual Testing with Postman/Insomnia",
            "desc": "Use API clients like Postman to manually send requests, inspect responses, and debug your endpoints.",
            "note": "While automated tests are the gold standard for reliability, manual testing is an essential part of the development workflow. API clients like Postman and Insomnia provide a graphical user interface that makes it incredibly easy to interact with APIs without writing any code. These tools are invaluable for several reasons. First, during development, they allow for rapid exploration and debugging. You can quickly build a request for a new endpoint you're working on, tweak the parameters, headers, and body, and immediately see the server's response, including the status code, headers, and body content. This instant feedback loop is much faster than writing a client script for every small change. Second, they are excellent for exploratory testing. You can easily test edge cases, send malformed data to see how the API handles errors, and check authentication and authorization flows. Third, these tools offer advanced features like creating collections of requests, which can be saved and shared with your team, effectively serving as executable API documentation. They also support environment variables, allowing you to easily switch between different environments (e.g., local development, staging, production) by changing variables like the base URL or API keys. Learning to use an API client effectively will significantly boost your productivity and help you build more robust APIs.",
            "code": "# This topic is conceptual and focuses on using an external tool.\n# The 'code' block will contain instructions for using Postman.\n\n# --- Example 1: Testing a GET request in Postman ---\n# 1. Open Postman and create a new request.\n# 2. Set the HTTP Method to 'GET'.\n# 3. In the URL bar, enter the address of an endpoint. For example, if you have a local Flask or FastAPI server running, use: http://127.0.0.1:5000/api/users\n# 4. Click the 'Send' button.\n# 5. In the bottom panel, inspect the 'Body' tab to see the JSON response, the 'Headers' tab to see response headers, and the 'Status' code to verify it (e.g., 200 OK).\n\n\n# --- Example 2: Testing a POST request with a JSON body in Postman ---\n# 1. Create another new request in Postman.\n# 2. Set the HTTP Method to 'POST'.\n# 3. Enter the URL for the creation endpoint, e.g., http://127.0.0.1:5000/api/users\n# 4. Go to the 'Body' tab below the URL bar.\n# 5. Select the 'raw' radio button and from the dropdown menu on the right, choose 'JSON'.\n# 6. Enter your JSON payload in the text area, for example:\n#    {\n#        \"name\": \"Jane Doe\",\n#        \"email\": \"jane.doe@example.com\"\n#    }\n# 7. Go to the 'Headers' tab. Postman usually adds the 'Content-Type: application/json' header automatically when you select JSON in the body, but it's good practice to verify it's there.\n# 8. Click 'Send' and inspect the response, expecting a '201 Created' status and the newly created resource in the body."
          },
          {
            "id": "t14-pytest-auto",
            "title": "Automated Testing with Pytest",
            "desc": "Write automated tests for your API endpoints using the Pytest framework to ensure reliability.",
            "note": "Automated testing is the process of writing code to test your application code and then running those tests automatically. This practice is fundamental to modern software development for several reasons. It provides a safety net that catches bugs and regressions before they reach production. Whenever you make a change, you can run your test suite to get immediate feedback on whether your change broke existing functionality. This confidence allows you to refactor code and add new features more quickly. For API testing, `pytest` is a popular, powerful, and easy-to-use framework in the Python ecosystem. The typical workflow involves creating a separate test file (e.g., `test_api.py`) where you write test functions. Each test function should focus on a specific piece of functionality. Inside a test function, you use an HTTP client like the `requests` library to make a call to your running API application. Then, you use `assert` statements to check that the response is what you expected. You might assert that the status code is `200`, that the `Content-Type` header is `application/json`, and that the data in the response body is correct. `Pytest` has a rich ecosystem of plugins, such as `pytest-flask` or `pytest-fastapi`, which provide fixtures and utilities to make testing even easier, such as providing a test client that can call your application without needing to run a live server. Integrating automated tests into your development process is a critical investment that pays huge dividends in code quality and maintainability.",
            "code": "from flask import Flask, jsonify\n\n# Example 1: A simple Flask app to be tested\n# Save this as 'main_app.py'\napp = Flask(__name__)\n\n@app.route('/api/ping')\ndef ping():\n    return jsonify({'status': 'ok'})\n\n@app.route('/api/data')\ndef get_data():\n    return jsonify({'items': [1, 2, 3]})\n\n\nimport requests\n\n# Example 2: An automated test script using pytest and requests\n# Save this as 'test_main_app.py'\n# To run: 'pip install pytest requests', then run 'pytest' in your terminal.\n# Make sure the Flask app ('main_app.py') is running in a separate terminal.\nAPI_BASE_URL = 'http://127.0.0.1:5000/api'\n\ndef test_ping_endpoint():\n    \"\"\"Tests the /ping endpoint for status and content.\"\"\"\n    response = requests.get(f'{API_BASE_URL}/ping')\n    # Assert that the request was successful\n    assert response.status_code == 200\n    # Assert that the response body is correct\n    assert response.json() == {'status': 'ok'}\n\ndef test_data_endpoint():\n    \"\"\"Tests the /data endpoint for content and structure.\"\"\"\n    response = requests.get(f'{API_BASE_URL}/data')\n    assert response.status_code == 200\n    response_data = response.json()\n    # Assert that the expected key is in the response\n    assert 'items' in response_data\n    # Assert that the value is a list of the correct length\n    assert isinstance(response_data['items'], list)\n    assert len(response_data['items']) == 3"
          },
          {
            "id": "t15-status-codes",
            "title": "Testing HTTP Status Codes",
            "desc": "Verify that your API returns the correct HTTP status codes for success, client errors, and server errors.",
            "note": "HTTP status codes are a crucial part of the contract of a REST API. They provide a standardized, immediate signal to the client about the outcome of its request. Relying on status codes is far more robust than, for example, checking for a key named `'error'` in a response body that always has a `200 OK` status. Therefore, testing that your API returns the correct status codes under various conditions is essential. Your automated tests should cover a range of scenarios: **Success Codes**: For a successful `GET` or `PUT` request, you should assert that the status code is `200 OK`. For a successful `POST` that creates a new resource, you should assert `201 Created`. For a successful `DELETE` or a request that requires processing but has no content to return, you should assert `204 No Content`. **Client Error Codes**: These indicate that the client did something wrong. You should test that sending a request with missing or invalid data (e.g., a malformed JSON body) returns `400 Bad Request`. Trying to access a resource that requires authentication without providing credentials should return `401 Unauthorized`. Trying to access a protected resource with valid credentials but insufficient permissions should return `403 Forbidden`. Requesting a resource that doesn't exist (e.g., `GET /users/9999`) should return `404 Not Found`. **Server Error Codes**: While harder to test deliberately, it's important that your API's global error handler correctly catches unexpected exceptions and returns a generic `500 Internal Server Error` instead of crashing or leaking stack traces. Thoroughly testing these codes ensures your API is predictable and easy for client developers to work with.",
            "code": "from flask import Flask, jsonify, request\n\n# Example 1: Flask app that returns various status codes\n# Save as 'status_app.py'\napp = Flask(__name__)\n\nitems = {'1': 'Item One'}\n\n@app.route('/api/items/<item_id>', methods=['GET'])\ndef get_item(item_id):\n    if item_id in items:\n        return jsonify({'id': item_id, 'name': items[item_id]}), 200\n    else:\n        return jsonify({'error': 'Item not found'}), 404\n\n@app.route('/api/items', methods=['POST'])\ndef create_item():\n    if not request.json or 'name' not in request.json:\n        return jsonify({'error': 'Missing name in request body'}), 400\n    new_id = str(len(items) + 1)\n    items[new_id] = request.json['name']\n    return jsonify({'id': new_id, 'name': items[new_id]}), 201\n\n\nimport requests\n\n# Example 2: Pytest script to verify the status codes\n# Save as 'test_status_app.py' and run with 'pytest'.\n# Make sure 'status_app.py' is running.\nAPI_BASE_URL = 'http://127.0.0.1:5000/api'\n\ndef test_get_item_success():\n    \"\"\"Test for 200 OK on a successful GET.\"\"\"\n    response = requests.get(f'{API_BASE_URL}/items/1')\n    assert response.status_code == 200\n\ndef test_get_item_not_found():\n    \"\"\"Test for 404 Not Found for a non-existent item.\"\"\"\n    response = requests.get(f'{API_BASE_URL}/items/999')\n    assert response.status_code == 404\n\ndef test_create_item_success():\n    \"\"\"Test for 201 Created on a successful POST.\"\"\"\n    response = requests.post(f'{API_BASE_URL}/items', json={'name': 'New Item'})\n    assert response.status_code == 201\n\ndef test_create_item_bad_request():\n    \"\"\"Test for 400 Bad Request when data is missing.\"\"\"\n    response = requests.post(f'{API_BASE_URL}/items', json={}) # Missing 'name'\n    assert response.status_code == 400"
          },
          {
            "id": "t16-mocking-patching",
            "title": "Mocking and Patching in Tests",
            "desc": "Isolate your tests from external dependencies like databases or third-party APIs using mocks.",
            "note": "Unit tests should be fast, reliable, and test one thing in isolation. However, API endpoints often have dependencies on other systems, such as a database, a cache, or another external API. Calling these real dependencies in your tests is problematic. It makes tests slow, as network or database calls take time. It makes them unreliable, as a test could fail due to a network glitch or a problem with the external service, not because of a bug in your code. It can also be costly or have side effects, like sending real emails or charging a credit card via a payment gateway API. This is where 'mocking' comes in. Mocking is the practice of replacing a real object or function with a 'mock object' during a test. This mock object simulates the behavior of the real object but is completely under your control. For example, instead of having your endpoint make a real database call to fetch a user, you can 'mock' the database function to immediately return a predefined user object. This allows you to test your endpoint's logic (e.g., how it processes the user data) without ever touching the actual database. In Python, the `unittest.mock` library (which is part of the standard library) is the primary tool for this. Its `patch` function allows you to temporarily replace objects within a specific scope (like a single test function). By mocking dependencies, you can create focused unit tests that verify your application's logic in a fast, predictable, and isolated manner.",
            "code": "import requests\nfrom flask import Flask, jsonify\n\n# Example 1: A Flask app that depends on an external service\n# Let's say this function calls a slow, external weather API.\ndef get_current_temperature(city):\n    # In a real scenario, this would make an actual HTTP request.\n    # We simulate it here.\n    print(f'Making a REAL (slow) API call for {city}...')\n    response = requests.get(f'https://api.weather.com/{city}') # This is fictional\n    return response.json()['temp']\n\napp = Flask(__name__)\n\n@app.route('/api/weather/<city>')\ndef weather_report(city):\n    temp = get_current_temperature(city)\n    if temp > 25:\n        report = 'warm'\n    else:\n        report = 'cool'\n    return jsonify({'city': city, 'report': report})\n\n\nfrom unittest.mock import patch\nfrom flask.testing import FlaskClient\n\n# Example 2: Testing the app logic by mocking the external dependency\n# To run: 'pip install pytest flask', save as 'test_weather_app.py', run 'pytest'.\n# We don't need 'requests' here because we are mocking it.\n\n# This is a pytest fixture that provides a test client for our app.\ndef client():\n    return app.test_client()\n\n# The @patch decorator replaces 'get_current_temperature' with a mock object.\ndef test_weather_report_warm(client: FlaskClient):\n    \"\"\"Test that the report is 'warm' when the mocked temperature is high.\"\"\"\n    # 'mock_get_temp' is the mock object passed into our test.\n    # We configure it to return 30 when called.\n    with patch('__main__.get_current_temperature', return_value=30) as mock_get_temp:\n        response = client.get('/api/weather/dubai')\n        # Assert our endpoint's logic works correctly.\n        assert response.status_code == 200\n        assert response.json['report'] == 'warm'\n        # We can also assert that our mock was called as expected.\n        mock_get_temp.assert_called_once_with('dubai')\n\ndef test_weather_report_cool(client: FlaskClient):\n    \"\"\"Test that the report is 'cool' when the mocked temperature is low.\"\"\"\n    with patch('__main__.get_current_temperature', return_value=15) as mock_get_temp:\n        response = client.get('/api/weather/london')\n        assert response.status_code == 200\n        assert response.json['report'] == 'cool'\n        mock_get_temp.assert_called_once_with('london')"
          }
        ]
      },
      {
        "id": "c5-crud-project",
        "title": "Day 5-7: Hands-on CRUD API Project",
        "desc": "Apply everything you've learned by building and testing a complete CRUD API for a resource.",
        "notes": "The final part of the week is a hands-on project to solidify your understanding. We will build a complete CRUD (Create, Read, Update, Delete) API from scratch using FastAPI. This project will integrate all the concepts we've covered: designing RESTful endpoints, handling JSON data, using Pydantic for validation, and writing automated tests with Pytest. We'll use a simple in-memory list of dictionaries as our 'database' to keep the focus on the API logic itself. You will implement four core endpoints corresponding to the four CRUD operations. This practical experience is crucial for transitioning from theoretical knowledge to real-world application. By the end of this project, you will have a fully functional and tested API that you can use as a reference for your future projects.",
        "duration": "3 days",
        "topics": [
          {
            "id": "t17-project-setup-create",
            "title": "Project Setup & Create (POST)",
            "desc": "Set up the FastAPI project and implement the 'Create' functionality with a POST endpoint.",
            "note": "We begin our project by setting up the basic structure for a FastAPI application. We'll create a main application file and define our data model using Pydantic. This model will represent the resource our API manages (e.g., a 'Book' with a title, author, and publication year). For simplicity, our data storage will be a global list of dictionaries, acting as an in-memory database. The first piece of functionality we'll implement is the 'Create' operation. This is handled by a `POST` request. We will create an endpoint, such as `/books`, that accepts a `POST` request. The request body must contain a JSON object matching our Pydantic model. FastAPI will automatically validate this incoming data. If the data is valid, our endpoint logic will assign a new unique ID to the book, add it to our in-memory list, and return the newly created book object to the client. The standard practice is to also return a `201 Created` status code to signal that the resource was created successfully. This first step establishes the foundation of our application and introduces the first of the four core CRUD operations.",
            "code": "from fastapi import FastAPI, status\nfrom pydantic import BaseModel\nfrom typing import List\n\n# Example 1: FastAPI app with project setup and the POST endpoint\n# Save as 'crud_api.py' and run with 'uvicorn crud_api:app --reload'\napp = FastAPI()\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n\n# In-memory database\nbooks_db: List[Book] = [\n    Book(id=1, title='The Great Gatsby', author='F. Scott Fitzgerald')\n]\n\n@app.post('/books', status_code=status.HTTP_201_CREATED, response_model=Book)\nasync def create_book(book_payload: Book):\n    \"\"\"Creates a new book and adds it to the database.\"\"\"\n    new_id = max(b.id for b in books_db) + 1 if books_db else 1\n    new_book = Book(id=new_id, title=book_payload.title, author=book_payload.author)\n    books_db.append(new_book)\n    return new_book\n\n# Placeholder for the GET endpoint (to be implemented next)\n@app.get('/books', response_model=List[Book])\nasync def get_all_books():\n    return books_db\n\n\nimport requests\nimport json\n\n# Example 2: Client script to test the CREATE functionality\nAPI_BASE_URL = 'http://127.0.0.1:8000'\n\nprint('--- Testing the CREATE (POST) endpoint ---')\n\n# --- First, see the initial state ---\ninitial_response = requests.get(f'{API_BASE_URL}/books')\nprint(f'Initial books: {json.dumps(initial_response.json(), indent=2)}')\n\n# --- Now, create a new book ---\nnew_book_data = {\n    'id': 0, # ID will be ignored and reassigned by the server\n    'title': '1984',\n    'author': 'George Orwell'\n}\n\ncreate_response = requests.post(f'{API_BASE_URL}/books', json=new_book_data)\n\nprint(f'\\nCreate Response Status Code: {create_response.status_code}')\nprint(f'Create Response Body: {json.dumps(create_response.json(), indent=2)}')\n\n# --- Finally, check the new state ---\nfinal_response = requests.get(f'{API_BASE_URL}/books')\nprint(f'\\nFinal books: {json.dumps(final_response.json(), indent=2)}')\n"
          },
          {
            "id": "t18-read-operations",
            "title": "Read Operations (GET)",
            "desc": "Implement the 'Read' functionality with endpoints to get a list of all resources and a single resource by its ID.",
            "note": "The 'Read' operation is fundamental to any API, as it allows clients to retrieve data. In a RESTful API, this is typically handled by two separate endpoints using the `GET` HTTP method. The first endpoint is for retrieving the entire collection of a resource. For our books API, this would be `GET /books`. This endpoint should query our data store (the in-memory list) and return an array of all book objects. The second endpoint is for retrieving a single, specific resource by its unique identifier. The convention is to use a path parameter in the URI, such as `GET /books/{book_id}`. This endpoint will receive the `book_id` as an argument. Its logic will then search the data store for a book with a matching ID. If the book is found, it is returned to the client with a `200 OK` status code. If no book with that ID exists, it's crucial to return a `404 Not Found` status code. This clear distinction between a successful response with data and a 'not found' error is a key aspect of a well-designed API. Implementing these two `GET` endpoints provides the essential functionality for clients to query and view the data managed by the API.",
            "code": "from fastapi import FastAPI, status, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\n\n# Example 1: Add GET endpoints to 'crud_api.py'\n# (This code block shows the complete app with the new additions)\napp = FastAPI()\n\nclass BookIn(BaseModel):\n    title: str\n    author: str\n\nclass Book(BookIn):\n    id: int\n\nbooks_db: List[Book] = [\n    Book(id=1, title='The Great Gatsby', author='F. Scott Fitzgerald'),\n    Book(id=2, title='To Kill a Mockingbird', author='Harper Lee')\n]\n\n@app.post('/books', status_code=status.HTTP_201_CREATED, response_model=Book)\nasync def create_book(book_payload: BookIn):\n    new_id = max(b.id for b in books_db) + 1 if books_db else 1\n    new_book = Book(id=new_id, **book_payload.dict())\n    books_db.append(new_book)\n    return new_book\n\n# GET endpoint for the collection\n@app.get('/books', response_model=List[Book])\nasync def get_all_books():\n    return books_db\n\n# GET endpoint for a single item\n@app.get('/books/{book_id}', response_model=Book)\nasync def get_book_by_id(book_id: int):\n    for book in books_db:\n        if book.id == book_id:\n            return book\n    # If the loop finishes without finding the book, raise a 404 error.\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Book not found')\n\n\nimport requests\nimport json\n\n# Example 2: Client script to test the READ functionality\nAPI_BASE_URL = 'http://127.0.0.1:8000'\n\nprint('--- Testing the READ (GET) endpoints ---')\n\n# --- Test Case 1: Get all books ---\nall_books_res = requests.get(f'{API_BASE_URL}/books')\nprint(f'\\nGet All Books Status: {all_books_res.status_code}')\nprint(f'All Books: {json.dumps(all_books_res.json(), indent=2)}')\n\n# --- Test Case 2: Get a single, existing book ---\nsingle_book_res = requests.get(f'{API_BASE_URL}/books/2')\nprint(f'\\nGet Book ID 2 Status: {single_book_res.status_code}')\nprint(f'Book 2: {json.dumps(single_book_res.json(), indent=2)}')\n\n# --- Test Case 3: Get a non-existent book ---\nnot_found_res = requests.get(f'{API_BASE_URL}/books/99')\nprint(f'\\nGet Book ID 99 Status: {not_found_res.status_code}')\nprint(f'Not Found Response: {json.dumps(not_found_res.json(), indent=2)}')\n"
          },
          {
            "id": "t19-update-operation",
            "title": "Update Operation (PUT)",
            "desc": "Implement the 'Update' functionality using a PUT endpoint to replace an existing resource.",
            "note": "The 'Update' operation allows clients to modify an existing resource. In a RESTful API, this is typically handled by the `PUT` HTTP method. A `PUT` request is directed at the specific URI of the resource to be updated, for example, `PUT /books/{book_id}`. A key characteristic of `PUT` is that it's idempotent and performs a full replacement. The client is expected to send the complete representation of the updated resource in the request body. The server then replaces the entire existing resource with this new representation. Our endpoint logic will first need to find the book with the specified `book_id`. If the book doesn't exist, it should return a `404 Not Found` error. If the book is found, we will update its data in our in-memory store with the data from the request payload. It's important that the ID remains the same. After a successful update, the API should return a `200 OK` status code, and it's good practice to return the updated representation of the resource in the response body. This confirms to the client exactly what the new state of the resource is. While `PATCH` is used for partial updates, `PUT` is the standard for a complete replacement, ensuring a predictable and consistent way to modify data.",
            "code": "# This code block shows the additions for the PUT endpoint to 'crud_api.py'\n# Assume the previous GET and POST endpoints from 't18-read-operations' exist.\nfrom fastapi import FastAPI, status, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\n\napp = FastAPI()\n\nclass BookIn(BaseModel):\n    title: str\n    author: str\n\nclass Book(BookIn):\n    id: int\n\nbooks_db: List[Book] = [\n    Book(id=1, title='The Great Gatsby', author='F. Scott Fitzgerald')\n]\n\n# ... (POST and GET endpoints from previous topics) ...\n@app.get('/books', response_model=List[Book])\nasync def get_all_books(): return books_db\n\n# UPDATE endpoint\n@app.put('/books/{book_id}', response_model=Book)\nasync def update_book(book_id: int, book_payload: BookIn):\n    for i, book in enumerate(books_db):\n        if book.id == book_id:\n            updated_book = Book(id=book_id, **book_payload.dict())\n            books_db[i] = updated_book\n            return updated_book\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Book not found')\n\n\nimport requests\nimport json\n\n# Example 2: Client script to test the UPDATE functionality\nAPI_BASE_URL = 'http://127.0.0.1:8000'\n\nprint('--- Testing the UPDATE (PUT) endpoint ---')\n\n# --- First, get the book we want to update ---\ninitial_book_res = requests.get(f'{API_BASE_URL}/books/1')\nprint(f'Book 1 before update: {initial_book_res.json()}')\n\n# --- Now, send the PUT request with the updated data ---\nupdated_data = {\n    'title': 'The Great Gatsby (Revised Edition)',\n    'author': 'F. Scott Fitzgerald'\n}\n\nupdate_res = requests.put(f'{API_BASE_URL}/books/1', json=updated_data)\n\nprint(f'\\nUpdate Response Status: {update_res.status_code}')\nprint(f'Update Response Body: {json.dumps(update_res.json(), indent=2)}')\n\n# --- Finally, get the book again to confirm it was updated ---\nfinal_book_res = requests.get(f'{API_BASE_URL}/books/1')\nprint(f'\\nBook 1 after update: {final_book_res.json()}')\n"
          },
          {
            "id": "t20-delete-operation",
            "title": "Delete Operation (DELETE)",
            "desc": "Implement the 'Delete' functionality with a DELETE endpoint to remove a resource.",
            "note": "The final CRUD operation is 'Delete', which allows clients to remove a resource permanently. This action is handled by the `DELETE` HTTP method. Like `GET` for a single item and `PUT`, a `DELETE` request targets the specific URI of the resource to be removed, such as `DELETE /books/{book_id}`. The request typically does not have a body. The server-side logic is straightforward: it finds the resource corresponding to the given `book_id`. If the resource doesn't exist, the server should respond with a `404 Not Found` status code, just as with `GET` and `PUT`. If the resource is found, it is removed from the data store. After a successful deletion, the server should respond with a `204 No Content` status code. The `204` code is appropriate because the action was successful, but there is no data to return in the response body. It is important not to return `200 OK` with a confirmation message, as `204` is the more precise and standard signal for this type of operation. `DELETE` operations are idempotent, meaning that making the same `DELETE` request multiple times has the same effect as making it once (the resource is deleted on the first call, and subsequent calls will likely result in a `404`, but the state of the system remains the same). Implementing this endpoint completes our CRUD API, providing clients with the full lifecycle management for the resource.",
            "code": "# This code block shows the additions for the DELETE endpoint to 'crud_api.py'\n# Assume the previous GET, POST, and PUT endpoints exist.\nfrom fastapi import FastAPI, status, HTTPException, Response\nfrom pydantic import BaseModel\nfrom typing import List\n\napp = FastAPI()\n\nclass BookIn(BaseModel):\n    title: str\n    author: str\n\nclass Book(BookIn):\n    id: int\n\nbooks_db: List[Book] = [\n    Book(id=1, title='Book One'),\n    Book(id=2, title='Book Two')\n]\n\n# ... (POST, GET, and PUT endpoints from previous topics) ...\n@app.get('/books', response_model=List[Book])\nasync def get_all_books(): return books_db\n\n# DELETE endpoint\n@app.delete('/books/{book_id}', status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    global books_db\n    book_to_delete = None\n    for book in books_db:\n        if book.id == book_id:\n            book_to_delete = book\n            break\n    \n    if not book_to_delete:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='Book not found')\n    \n    books_db.remove(book_to_delete)\n    # With a 204 status, FastAPI sends no body, so we return a Response object.\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n\n\nimport requests\n\n# Example 2: Client script to test the DELETE functionality\nAPI_BASE_URL = 'http://127.0.0.1:8000'\n\nprint('--- Testing the DELETE endpoint ---')\n\n# --- First, check the books list before deletion ---\ninitial_res = requests.get(f'{API_BASE_URL}/books')\nprint(f'Books before delete: {[book[\"id\"] for book in initial_res.json()]}')\n\n# --- Now, send the DELETE request for book with ID 2 ---\nbook_id_to_delete = 2\ndelete_res = requests.delete(f'{API_BASE_URL}/books/{book_id_to_delete}')\n\nprint(f'\\nDelete Response Status: {delete_res.status_code}')\n# A 204 response has no body, so .text or .json() will be empty.\nprint(f'Delete response has no content, as expected.')\n\n# --- Finally, check the books list again to confirm deletion ---\nfinal_res = requests.get(f'{API_BASE_URL}/books')\nprint(f'\\nBooks after delete: {[book[\"id\"] for book in final_res.json()]}')\n"
          }
        ]
      }
    ]
  }
]
